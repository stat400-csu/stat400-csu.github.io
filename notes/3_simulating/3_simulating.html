<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Chapter 3: Methods for Simulating Data" />






<meta name="description" content="Chapter 3: Methods for Simulating Data">

<script id="pandoc-meta" type="application/json">
{"output":{"pagedown::html_paged":{"self_contained":true,"css":["../style/my-style-page.css","default-fonts","default-page","default"],"number_sections":true}},"title":"Chapter 3: Methods for Simulating Data"}
</script>

<title>Chapter 3: Methods for Simulating Data</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  let beforePaged = PagedConfig.before;
  window.PagedConfig.before = async () => {
    if (beforePaged) await beforePaged();
    return new Promise((resolve, reject) => {
      var script = document.createElement("script");
      script.type = "text/javascript";
      var src = `https://mathjax.rstudio.com/latest/MathJax.js` + "?config=TeX-MML-AM_CHTML";
      if (location.protocol !== "file:" && /^https?:/.test(src))
        src = src.replace(/^https?:/, '');
      script.src = src;
      window.MathJax = {
        AuthorInit: () => {
          MathJax.Hub.Register.StartupHook("Begin", () => {
            MathJax.Hub.Queue(resolve);
          });
        }
      };
      document.getElementsByTagName("head")[0].appendChild(script);
    });
  };
})();
</script>

<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: local('Old Standard TT Regular'), local('OldStandardTT-Regular'), url(data:font/ttf;base64,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AYoAPgIcACwC9AA+Ap4APgKeAD4DRgA+AwIAPgMCAD4CvABGArwARgK8AEYCvABGArwARgK8AEYCvABGBBgARgKoAD4CqAA+ArwARgLMAD4CbABYAsoASAMMADQDDAA0AwwANAMMADQDDAA0AwQALAQsACYC7gAuAtgAKgLYACoCjABEAe4ALgHuAC4B7gAuAe4ALgHuAC4B7gAuAe4ALgK8AC4CAAAWAbQAMAG0ADACCgAwAfQAMAHMADABzAAwAcwAMAHMADABzAAwAUoAHAIcADQCIAAcAQ4AJgEOACYBDgAmARoABwEaAAsBDv/0AUD/2gIIABwBDgAcAXQAHAMaACYCHAAmAhwAJgHwADAB8AAwAfAAMAHwADAB8AAwAfAAMAHwADAC/gAwAgYAHAH0ABoB9gAwAZoAJgGyADQCDgAcAV4AHAIWACACFgAgAhYAIAIWACACFgAgAhIAEgMIABICCAAiAhIAEgISABICEgASAbgAKAISABwCEgAcAXwAPgF8AEYCRAAwAkQAeAJEAEoCRABIAkQAOAJEAFYCRABQAkQAWgJEADwCRABOAXwAHgF8AFQBfAA0AXwARAF8ACwBfAA2AXwANgF8ADwBfAAoAXwAMgF8AB4BfABUAXwANAF8AEQBfAAsAXwANgF8ADYBfAA8AXwAKAF8ADIBfAAeAXwAVAF8ADQBfABEAXwALAF8ADYBfAA2AXwAPAF8ACgBfAAyAFL/gAM0AFQDNABUAzQARAH2AEgBwgA4ARgATgH0AIgBGABOARgASANIAE4BGABOARgATgKsAFEBGABOAdYAQAHWACIBigBWAPAAVgEYAEgBwgA4AggAAAGkAGgBpABUAXwAeAF8AEYBcgBiAXIAMAPoADwCbAA8AXIAPAFyADwB4ABsAeAAcgFKAGwBSgBbAdIASAHSAEYB0gBIARgARgEYAEgBGABIARgAAACkAAAAAAAAAkQAcAJEADQCRAA+AkQAIgLQAEACRAAOAjAAMAOsADADrAAwA6wAnAOsADADrAAwA6wAUAOsAFQDrAAwApQAMAJEADACXgA+A1wAYAF4ADABeAAwAzQAMAMSADYCHABAAoAAZAM0ADADNAAwA9QAHgJEAJoBHAB4ARwAeAJEAD4BBAAsAawALADIACgAyAAoAXEAZAGCAGQBzgBkAeQAZAFxAGQBzABkAYwAZAHkAGQAAQAAAvr/EgDsBZj8zP0iBWoAAQAAAAAAAAAAAAAAAAAAAQAABAJcAZAABQAAAooCWAAAAEsCigJYAAABXgAyAREAAAAABQAAAAAAAAAAAAAHAAAAAQAAAAAAAAAAUGZFZADAAAAiFQL6/xIA7AO0ARogAAGXAAAAAAHIAsgAAAAgAAMAAAACAAAAAwAAABQAAwABAAAAFAAEAnwAAAA8ACAABAAcAAAADQAvADkAfgD/ATEBUwK8AsYC2gLcIAkgCyAUIBogHiAiICYgMyA6IEQgdCCsISIhkSGTIhIiFf//AAAAAAANACAAMAA6AKABMQFSArsCxgLaAtwgCSALIBMgGCAcICIgJiAyIDkgRCB0IKwhIiGRIZMiEiIV//8AAf/1AAAATwAAAAD/IwAAAAD+NP4k/iPgyeDIAADgtgAA4Izgi+DC4JDgY+At4Cvfzd9W31Xeyt7FAAEAAAAAADgAAABUANwAAAGYAZoAAAAAAAAAAAAAAZIAAAGSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwCyALgAtADWAOYA6gC5AMEAwgCrANsAsADFALUAuwCvALoA4QDfAOAAtgDpAAQADAANAA8AEQAWABcAGAAZAB4AHwAgACIAIwAlAC0ALwAwADEAMgAzADgAOQA6ADsAPQC/AKwAwADzALwA/AA+AEYARwBJAEsAUABRAFIAUwBZAFoAWwBdAF4AYABoAGoAawBsAG4AbwB0AHUAdgB3AHoAvQDxAL4A4wDRALMA1ADYANUA2QDyAOwA+wDtAH0AxwDkAMYA7gD9APAA4gCfAKAA+ADlAOsArQD5AJ4AfgDIAKkAqACqALcACAAFAAYACgAHAAkACwAOABUAEgATABQAHQAaABsAHAAQACQAKQAmACcAKwAoAN0AKgA3ADQANQA2ADwALgBtAEIAPwBAAEQAQQBDAEUASABPAEwATQBOAFgAVQBWAFcASgBfAGQAYQBiAGYAYwDeAGUAcwBwAHEAcgB4AGkAeQAsAGcA9wD2AMQAwwDMAM0Ay7AALCCwAFVYRVkgIEu4AA5RS7AGU1pYsDQbsChZYGYgilVYsAIlYbkIAAgAY2MjYhshIbAAWbAAQyNEsgABAENgQi2wASywIGBmLbACLCBkILDAULAEJlqyKAEKQ0VjRbAGRVghsAMlWVJbWCEjIRuKWCCwUFBYIbBAWRsgsDhQWCGwOFlZILEBCkNFY0VhZLAoUFghsQEKQ0VjRSCwMFBYIbAwWRsgsMBQWCBmIIqKYSCwClBYYBsgsCBQWCGwCmAbILA2UFghsDZgG2BZWVkbsAErWVkjsABQWGVZWS2wAywgRSCwBCVhZCCwBUNQWLAFI0KwBiNCGyEhWbABYC2wBCwjISMhIGSxBWJCILAGI0KwBkVYG7EBCkNFY7EBCkOwBGBFY7ADKiEgsAZDIIogirABK7EwBSWwBCZRWGBQG2FSWVgjWSFZILBAU1iwASsbIbBAWSOwAFBYZVktsAUssAdDK7IAAgBDYEItsAYssAcjQiMgsAAjQmGwAmJmsAFjsAFgsAUqLbAHLCAgRSCwC0NjuAQAYiCwAFBYsEBgWWawAWNgRLABYC2wCCyyBwsAQ0VCKiGyAAEAQ2BCLbAJLLAAQyNEsgABAENgQi2wCiwgIEUgsAErI7AAQ7AEJWAgRYojYSBkILAgUFghsAAbsDBQWLAgG7BAWVkjsABQWGVZsAMlI2FERLABYC2wCywgIEUgsAErI7AAQ7AEJWAgRYojYSBksCRQWLAAG7BAWSOwAFBYZVmwAyUjYUREsAFgLbAMLCCwACNCsgsKA0VYIRsjIVkqIS2wDSyxAgJFsGRhRC2wDiywAWAgILAMQ0qwAFBYILAMI0JZsA1DSrAAUlggsA0jQlktsA8sILAQYmawAWMguAQAY4ojYbAOQ2AgimAgsA4jQiMtsBAsS1RYsQRkRFkksA1lI3gtsBEsS1FYS1NYsQRkRFkbIVkksBNlI3gtsBIssQAPQ1VYsQ8PQ7ABYUKwDytZsABDsAIlQrEMAiVCsQ0CJUKwARYjILADJVBYsQEAQ2CwBCVCioogiiNhsA4qISOwAWEgiiNhsA4qIRuxAQBDYLACJUKwAiVhsA4qIVmwDENHsA1DR2CwAmIgsABQWLBAYFlmsAFjILALQ2O4BABiILAAUFiwQGBZZrABY2CxAAATI0SwAUOwAD6yAQEBQ2BCLbATLACxAAJFVFiwDyNCIEWwCyNCsAojsARgQiBgsAFhtRERAQAOAEJCimCxEgYrsIkrGyJZLbAULLEAEystsBUssQETKy2wFiyxAhMrLbAXLLEDEystsBgssQQTKy2wGSyxBRMrLbAaLLEGEystsBsssQcTKy2wHCyxCBMrLbAdLLEJEystsCksIyCwEGJmsAFjsAZgS1RYIyAusAFdGyEhWS2wKiwjILAQYmawAWOwFmBLVFgjIC6wAXEbISFZLbArLCMgsBBiZrABY7AmYEtUWCMgLrABchshIVktsB4sALANK7EAAkVUWLAPI0IgRbALI0KwCiOwBGBCIGCwAWG1EREBAA4AQkKKYLESBiuwiSsbIlktsB8ssQAeKy2wICyxAR4rLbAhLLECHistsCIssQMeKy2wIyyxBB4rLbAkLLEFHistsCUssQYeKy2wJiyxBx4rLbAnLLEIHistsCgssQkeKy2wLCwgPLABYC2wLSwgYLARYCBDI7ABYEOwAiVhsAFgsCwqIS2wLiywLSuwLSotsC8sICBHICCwC0NjuAQAYiCwAFBYsEBgWWawAWNgI2E4IyCKVVggRyAgsAtDY7gEAGIgsABQWLBAYFlmsAFjYCNhOBshWS2wMCwAsQACRVRYsAEWsC8qsQUBFUVYMFkbIlktsDEsALANK7EAAkVUWLABFrAvKrEFARVFWDBZGyJZLbAyLCA1sAFgLbAzLACwAUVjuAQAYiCwAFBYsEBgWWawAWOwASuwC0NjuAQAYiCwAFBYsEBgWWawAWOwASuwABa0AAAAAABEPiM4sTIBFSohLbA0LCA8IEcgsAtDY7gEAGIgsABQWLBAYFlmsAFjYLAAQ2E4LbA1LC4XPC2wNiwgPCBHILALQ2O4BABiILAAUFiwQGBZZrABY2CwAENhsAFDYzgtsDcssQIAFiUgLiBHsAAjQrACJUmKikcjRyNhIFhiGyFZsAEjQrI2AQEVFCotsDgssAAWsBAjQrAEJbAEJUcjRyNhsAlDK2WKLiMgIDyKOC2wOSywABawECNCsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgsAhDIIojRyNHI2EjRmCwBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2EjICCwBCYjRmE4GyOwCENGsAIlsAhDRyNHI2FgILAEQ7ACYiCwAFBYsEBgWWawAWNgIyCwASsjsARDYLABK7AFJWGwBSWwAmIgsABQWLBAYFlmsAFjsAQmYSCwBCVgZCOwAyVgZFBYIRsjIVkjICCwBCYjRmE4WS2wOiywABawECNCICAgsAUmIC5HI0cjYSM8OC2wOyywABawECNCILAII0IgICBGI0ewASsjYTgtsDwssAAWsBAjQrADJbACJUcjRyNhsABUWC4gPCMhG7ACJbACJUcjRyNhILAFJbAEJUcjRyNhsAYlsAUlSbACJWG5CAAIAGNjIyBYYhshWWO4BABiILAAUFiwQGBZZrABY2AjLiMgIDyKOCMhWS2wPSywABawECNCILAIQyAuRyNHI2EgYLAgYGawAmIgsABQWLBAYFlmsAFjIyAgPIo4LbA+LCMgLkawAiVGsBBDWFAbUllYIDxZLrEuARQrLbA/LCMgLkawAiVGsBBDWFIbUFlYIDxZLrEuARQrLbBALCMgLkawAiVGsBBDWFAbUllYIDxZIyAuRrACJUawEENYUhtQWVggPFkusS4BFCstsEEssDgrIyAuRrACJUawEENYUBtSWVggPFkusS4BFCstsEIssDkriiAgPLAEI0KKOCMgLkawAiVGsBBDWFAbUllYIDxZLrEuARQrsARDLrAuKy2wQyywABawBCWwBCYgLkcjRyNhsAlDKyMgPCAuIzixLgEUKy2wRCyxCAQlQrAAFrAEJbAEJSAuRyNHI2EgsAQjQrAJQysgsGBQWCCwQFFYswIgAyAbswImAxpZQkIjIEewBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2GwAiVGYTgjIDwjOBshICBGI0ewASsjYTghWbEuARQrLbBFLLEAOCsusS4BFCstsEYssQA5KyEjICA8sAQjQiM4sS4BFCuwBEMusC4rLbBHLLAAFSBHsAAjQrIAAQEVFBMusDQqLbBILLAAFSBHsAAjQrIAAQEVFBMusDQqLbBJLLEAARQTsDUqLbBKLLA3Ki2wSyywABZFIyAuIEaKI2E4sS4BFCstsEwssAgjQrBLKy2wTSyyAABEKy2wTiyyAAFEKy2wTyyyAQBEKy2wUCyyAQFEKy2wUSyyAABFKy2wUiyyAAFFKy2wUyyyAQBFKy2wVCyyAQFFKy2wVSyzAAAAQSstsFYsswABAEErLbBXLLMBAABBKy2wWCyzAQEAQSstsFksswAAAUErLbBaLLMAAQFBKy2wWyyzAQABQSstsFwsswEBAUErLbBdLLIAAEMrLbBeLLIAAUMrLbBfLLIBAEMrLbBgLLIBAUMrLbBhLLIAAEYrLbBiLLIAAUYrLbBjLLIBAEYrLbBkLLIBAUYrLbBlLLMAAABCKy2wZiyzAAEAQistsGcsswEAAEIrLbBoLLMBAQBCKy2waSyzAAABQistsGosswABAUIrLbBrLLMBAAFCKy2wbCyzAQEBQistsG0ssQA6Ky6xLgEUKy2wbiyxADorsD4rLbBvLLEAOiuwPystsHAssAAWsQA6K7BAKy2wcSyxATorsD4rLbByLLEBOiuwPystsHMssAAWsQE6K7BAKy2wdCyxADsrLrEuARQrLbB1LLEAOyuwPistsHYssQA7K7A/Ky2wdyyxADsrsEArLbB4LLEBOyuwPistsHkssQE7K7A/Ky2weiyxATsrsEArLbB7LLEAPCsusS4BFCstsHwssQA8K7A+Ky2wfSyxADwrsD8rLbB+LLEAPCuwQCstsH8ssQE8K7A+Ky2wgCyxATwrsD8rLbCBLLEBPCuwQCstsIIssQA9Ky6xLgEUKy2wgyyxAD0rsD4rLbCELLEAPSuwPystsIUssQA9K7BAKy2whiyxAT0rsD4rLbCHLLEBPSuwPystsIgssQE9K7BAKy2wiSyzCQQCA0VYIRsjIVlCK7AIZbADJFB4sQUBFUVYMFktAAAAS7gAyFJYsQEBjlmwAbkIAAgAY3CxAAdCtVxINCAEACqxAAdCQApPCDsIJwgVBwQIKrEAB0JAClkGRQYxBh4FBAgqsQALQr0UAA8ACgAFgAAEAAkqsQAPQr0AQABAAEAAQAAEAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWUAKUQg9CCkIFwcEDCq4Af+FsASNsQIARLMFZAYAREQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAFgAGAAYAsgAAAHIAAD/GgO0/uYC2v/uAdT/9P8SA7T+5gBYAFgAGAAYAsgAAAK6AcgAAP8aA7T+5gLa/+4CugHU//T/EgO0/uYAWABYABgAGAEI/2QCugHIAAD/GgO0/uYBCP9aAroB1P/0/xoDtP7mAFgAWAAYABgCwgEWAroByAAA/xoDtP7mAsIBDgK6AdT/9P8SA7T+5gAAAAAACABmAAMAAQQJAAAAigAAAAMAAQQJAAEAHgCKAAMAAQQJAAIADgCoAAMAAQQJAAMAQAC2AAMAAQQJAAQALgD2AAMAAQQJAAUAGgEkAAMAAQQJAAYAKgE+AAMAAQQJAA4ANAFoAEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADEAMQAgAFQAaABlACAATwBsAGQAIABTAHQAYQBuAGQAYQByAGQAIABQAHIAbwBqAGUAYwB0ACAAQQB1AHQAaABvAHIAcwAgACgAYQBtAGsAcgB5AHUAawBvAHYAQABnAG0AYQBpAGwALgBjAG8AbQApAE8AbABkACAAUwB0AGEAbgBkAGEAcgBkACAAVABUAFIAZQBnAHUAbABhAHIAMwAuADAAMAAwADsAUABmAEUAZAA7AE8AbABkAFMAdABhAG4AZABhAHIAZABUAFQALQBSAGUAZwB1AGwAYQByAE8AbABkACAAUwB0AGEAbgBkAGEAcgBkACAAVABUACAAUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMwAuADAAMAAwAE8AbABkAFMAdABhAG4AZABhAHIAZABUAFQALQBSAGUAZwB1AGwAYQByAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATAAAAAIAAAAAAAD/tQAyAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQIAAgADACQAyQDHAGIArQBjAK4AkAAlACYAZAAnAOkAKABlAMgAygDLACkAKgArACwAzADNAM4AzwAtAC4ALwEDADAAMQBmADIA0ADRAGcA0wCRAK8AsAAzAO0ANAA1ADYANwA4ANQA1QBoANYAOQA6ADsAPADrAD0ARABpAGsAbABqAG4AbQCgAEUARgBvAEcA6gBIAHAAcgBzAHEASQBKAEsATADXAHQAdgB3AHUATQBOAE8BBABQAFEAeABSAHkAewB8AHoAoQB9ALEAUwDuAFQAVQBWAIkAVwBYAH4AgACBAH8AWQBaAFsAXADsALoAXQDAAMEAnQCeABMAFAAVABYAFwAYABkAGgAbABwBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIAvAD0APUA9gANAD8AwwCHAB0ADwCrAAQAowAGABEAIgCiAAUACgAeABIAQgBeAGAAPgBAAAsADACzALIAEAEjAKkAqgC+AL8AxQC0ALUAtgC3AMQBJAElASYAhAC9AAcBJwCFAJYBKAAOAO8A8AC4ACAAIQAfAJMAYQCkASkACAEqASsAIwAJAIgAhgCLAIoAjACDAF8A6ABBASwBLQEuAS8AjQDeANgAjgBDANoA3QDZBE5VTEwETGRvdARsZG90CXplcm8uZG5vbQhvbmUuZG5vbQh0d28uZG5vbQp0aHJlZS5kbm9tCWZvdXIuZG5vbQlmaXZlLmRub20Ic2l4LmRub20Kc2V2ZW4uZG5vbQplaWdodC5kbm9tCW5pbmUuZG5vbQl6ZXJvLm51bXIIb25lLm51bXIIdHdvLm51bXIKdGhyZWUubnVtcglmb3VyLm51bXIJZml2ZS5udW1yCHNpeC5udW1yCnNldmVuLm51bXIKZWlnaHQubnVtcgluaW5lLm51bXIHdW5pMjA3MAd1bmkwMEI5B3VuaTAwQjIHdW5pMDBCMwd1bmkyMDc0B3VuaTIwNzUHdW5pMjA3Ngd1bmkyMDc3B3VuaTIwNzgHdW5pMjA3OQd1bmkwMEFEB3VuaTAwQTAHdW5pMjAwOQd1bmkyMDBCBEV1cm8HdW5pMjIxNQd1bmkwMEI1B2Fycm93dXAJYXJyb3dkb3duBm1pbnV0ZQZzZWNvbmQHdW5pMDJCQwd1bmkwMkJCAAAAAQAB//8ADwABAAAADAAAAAAAAAACAAwABAAEAAEAEQARAAEAGQAZAAEAJQAlAAEAMwAzAAEAOwA7AAEAPgA+AAEASwBLAAEAUwBUAAEAYABgAAEAbwBvAAEAdwB3AAEAAQAAAAoAQgBcAANERkxUABRjeXJsACBsYXRuACwABAAAAAD//wABAAAABAAAAAD//wABAAEABAAAAAD//wABAAIAA2tlcm4AFGtlcm4AFGtlcm4AFAAAAAEAAAABAAQAAgAIAAQADgTGBc4F9AACA0wABAAAA4AD6AASABcAAP/Q/9D/qP+w/1z/iP9w/8D/wP/UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6v/g/9gAAAAAAAAAAP/Y/9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zP+4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/U/9T/0AAAAAAAAAAA/8D/qAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+o/2z/qP/A/9D/uP+4/7j/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4P/IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8D/ogAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2P/YAAAAAAAAAAAAAAAAAAAAAAAAAAD/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8T/yP/I/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/k/7D/wAAAAAAAAAAA/8T/sAAAAAAAAAAAAAAAAAAA/+AAAAAAAAAAAAAAAAD/6gAAAAAAAAAAAAAAAP+4/3L/gP/U/+T/zP+i/9wAAAAAAAAAAAAAAAAAAAAA/9wAAP/UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/oAAAAAAAAAAAAAAAA/+j/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+w/5j/uP/M/9z/vP/A/9T/5AAAAAAAAAAA/+T/6AAAAAAAAAAAAAAAAAAAAAD/oP+GAAD/0AAA/9AAAP/UAAAAAAAAAAAAAAAA/8AAAAAAAAAAAAAAAAAAAAAA/3D/aAAA/7D/yP+g/2j/oAAAAAD/1P/UAAD/6P/oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/5AAAAAAAAAAAAAAAAAAAAAD/0AAAAAAAAAAAAAD/4P/o//D/kP+IAAD/wP/U/7j/qP+4AAAAAP/A/+AAAgAIAAQACgAAAAwAEAAHABYAFwAMAB4AIAAOACMAKQARACsAKwAYAC0ALQAZADAAPAAaAAEADAAxAAEAAgACAAMAAwAAAAAAAAAAAAAABAAFAAAAAAAAAAAAAAAAAAYABwAIAAAAAAAFAAUACQAJAAkACQAJAAAACQAAAAoAAAAAAAsADAANAA4ADgAOAA4ADgAPAA8AEAARABEAAgAiAAQACgALAAsACwAMAA0ADgABABcAFwABAB4AHgANACUAKQACACsALAACAC8ALwACADIAMgADADMANwAEADgAOQAFADoAOgAUADsAPAAGAD4APwAOAEAARAAPAEUARQAOAEcASQAQAEsATAAQAFEAUQASAFMAVQAVAFgAWAAVAFkAWQATAF0AXgAVAGAAYQAQAGcAZwAQAG8AcAAWAHMAcwAWAHQAdAAIAHUAdQAJAHcAeAAKALAAsQARALUAtQARAM0AzQAHAM8AzwAHAAIAYAAEAAAAiAC2AAUACAAA/+D/6P/wAAAAAAAAAAAAAP/W//AAAP/oAAAAAAAAAAAAAAAAAAAAAP/g/9D/8AAAAAAAAAAAAAAAAP/oAAAAAAAAAAAAAAAA/+D/0P/wAAIABgA+AEQAAABGAEYABwBgAGQACABmAGYADQBoAGkADgB0AHkAEAACAAcARgBGAAEAYABkAAEAZgBmAAEAaABpAAEAdAB1AAIAdgB2AAMAdwB5AAQAAgANAD4APwAFAEUARQAFAEcASQAGAEsATAAGAE0ATwAHAGAAYQAGAGIAZAAHAGYAZgAHAGcAZwAGAHQAdAABAHUAdQACAHYAdgAEAHcAeAADAAIAOAAEAAAAQAAWAAEAAwAA/0z/mgACAAIABAAKAAEAHgAeAAIAAgASAAQAAAAaABoAAQABAAAAAQACAMwAzgACAAAAAAABAAAACgBqAPQAA0RGTFQAFGN5cmwAJmxhdG4AOAAEAAAAAP//AAQAAAAEAAgADQAEAAAAAP//AAQAAQAFAAkADgAKAAFDQVQgABgAAP//AAQAAgAGAAoADwAA//8ABQADAAcACwAMABAAEWRub20AaGRub20AaGRub20AaGRub20AaGZyYWMAbmZyYWMAbmZyYWMAbmZyYWMAbmxpZ2EAeGxpZ2EAeGxpZ2EAeGxpZ2EAeGxvY2wAfm51bXIAhG51bXIAhG51bXIAhG51bXIAhAAAAAEAAgAAAAMAAwAEAAUAAAABAAYAAAABAAAAAAABAAEACQAUAHoAWABmAHoAkgDaAQIBMAAGAAAAAgAKACQAAwAAAAIAFAAuAAEAFAABAAAABwABAAEAWwADAAAAAgAaABQAAQAaAAEAAAAHAAEAAQCtAAEAAQAgAAEAAAABAAgAAQAoAAoAAQAAAAEACAABAAb/7AABAAEAuwABAAAAAQAIAAEABgAUAAIAAQB/AIgAAAAGAAAAAgAKACIAAwABABIAAQA0AAAAAQAAAAgAAQABAKcAAwABABIAAQAcAAAAAQAAAAgAAgABAIkAkgAAAAIAAQCTAJwAAAAEAAAAAQAIAAEAGgABAAgAAgAGAAwAewACAFMAfAACAFsAAQABAFAABAAAAAEACAABAB4AAgAKABQAAQAEACEAAgCtAAEABABcAAIArQABAAIAIABbAAEAAAABAAgAAgAiAA4AfQB+AH0AfgCJAIoAiwCMAI0AjgCPAJAAkQCSAAEADgAEACUAPgBgAJMAlACVAJYAlwCYAJkAmgCbAJwAAA==) format('truetype');
}
body {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;
}
blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}
</style>
<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.level1 {
break-before: recto;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
h1, h2, h3, h4, h5, h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: hidden;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const afterPaged = window.PagedConfig.after;

  window.PagedConfig.after = () => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged();

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      pagedownListener('');
    } else {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
    }
  };
})();
</script>
<script>(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	global.PagedPolyfill = factory();
}(typeof self !== 'undefined' ? self : this, function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n.default || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function"){
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if(element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		let after = node;

		if (after.nextSibling) {
			if (limiter && node === limiter) {
				return;
			}
			after = after.nextSibling;
		} else {
			while (after) {
				after = after.parentNode;
				if (limiter && after === limiter) {
					after = undefined;
					break;
				}
				if (after && after.nextSibling) {
					after = after.nextSibling;
					break;
				}
			}
		}

		return after;
	}

	function nodeBefore(node, limiter) {
		let before = node;
		if (before.previousSibling) {
			if (limiter && node === limiter) {
				return;
			}
			before = before.previousSibling;
		} else {
			while (before) {
				before = before.parentNode;
				if (limiter && before === limiter) {
					before = undefined;
					break;
				}
				if (before && before.previousSibling) {
					before = before.previousSibling;
					break;
				}
			}
		}

		return before;
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after);
		}

		return after;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				(node.dataset.page || node.dataset.afterPage)
			 ) {
			return true;
		}

		return false;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

	  /**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
	  triggerSync(){
	    var args = arguments;
	    var context = this.context;
	    var results = [];

	    this.hooks.forEach(function(task) {
	      var executing = task.apply(context, args);

	      results.push(executing);
	    });


	    return results;
	  }

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, maxChars) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.maxChars = maxChars || MAX_CHARS_PER_BREAK;
		}

		async renderTo(wrapper, source, breakToken, bounds=this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			while (!done && !newBreakToken) {
				next = walker.next();
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset=0) {
			return {
				node,
				offset
			};
		}

		shouldBreak(node) {
			let previousSibling = node.previousSibling;
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node);
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow=true, rebuild=true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function() {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function(e) {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let { width, height } = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if(window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						renderedNode = findElement(prevValidNode(temp), rendered);
						return;
					}

					node = findElement(renderedNode, source);
					offset = 0;
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					node = child(parent, index);
					offset = 0;
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return {
				node,
				offset
			};

		}

		findBreakToken(rendered, source, bounds=this.bounds, extract=true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);

				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});


				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds=this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let { width } = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds=this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end =  Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.floor(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						if (isElement(node) ) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.setStartBefore(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

					}

					if (!range && isText(node) &&
							node.textContent.trim().length &&
							window.getComputedStyle(node.parentNode)["break-inside"] !== "avoid") {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if(left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right < end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds=this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if(!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer);

			return extracted;
		}

		hyphenateAtBreak(startContainer) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length-1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (/^\w|\u00AD$/.test(prevLetter)) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += "\u2011";
				}
			}
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum+1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute('id', id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if(e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function() {
				if(this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element &&this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver( entries => {

				if (!this.listening) {
					return;
				}

				for (let entry of entries) {
					const cr = entry.contentRect;

					if (cr.height > prevHeight) {
						this.checkOverflowAfterResize(contents);
						prevHeight = wrapper.getBoundingClientRect().height;
					} else if (cr.height < prevHeight ) { // TODO: calc line height && (prevHeight - cr.height) >= 22
						this.checkUnderflowAfterResize(contents);
						prevHeight = cr.height;
					}
				}
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			// let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);
			this.removeEmpty(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);
			this.removeEmpty(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				{ acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		removeEmpty(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_TEXT,
				{ acceptNode: function(node) {
					// Only remove more than a single space
					if (node.textContent.length > 1 && !node.textContent.trim()) {

						// Don't touch whitespace if text is preformated
						let parent = node.parentNode;
						let pre = isElement(parent) && parent.closest("pre");
						if (pre) {
							return NodeFilter.FILTER_REJECT;
						}

						return NodeFilter.FILTER_ACCEPT;
					} else {
						return NodeFilter.FILTER_REJECT;
					}
				} },
				false
			);

			let node;
			let current;
			node = treeWalker.nextNode();
			while(node) {
				current = node;
				node = treeWalker.nextNode();
				// if (!current.nextSibling || (current.nextSibling && current.nextSibling.nodeType === 1)) {
				current.parentNode.removeChild(current);
				// }
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		// isWrapper(element) {
		//   return wrappersRegex.test(element.nodeName);
		// }

		isText(node) {
			return node.tagName === "TAG";
		}

		isElement(node) {
			return node.nodeType === 1;
		}

		hasChildren(node) {
			return node.childNodes && node.childNodes.length;
		}


		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo) {
			// this.preview = preview;

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this._total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", content);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);

			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt);

			let done = false;
			let result;

			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && (true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}
		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/

		get total() {
			return this._total;
		}

		set total(num) {
			this.pagesArea.style.setProperty("--pagedjs-page-count", num);
			this._total = num;
		}

		loadFonts() {
			let fontPromises = [];
			document.fonts.forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//            item        item        item        item
	//          /------\    /------\    /------\    /------\
	//          | data |    | data |    | data |    | data |
	//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
	//          | next-+--->| next-+--->| next-+--->| next-+--> null
	//          \------/    \------/    \------/    \------/
	//             ^                                    ^
	//             |                list                |
	//             |              /------\              |
	//             \--------------+-head |              |
	//                            | tail-+--------------/
	//                            \------/
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var list = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var CssSyntaxError = function(message, source, offset, line, column) {
	    var error = createCustomError('CssSyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var error = CssSyntaxError;

	// token types (note: value shouldn't intersect with used char codes)
	var WHITESPACE = 1;
	var IDENTIFIER = 2;
	var NUMBER = 3;
	var STRING = 4;
	var COMMENT = 5;
	var PUNCTUATOR = 6;
	var CDO = 7;
	var CDC = 8;
	var ATKEYWORD = 14;
	var FUNCTION = 15;
	var URL$1 = 16;
	var RAW = 17;

	var TAB = 9;
	var N = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var TYPE = {
	    WhiteSpace:   WHITESPACE,
	    Identifier:   IDENTIFIER,
	    Number:           NUMBER,
	    String:           STRING,
	    Comment:         COMMENT,
	    Punctuator:   PUNCTUATOR,
	    CDO:                 CDO,
	    CDC:                 CDC,
	    AtKeyword:     ATKEYWORD,
	    Function:       FUNCTION,
	    Url:                 URL$1,
	    Raw:                 RAW,

	    ExclamationMark:      33,  // !
	    QuotationMark:        34,  // "
	    NumberSign:           35,  // #
	    DollarSign:           36,  // $
	    PercentSign:          37,  // %
	    Ampersand:            38,  // &
	    Apostrophe:           39,  // '
	    LeftParenthesis:      40,  // (
	    RightParenthesis:     41,  // )
	    Asterisk:             42,  // *
	    PlusSign:             43,  // +
	    Comma:                44,  // ,
	    HyphenMinus:          45,  // -
	    FullStop:             46,  // .
	    Solidus:              47,  // /
	    Colon:                58,  // :
	    Semicolon:            59,  // ;
	    LessThanSign:         60,  // <
	    EqualsSign:           61,  // =
	    GreaterThanSign:      62,  // >
	    QuestionMark:         63,  // ?
	    CommercialAt:         64,  // @
	    LeftSquareBracket:    91,  // [
	    Backslash:            92,  // \
	    RightSquareBracket:   93,  // ]
	    CircumflexAccent:     94,  // ^
	    LowLine:              95,  // _
	    GraveAccent:          96,  // `
	    LeftCurlyBracket:    123,  // {
	    VerticalLine:        124,  // |
	    RightCurlyBracket:   125,  // }
	    Tilde:               126   // ~
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
	var SYMBOL_TYPE = new SafeUint32Array(0x80);
	var PUNCTUATION = new SafeUint32Array(0x80);
	var STOP_URL_RAW = new SafeUint32Array(0x80);

	for (var i = 0; i < SYMBOL_TYPE.length; i++) {
	    SYMBOL_TYPE[i] = IDENTIFIER;
	}

	// fill categories
	[
	    TYPE.ExclamationMark,    // !
	    TYPE.QuotationMark,      // "
	    TYPE.NumberSign,         // #
	    TYPE.DollarSign,         // $
	    TYPE.PercentSign,        // %
	    TYPE.Ampersand,          // &
	    TYPE.Apostrophe,         // '
	    TYPE.LeftParenthesis,    // (
	    TYPE.RightParenthesis,   // )
	    TYPE.Asterisk,           // *
	    TYPE.PlusSign,           // +
	    TYPE.Comma,              // ,
	    TYPE.HyphenMinus,        // -
	    TYPE.FullStop,           // .
	    TYPE.Solidus,            // /
	    TYPE.Colon,              // :
	    TYPE.Semicolon,          // ;
	    TYPE.LessThanSign,       // <
	    TYPE.EqualsSign,         // =
	    TYPE.GreaterThanSign,    // >
	    TYPE.QuestionMark,       // ?
	    TYPE.CommercialAt,       // @
	    TYPE.LeftSquareBracket,  // [
	    // TYPE.Backslash,          // \
	    TYPE.RightSquareBracket, // ]
	    TYPE.CircumflexAccent,   // ^
	    // TYPE.LowLine,            // _
	    TYPE.GraveAccent,        // `
	    TYPE.LeftCurlyBracket,   // {
	    TYPE.VerticalLine,       // |
	    TYPE.RightCurlyBracket,  // }
	    TYPE.Tilde               // ~
	].forEach(function(key) {
	    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;
	    PUNCTUATION[Number(key)] = PUNCTUATOR;
	});

	for (var i = 48; i <= 57; i++) {
	    SYMBOL_TYPE[i] = NUMBER;
	}

	SYMBOL_TYPE[SPACE] = WHITESPACE;
	SYMBOL_TYPE[TAB] = WHITESPACE;
	SYMBOL_TYPE[N] = WHITESPACE;
	SYMBOL_TYPE[R] = WHITESPACE;
	SYMBOL_TYPE[F] = WHITESPACE;

	SYMBOL_TYPE[TYPE.Apostrophe] = STRING;
	SYMBOL_TYPE[TYPE.QuotationMark] = STRING;

	STOP_URL_RAW[SPACE] = 1;
	STOP_URL_RAW[TAB] = 1;
	STOP_URL_RAW[N] = 1;
	STOP_URL_RAW[R] = 1;
	STOP_URL_RAW[F] = 1;
	STOP_URL_RAW[TYPE.Apostrophe] = 1;
	STOP_URL_RAW[TYPE.QuotationMark] = 1;
	STOP_URL_RAW[TYPE.LeftParenthesis] = 1;
	STOP_URL_RAW[TYPE.RightParenthesis] = 1;

	// whitespace is punctuation ...
	PUNCTUATION[SPACE] = PUNCTUATOR;
	PUNCTUATION[TAB] = PUNCTUATOR;
	PUNCTUATION[N] = PUNCTUATOR;
	PUNCTUATION[R] = PUNCTUATOR;
	PUNCTUATION[F] = PUNCTUATOR;
	// ... hyper minus is not
	PUNCTUATION[TYPE.HyphenMinus] = 0;

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME,

	    SYMBOL_TYPE: SYMBOL_TYPE,
	    PUNCTUATION: PUNCTUATION,
	    STOP_URL_RAW: STOP_URL_RAW
	};

	var PUNCTUATION$1 = _const.PUNCTUATION;
	var STOP_URL_RAW$1 = _const.STOP_URL_RAW;
	var TYPE$1 = _const.TYPE;
	var FULLSTOP = TYPE$1.FullStop;
	var PLUSSIGN = TYPE$1.PlusSign;
	var HYPHENMINUS = TYPE$1.HyphenMinus;
	var PUNCTUATOR$1 = TYPE$1.Punctuator;
	var TAB$1 = 9;
	var N$1 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var BACK_SLASH = 92;
	var E = 101; // 'e'.charCodeAt(0)

	function firstCharOffset(source) {
	    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
	        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
	        return 1;
	    }

	    return 0;
	}

	function isHex(code) {
	    return (code >= 48 && code <= 57) || // 0 .. 9
	           (code >= 65 && code <= 70) || // A .. F
	           (code >= 97 && code <= 102);  // a .. f
	}

	function isNumber(code) {
	    return code >= 48 && code <= 57;
	}

	function isWhiteSpace(code) {
	    return code === SPACE$1 || code === TAB$1 || isNewline(code);
	}

	function isNewline(code) {
	    return code === R$1 || code === N$1 || code === F$1;
	}

	function getNewlineLength(source, offset, code) {
	    if (isNewline(code)) {
	        if (code === R$1 && offset + 1 < source.length && source.charCodeAt(offset + 1) === N$1) {
	            return 2;
	        }

	        return 1;
	    }

	    return 0;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (code >= 65 && code <= 90) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var refCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (testCode >= 65 && testCode <= 90) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== refCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    while (offset >= 0 && isWhiteSpace(source.charCodeAt(offset))) {
	        offset--;
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    while (offset < source.length && isWhiteSpace(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findCommentEnd(source, offset) {
	    var commentEnd = source.indexOf('*/', offset);

	    if (commentEnd === -1) {
	        return source.length;
	    }

	    return commentEnd + 2;
	}

	function findStringEnd(source, offset, quote) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // TODO: bad string
	        if (code === BACK_SLASH) {
	            offset++;
	        } else if (code === quote) {
	            offset++;
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    while (offset < source.length && isNumber(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findNumberEnd(source, offset, allowFraction) {
	    var code;

	    offset = findDecimalNumberEnd(source, offset);

	    // fraction: .\d+
	    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {
	        code = source.charCodeAt(offset + 1);

	        if (isNumber(code)) {
	            offset = findDecimalNumberEnd(source, offset + 1);
	        }
	    }

	    // exponent: e[+-]\d+
	    if (offset + 1 < source.length) {
	        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
	            code = source.charCodeAt(offset + 1);

	            if (code === PLUSSIGN || code === HYPHENMINUS) {
	                if (offset + 2 < source.length) {
	                    code = source.charCodeAt(offset + 2);
	                }
	            }

	            if (isNumber(code)) {
	                offset = findDecimalNumberEnd(source, offset + 2);
	            }
	        }
	    }

	    return offset;
	}

	// skip escaped unicode sequence that can ends with space
	// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
	function findEscapeEnd(source, offset) {
	    for (var i = 0; i < 7 && offset + i < source.length; i++) {
	        var code = source.charCodeAt(offset + i);

	        if (i !== 6 && isHex(code)) {
	            continue;
	        }

	        if (i > 0) {
	            offset += i - 1 + getNewlineLength(source, offset + i, code);
	            if (code === SPACE$1 || code === TAB$1) {
	                offset++;
	            }
	        }

	        break;
	    }

	    return offset;
	}

	function findIdentifierEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && PUNCTUATION$1[code] === PUNCTUATOR$1) {
	            break;
	        }
	    }

	    return offset;
	}

	function findUrlRawEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && STOP_URL_RAW$1[code] === 1) {
	            break;
	        }
	    }

	    return offset;
	}

	var utils = {
	    firstCharOffset: firstCharOffset,

	    isHex: isHex,
	    isNumber: isNumber,
	    isWhiteSpace: isWhiteSpace,
	    isNewline: isNewline,
	    getNewlineLength: getNewlineLength,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd,
	    findCommentEnd: findCommentEnd,
	    findStringEnd: findStringEnd,
	    findDecimalNumberEnd: findDecimalNumberEnd,
	    findNumberEnd: findNumberEnd,
	    findEscapeEnd: findEscapeEnd,
	    findIdentifierEnd: findIdentifierEnd,
	    findUrlRawEnd: findUrlRawEnd
	};

	var TYPE$2 = _const.TYPE;
	var NAME$1 = _const.NAME;
	var SYMBOL_TYPE$1 = _const.SYMBOL_TYPE;


	var firstCharOffset$1 = utils.firstCharOffset;
	var cmpStr$1 = utils.cmpStr;
	var isNumber$1 = utils.isNumber;
	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var findCommentEnd$1 = utils.findCommentEnd;
	var findStringEnd$1 = utils.findStringEnd;
	var findNumberEnd$1 = utils.findNumberEnd;
	var findIdentifierEnd$1 = utils.findIdentifierEnd;
	var findUrlRawEnd$1 = utils.findUrlRawEnd;

	var NULL = 0;
	var WHITESPACE$1 = TYPE$2.WhiteSpace;
	var IDENTIFIER$1 = TYPE$2.Identifier;
	var NUMBER$1 = TYPE$2.Number;
	var STRING$1 = TYPE$2.String;
	var COMMENT$1 = TYPE$2.Comment;
	var PUNCTUATOR$2 = TYPE$2.Punctuator;
	var CDO$1 = TYPE$2.CDO;
	var CDC$1 = TYPE$2.CDC;
	var ATKEYWORD$1 = TYPE$2.AtKeyword;
	var FUNCTION$1 = TYPE$2.Function;
	var URL$2 = TYPE$2.Url;
	var RAW$1 = TYPE$2.Raw;

	var N$2 = 10;
	var F$2 = 12;
	var R$2 = 13;
	var STAR = TYPE$2.Asterisk;
	var SLASH = TYPE$2.Solidus;
	var FULLSTOP$1 = TYPE$2.FullStop;
	var PLUSSIGN$1 = TYPE$2.PlusSign;
	var HYPHENMINUS$1 = TYPE$2.HyphenMinus;
	var GREATERTHANSIGN = TYPE$2.GreaterThanSign;
	var LESSTHANSIGN = TYPE$2.LessThanSign;
	var EXCLAMATIONMARK = TYPE$2.ExclamationMark;
	var COMMERCIALAT = TYPE$2.CommercialAt;
	var QUOTATIONMARK = TYPE$2.QuotationMark;
	var APOSTROPHE = TYPE$2.Apostrophe;
	var LEFTPARENTHESIS = TYPE$2.LeftParenthesis;
	var RIGHTPARENTHESIS = TYPE$2.RightParenthesis;
	var LEFTCURLYBRACKET = TYPE$2.LeftCurlyBracket;
	var RIGHTCURLYBRACKET = TYPE$2.RightCurlyBracket;
	var LEFTSQUAREBRACKET = TYPE$2.LeftSquareBracket;
	var RIGHTSQUAREBRACKET = TYPE$2.RightSquareBracket;

	var MIN_BUFFER_SIZE = 16 * 1024;
	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;
	var SafeUint32Array$1 = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	function computeLinesAndColumns(tokenizer, source) {
	    var sourceLength = source.length;
	    var start = firstCharOffset$1(source);
	    var lines = tokenizer.lines;
	    var line = tokenizer.startLine;
	    var columns = tokenizer.columns;
	    var column = tokenizer.startColumn;

	    if (lines === null || lines.length < sourceLength + 1) {
	        lines = new SafeUint32Array$1(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
	        columns = new SafeUint32Array$1(lines.length);
	    }

	    for (var i = start; i < sourceLength; i++) {
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$2 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$2) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    tokenizer.linesAnsColumnsComputed = true;
	    tokenizer.lines = lines;
	    tokenizer.columns = columns;
	}

	function tokenLayout(tokenizer, source, startPos) {
	    var sourceLength = source.length;
	    var offsetAndType = tokenizer.offsetAndType;
	    var balance = tokenizer.balance;
	    var tokenCount = 0;
	    var prevType = 0;
	    var offset = startPos;
	    var anchor = 0;
	    var balanceCloseCode = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
	        offsetAndType = new SafeUint32Array$1(sourceLength + 1024);
	        balance = new SafeUint32Array$1(sourceLength + 1024);
	    }

	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = code < 0x80 ? SYMBOL_TYPE$1[code] : IDENTIFIER$1;

	        balance[tokenCount] = sourceLength;

	        switch (type) {
	            case WHITESPACE$1:
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            case PUNCTUATOR$2:
	                switch (code) {
	                    case balanceCloseCode:
	                        balancePrev = balanceStart & OFFSET_MASK;
	                        balanceStart = balance[balancePrev];
	                        balanceCloseCode = balanceStart >> TYPE_SHIFT;
	                        balance[tokenCount] = balancePrev;
	                        balance[balancePrev++] = tokenCount;
	                        for (; balancePrev < tokenCount; balancePrev++) {
	                            if (balance[balancePrev] === sourceLength) {
	                                balance[balancePrev] = tokenCount;
	                            }
	                        }
	                        break;

	                    case LEFTSQUAREBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTSQUAREBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTCURLYBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTCURLYBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTPARENTHESIS:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTPARENTHESIS;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;
	                }

	                // /*
	                if (code === STAR && prevType === SLASH) {
	                    type = COMMENT$1;
	                    offset = findCommentEnd$1(source, offset + 1);
	                    tokenCount--; // rewrite prev token
	                    break;
	                }

	                // edge case for -.123 and +.123
	                if (code === FULLSTOP$1 && (prevType === PLUSSIGN$1 || prevType === HYPHENMINUS$1)) {
	                    if (offset + 1 < sourceLength && isNumber$1(source.charCodeAt(offset + 1))) {
	                        type = NUMBER$1;
	                        offset = findNumberEnd$1(source, offset + 2, false);
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // <!--
	                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
	                    if (offset + 2 < sourceLength &&
	                        source.charCodeAt(offset + 1) === HYPHENMINUS$1 &&
	                        source.charCodeAt(offset + 2) === HYPHENMINUS$1) {
	                        type = CDO$1;
	                        offset = offset + 3;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // -->
	                if (code === HYPHENMINUS$1 && prevType === HYPHENMINUS$1) {
	                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
	                        type = CDC$1;
	                        offset = offset + 2;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // ident(
	                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER$1) {
	                    offset = offset + 1;
	                    tokenCount--; // rewrite prev token
	                    balance[tokenCount] = balance[tokenCount + 1];
	                    balanceStart--;

	                    // 4 char length identifier and equal to `url(` (case insensitive)
	                    if (offset - anchor === 4 && cmpStr$1(source, anchor, offset, 'url(')) {
	                        // special case for url() because it can contain any symbols sequence with few exceptions
	                        anchor = findWhiteSpaceEnd$1(source, offset);
	                        code = source.charCodeAt(anchor);
	                        if (code !== LEFTPARENTHESIS &&
	                            code !== RIGHTPARENTHESIS &&
	                            code !== QUOTATIONMARK &&
	                            code !== APOSTROPHE) {
	                            // url(
	                            offsetAndType[tokenCount++] = (URL$2 << TYPE_SHIFT) | offset;
	                            balance[tokenCount] = sourceLength;

	                            // ws*
	                            if (anchor !== offset) {
	                                offsetAndType[tokenCount++] = (WHITESPACE$1 << TYPE_SHIFT) | anchor;
	                                balance[tokenCount] = sourceLength;
	                            }

	                            // raw
	                            type = RAW$1;
	                            offset = findUrlRawEnd$1(source, anchor);
	                        } else {
	                            type = URL$2;
	                        }
	                    } else {
	                        type = FUNCTION$1;
	                    }
	                    break;
	                }

	                type = code;
	                offset = offset + 1;
	                break;

	            case NUMBER$1:
	                offset = findNumberEnd$1(source, offset + 1, prevType !== FULLSTOP$1);

	                // merge number with a preceding dot, dash or plus
	                if (prevType === FULLSTOP$1 ||
	                    prevType === HYPHENMINUS$1 ||
	                    prevType === PLUSSIGN$1) {
	                    tokenCount--; // rewrite prev token
	                }

	                break;

	            case STRING$1:
	                offset = findStringEnd$1(source, offset + 1, code);
	                break;

	            default:
	                anchor = offset;
	                offset = findIdentifierEnd$1(source, offset);

	                // merge identifier with a preceding dash
	                if (prevType === HYPHENMINUS$1) {
	                    // rewrite prev token
	                    tokenCount--;
	                    // restore prev prev token type
	                    // for case @-prefix-ident
	                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
	                }

	                if (prevType === COMMERCIALAT) {
	                    // rewrite prev token and change type to <at-keyword-token>
	                    tokenCount--;
	                    type = ATKEYWORD$1;
	                }
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
	        prevType = type;
	    }

	    // finalize arrays
	    offsetAndType[tokenCount] = offset;
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    tokenizer.offsetAndType = offsetAndType;
	    tokenizer.tokenCount = tokenCount;
	    tokenizer.balance = balance;
	}

	//
	// tokenizer
	//

	var Tokenizer = function(source, startOffset, startLine, startColumn) {
	    this.offsetAndType = null;
	    this.balance = null;
	    this.lines = null;
	    this.columns = null;

	    this.setSource(source, startOffset, startLine, startColumn);
	};

	Tokenizer.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        var safeSource = String(source || '');
	        var start = firstCharOffset$1(safeSource);

	        this.source = safeSource;
	        this.firstCharOffset = start;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAnsColumnsComputed = false;

	        this.eof = false;
	        this.currentToken = -1;
	        this.tokenType = 0;
	        this.tokenStart = start;
	        this.tokenEnd = start;

	        tokenLayout(this, safeSource, start);
	        this.next();
	    },

	    lookupType: function(offset) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return NULL;
	    },
	    lookupNonWSType: function(offset) {
	        offset += this.currentToken;

	        for (var type; offset < this.tokenCount; offset++) {
	            type = this.offsetAndType[offset] >> TYPE_SHIFT;

	            if (type !== WHITESPACE$1) {
	                return type;
	            }
	        }

	        return NULL;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenNum) {
	        if (tokenNum === this.currentToken) {
	            return this.tokenStart;
	        }

	        if (tokenNum > 0) {
	            return tokenNum < this.tokenCount
	                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },
	    getOffsetExcludeWS: function() {
	        if (this.currentToken > 0) {
	            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE$1) {
	                return this.currentToken > 1
	                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK
	                    : this.firstCharOffset;
	            }
	        }
	        return this.tokenStart;
	    },
	    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {
	        var cursor = startToken;
	        var balanceEnd;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // belance end points to offset before start
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            // check token is stop type
	            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
	                case endTokenType1:
	                    break loop;

	                case endTokenType2:
	                    if (includeTokenType2) {
	                        cursor++;
	                    }
	                    break loop;

	                default:
	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }

	        }

	        return cursor - this.currentToken;
	    },
	    isBalanceEdge: function(pos) {
	        var balanceStart = this.balance[this.currentToken];
	        return balanceStart < pos;
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE$1) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE$1 || this.tokenType === COMMENT$1) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.currentToken + tokenCount;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.currentToken + 1;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.eof = true;
	            this.tokenType = NULL;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    eat: function(tokenType) {
	        if (this.tokenType !== tokenType) {
	            var offset = this.tokenStart;
	            var message = NAME$1[tokenType] + ' is expected';

	            // tweak message and offset
	            if (tokenType === IDENTIFIER$1) {
	                // when identifier is expected but there is a function or url
	                if (this.tokenType === FUNCTION$1 || this.tokenType === URL$2) {
	                    offset = this.tokenEnd - 1;
	                    message += ' but function found';
	                }
	            } else {
	                // when test type is part of another token show error for current position + 1
	                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                if (this.source.charCodeAt(this.tokenStart) === tokenType) {
	                    offset = offset + 1;
	                }
	            }

	            this.error(message, offset);
	        }

	        this.next();
	    },
	    eatNonWS: function(tokenType) {
	        this.skipWS();
	        this.eat(tokenType);
	    },

	    consume: function(tokenType) {
	        var value = this.getTokenValue();

	        this.eat(tokenType);

	        return value;
	    },
	    consumeFunctionName: function() {
	        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);

	        this.eat(FUNCTION$1);

	        return name;
	    },
	    consumeNonWS: function(tokenType) {
	        this.skipWS();

	        return this.consume(tokenType);
	    },

	    expectIdentifier: function(name) {
	        if (this.tokenType !== IDENTIFIER$1 || cmpStr$1(this.source, this.tokenStart, this.tokenEnd, name) === false) {
	            this.error('Identifier `' + name + '` is expected');
	        }

	        this.next();
	    },

	    getLocation: function(offset, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },

	    getLocationRange: function(start, end, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    },

	    error: function(message, offset) {
	        var location = typeof offset !== 'undefined' && offset < this.source.length
	            ? this.getLocation(offset)
	            : this.eof
	                ? this.getLocation(findWhiteSpaceStart$1(this.source, this.source.length - 1))
	                : this.getLocation(this.tokenStart);

	        throw new error(
	            message || 'Unexpected input',
	            this.source,
	            location.offset,
	            location.line,
	            location.column
	        );
	    },

	    dump: function() {
	        var offset = 0;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	// extend with error class
	Tokenizer.CssSyntaxError = error;

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    Tokenizer[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(utils).forEach(function(key) {
	    Tokenizer[key] = utils[key];
	});

	// warm up tokenizer to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();

	var Tokenizer_1 = Tokenizer;

	var tokenizer = Tokenizer_1;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateSequence(node, forceBraces, decorate) {
	    var result = node.terms.map(function(term) {
	        return generate(term, forceBraces, decorate);
	    }).join(node.combinator === ' ' ? ' ' : ' ' + node.combinator + ' ');

	    if (node.explicit || forceBraces) {
	        result = (result[0] !== ',' ? '[ ' : '[') + result + ' ]';
	    }

	    return result;
	}

	function generate(node, forceBraces, decorate) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, forceBraces, decorate) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, forceBraces, decorate) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, forceBraces, decorate);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = 0;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    if (node === null) {
	        mismatchOffset = css.length;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, lexer, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error$1 = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS$2 = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS$2 &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS$2;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS$2 &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS$2) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var findIdentifierEnd$2 = utils.findIdentifierEnd;
	var findNumberEnd$2 = utils.findNumberEnd;
	var findDecimalNumberEnd$1 = utils.findDecimalNumberEnd;
	var isHex$1 = utils.isHex;

	var SYMBOL_TYPE$2 = _const.SYMBOL_TYPE;
	var IDENTIFIER$2 = _const.TYPE.Identifier;
	var PLUSSIGN$2 = _const.TYPE.PlusSign;
	var HYPHENMINUS$3 = _const.TYPE.HyphenMinus;
	var NUMBERSIGN = _const.TYPE.NumberSign;

	var PERCENTAGE = {
	    '%': true
	};

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	function consumeFunction(token, addTokenToMatch, getNextToken) {
	    var length = 1;
	    var cursor;

	    do {
	        cursor = getNextToken(length++);
	    } while (cursor !== null && cursor.node !== token.node);

	    if (cursor === null) {
	        return false;
	    }

	    while (true) {
	        // consume tokens until cursor
	        if (addTokenToMatch() === cursor) {
	            break;
	        }
	    }

	    return true;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(token, addTokenToMatch, getNextToken) {
	    if (token === null) {
	        return false;
	    }

	    var name = token.value.toLowerCase();
	    if (name !== 'calc(' &&
	        name !== '-moz-calc(' &&
	        name !== '-webkit-calc(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function attr$1(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'attr(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function expression(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'expression(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function url(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'url(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function idSelector(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    if (token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    if (consumeIdentifier(token.value, 1) !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function isNumber$2(str) {
	    return /^[-+]?(\d+|\d*\.\d+)([eE][-+]?\d+)?$/.test(str);
	}

	function consumeNumber(str, allowFraction) {
	    var code = str.charCodeAt(0);

	    return findNumberEnd$2(str, code === PLUSSIGN$2 || code === HYPHENMINUS$3 ? 1 : 0, allowFraction);
	}

	function consumeIdentifier(str, offset) {
	    var code = str.charCodeAt(offset);

	    if (code < 0x80 && SYMBOL_TYPE$2[code] !== IDENTIFIER$2 && code !== HYPHENMINUS$3) {
	        return offset;
	    }

	    return findIdentifierEnd$2(str, offset + 1);
	}

	function astNode(type) {
	    return function(token, addTokenToMatch) {
	        if (token === null || token.node.type !== type) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function dimension(type) {
	    return function(token, addTokenToMatch, getNextToken) {
	        if (calc(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null) {
	            return false;
	        }

	        var numberEnd = consumeNumber(token.value, true);
	        if (numberEnd === 0) {
	            return false;
	        }

	        if (type) {
	            if (!type.hasOwnProperty(token.value.substr(numberEnd).toLowerCase())) {
	                return false;
	            }
	        } else {
	            var unitEnd = consumeIdentifier(token.value, numberEnd);
	            if (unitEnd === numberEnd || unitEnd !== token.value.length) {
	                return false;
	            }
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function zeroUnitlessDimension(type) {
	    var isDimension = dimension(type);

	    return function(token, addTokenToMatch, getNextToken) {
	        if (isDimension(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null || Number(token.value) !== 0) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function number(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, true);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberZeroOne(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 0 || value > 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberOneOrGreater(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function integer(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, false);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function positiveInteger(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = findDecimalNumberEnd$1(token.value, 0);
	    if (numberEnd !== token.value.length || token.value.charCodeAt(0) === HYPHENMINUS$3) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function hexColor(token, addTokenToMatch) {
	    if (token === null || token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    var length = token.value.length - 1;

	    // valid length is 3, 4, 6 and 8 (+1 for #)
	    if (length !== 3 && length !== 4 && length !== 6 && length !== 8) {
	        return false;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHex$1(token.value.charCodeAt(i))) {
	            return false;
	        }
	    }

	    addTokenToMatch();
	    return true;
	}

	// https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	// https://drafts.csswg.org/css-values-4/#identifier-value
	function customIdent(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    var identEnd = consumeIdentifier(token.value, 0);
	    if (identEnd !== token.value.length) {
	        return false;
	    }

	    var name = token.value.toLowerCase();

	    //  3.2. Author-defined Identifiers: the <custom-ident> type
	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (name === 'unset' || name === 'initial' || name === 'inherit') {
	        return false;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (name === 'default') {
	        return false;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)

	    addTokenToMatch();
	    return true;
	}

	var generic = {
	    'angle': zeroUnitlessDimension(ANGLE),
	    'attr()': attr$1,
	    'custom-ident': customIdent,
	    'decibel': dimension(DECIBEL),
	    'dimension': dimension(),
	    'frequency': dimension(FREQUENCY),
	    'flex': dimension(FLEX),
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'ident': astNode('Identifier'),
	    'integer': integer,
	    'length': zeroUnitlessDimension(LENGTH),
	    'number': number,
	    'number-zero-one': numberZeroOne,
	    'number-one-or-greater': numberOneOrGreater,
	    'percentage': dimension(PERCENTAGE),
	    'positive-integer': positiveInteger,
	    'resolution': dimension(RESOLUTION),
	    'semitones': dimension(SEMITONES),
	    'string': astNode('String'),
	    'time': dimension(TIME),
	    'unicode-range': astNode('UnicodeRange'),
	    'url': url,

	    // old IE stuff
	    'progid': astNode('Raw'),
	    'expression': expression
	};

	var SyntaxParseError = function(message, input, offset) {
	    var error = createCustomError('SyntaxParseError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var error$2 = {
	    SyntaxParseError: SyntaxParseError
	};

	var SyntaxParseError$1 = error$2.SyntaxParseError;

	var TAB$2 = 9;
	var N$3 = 10;
	var F$3 = 12;
	var R$3 = 13;
	var SPACE$2 = 32;

	var Tokenizer$1 = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer$1.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R$3 && code !== N$3 && code !== F$3 && code !== SPACE$2 && code !== TAB$2) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new SyntaxParseError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer$1;

	var TAB$3 = 9;
	var N$4 = 10;
	var F$4 = 12;
	var R$4 = 13;
	var SPACE$3 = 32;
	var EXCLAMATIONMARK$1 = 33;    // !
	var NUMBERSIGN$1 = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE$1 = 39;         // '
	var LEFTPARENTHESIS$1 = 40;    // (
	var RIGHTPARENTHESIS$1 = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$3 = 43;           // +
	var COMMA = 44;              // ,
	var LESSTHANSIGN$1 = 60;       // <
	var GREATERTHANSIGN$1 = 62;    // >
	var QUESTIONMARK = 63;       // ?
	var COMMERCIALAT$1 = 64;       // @
	var LEFTSQUAREBRACKET$1 = 91;  // [
	var RIGHTSQUAREBRACKET$1 = 93; // ]
	var LEFTCURLYBRACKET$1 = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET$1 = 125; // }
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos + 1)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET$1);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET$1) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET$1);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$3:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN$1:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET$1) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET$1:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    tokenizer.eat(APOSTROPHE$1);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE$1);
	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	function readType(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1 &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS$1) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET$1);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET$1);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK$1) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET$1:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET$1:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN$1:
	            return tokenizer.nextCharCode() === APOSTROPHE$1
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE$1:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$3:
	        case TAB$3:
	        case N$4:
	        case R$4:
	        case F$4:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT$1:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$3:
	        case QUESTIONMARK:
	        case NUMBERSIGN$1:
	        case EXCLAMATIONMARK$1:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET$1:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(str) {
	    var tokenizer = new tokenizer$1(str);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== str.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node, context);
	};

	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = null;
	        var tokens = [];

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                if (tokens.length > 0) {
	                    switch (curNode.type) {
	                        case 'Dimension':
	                        case 'HexColor':
	                        case 'IdSelector':
	                        case 'Percentage':
	                            if (prev.node === curNode) {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Function':
	                        case 'PseudoClassSelector':
	                        case 'PseudoElementSelector':
	                        case 'Url':
	                            if (chunk === '(') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Atrule':
	                            if (prev.node === curNode && prev.value === '@') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;
	                    }
	                }

	                tokens.push(prev = {
	                    value: chunk,
	                    node: curNode
	                });
	            },
	            result: function() {
	                return tokens;
	            }
	        };
	    }
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$2 = 40;  // (
	var RIGHTPARENTHESIS$2 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$2 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$2
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;

	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 10000;
	var totalIterationCount = 0;

	function mapList(list, fn) {
	    var result = [];

	    while (list) {
	        result.unshift(fn(list));
	        list = list.prev;
	    }

	    return result;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(token.value.length - 1);

	    return (
	        token === ',' ||
	        token === '(' ||
	        token === '[' ||
	        token === '/'
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(0);

	    return (
	        token === ')' ||
	        token === ']' ||
	        token === '/'
	    );
	}

	function internalMatch(tokens, syntax, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenCursor++;
	            token = tokenCursor < tokens.length ? tokens[tokenCursor] : null;
	        } while (token !== null && !/\S/.test(token.value));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenCursor + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function pushThenStack(nextSyntax) {
	        thenStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextSyntax) {
	        elseStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenCursor: tokenCursor,
	            token: token,
	            prev: elseStack
	        };
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: syntax.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();

	        if (tokenCursor > longestMatch) {
	            longestMatch = tokenCursor;
	        }

	        return matchStack.token;
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: syntax,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: syntax.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    var iterationCount = 0;
	    var exitReason = EXIT_REASON_MATCH;

	    var matchStack = { type: 'Stub', syntax: null, token: null, tokenCursor: -1, prev: null };
	    var longestMatch = 0;
	    var tokenCursor = -1;
	    var token = null;

	    moveToNextToken();

	    while (true) {
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? x.type + '!' + x.syntax.name : null),
	        //         elseStack: mapList(elseStack, x => x.id),
	        //         thenStack: mapList(thenStack, x => x.id),
	        //         token: token && token.value,
	        //         tokenCursor,
	        //         syntax
	        //     }, { depth: null })
	        // );

	        // prevent infinite loop
	        if (++iterationCount === ITERATION_LIMIT) {
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            break;
	        }

	        if (syntax === MATCH$1) {
	            if (thenStack === null) {
	                // turn to MISMATCH when some tokens left unmatched
	                if (token !== null) {
	                    // doesn't mismatch if just one token left and it's an IE hack
	                    if (tokenCursor !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                        syntax = MISMATCH$1;
	                        continue;
	                    }
	                }

	                // break the main loop, return a result - MATCH
	                exitReason = EXIT_REASON_MATCH;
	                break;
	            }

	            // go to next syntax (`then` branch)
	            syntax = thenStack.nextSyntax;

	            // check match is not empty
	            if (syntax === DISALLOW_EMPTY$1) {
	                if (thenStack.matchStack.token === matchStack.token) {
	                    syntax = MISMATCH$1;
	                    continue;
	                } else {
	                    syntax = MATCH$1;
	                }
	            }

	            // close syntax if needed
	            while (syntaxStack !== null && thenStack.syntaxStack !== syntaxStack) {
	                closeSyntax();
	            }

	            // pop stack
	            thenStack = thenStack.prev;
	            continue;
	        }

	        if (syntax === MISMATCH$1) {
	            if (elseStack === null) {
	                // break the main loop, return a result - MISMATCH
	                exitReason = EXIT_REASON_MISMATCH;
	                break;
	            }

	            // go to next syntax (`else` branch)
	            syntax = elseStack.nextSyntax;

	            // restore all the rest stack states
	            thenStack = elseStack.thenStack;
	            syntaxStack = elseStack.syntaxStack;
	            matchStack = elseStack.matchStack;
	            tokenCursor = elseStack.tokenCursor;
	            token = elseStack.token;

	            // pop stack
	            elseStack = elseStack.prev;
	            continue;
	        }

	        switch (syntax.type) {
	            case 'MatchGraph':
	                syntax = syntax.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (syntax.else !== MISMATCH$1) {
	                    pushElseStack(syntax.else);
	                }

	                if (syntax.then !== MATCH$1) {
	                    pushThenStack(syntax.then);
	                }

	                syntax = syntax.match;
	                break;

	            case 'MatchOnce':
	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: matchStack,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                if (syntax.index === syntax.terms.length) {
	                    // if no matches during a cycle
	                    if (syntax.matchStack === matchStack) {
	                        // no matches at all or it's required all terms to be matched
	                        if (syntax.mask === 0 || syntax.all) {
	                            syntax = MISMATCH$1;
	                            break;
	                        }

	                        // a partial match is ok
	                        syntax = MATCH$1;
	                        break;
	                    } else {
	                        // start trying to match from the start
	                        syntax.index = 0;
	                        syntax.matchStack = matchStack;
	                    }
	                }

	                for (; syntax.index < syntax.terms.length; syntax.index++) {
	                    if ((syntax.mask & (1 << syntax.index)) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(syntax);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            buffer: syntax
	                        });

	                        // match
	                        syntax = syntax.terms[syntax.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                syntax = syntax.buffer;

	                var newMask = syntax.mask | (1 << (syntax.index - 1));

	                // all terms are matched
	                if (newMask === (1 << syntax.terms.length) - 1) {
	                    syntax = MATCH$1;
	                    continue;
	                }

	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: syntax.matchStack,
	                    index: syntax.index,
	                    mask: newMask
	                };

	                break;

	            case 'Enum':
	                var name = token !== null ? token.value.toLowerCase() : '';

	                // drop \0 and \9 hack from keyword name
	                if (name.indexOf('\\') !== -1) {
	                    name = name.replace(/\\[09].*$/, '');
	                }

	                if (hasOwnProperty$1.call(syntax.map, name)) {
	                    syntax = syntax.map[name];
	                } else {
	                    syntax = MISMATCH$1;
	                }

	                break;

	            case 'Generic':
	                syntax = syntax.fn(token, addTokenToMatch, getNextToken) ? MATCH$1 : MISMATCH$1;
	                break;

	            case 'Type':
	            case 'Property':
	                openSyntax();

	                var syntaxDict = syntax.type === 'Type' ? 'types' : 'properties';

	                if (hasOwnProperty$1.call(syntaxes, syntaxDict) && syntaxes[syntaxDict][syntax.name]) {
	                    syntax = syntaxes[syntaxDict][syntax.name].match;
	                } else {
	                    syntax = undefined;
	                }

	                if (!syntax) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (syntaxStack.syntax.type === 'Type'
	                            ? '<' + syntaxStack.syntax.name + '>'
	                            : '<\'' + syntaxStack.syntax.name + '\'>')
	                    );
	                }

	                break;

	            case 'Keyword':
	                var name = syntax.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (keywordName.toLowerCase() === name) {
	                        addTokenToMatch();

	                        syntax = MATCH$1;
	                        break;
	                    }
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && token.value.toLowerCase() === syntax.name) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === syntax.value) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.value === ',') {
	                    if (isCommaContextStart(matchStack.token)) {
	                        syntax = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        syntax = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    syntax = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            // case 'String':
	            // TODO: strings with length other than 1 char

	            default:
	                throw new Error('Unknown node type: ' + syntax.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    if (exitReason === EXIT_REASON_MATCH) {
	        while (syntaxStack !== null) {
	            closeSyntax();
	        }
	    } else {
	        matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match !== null) {
	        matchResult.match = mapList(matchResult.match, function(item) {
	            if (item.type === OPEN_SYNTAX || item.type === CLOSE_SYNTAX) {
	                return { type: item.type, syntax: item.syntax };
	            }

	            return {
	                syntax: item.syntax,
	                token: item.token && item.token.value,
	                node: item.token && item.token.node
	            };
	        }).slice(1);
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var cursor = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph$$1.syntax || null,
	        match: []
	    };
	    var stack = [host];

	    // revert a list
	    var prev = null;
	    var next = null;
	    while (cursor !== null) {
	        next = cursor.prev;
	        cursor.prev = prev;
	        prev = cursor;
	        cursor = next;
	    }

	    // init the cursor to start with 2nd item since 1st is a stub item
	    cursor = prev.prev;

	    // build a tree
	    while (cursor !== null && cursor.syntax !== null) {
	        var entry = cursor;

	        switch (entry.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: entry.syntax,
	                    match: []
	                });
	                stack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                stack.pop();
	                host = stack[stack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: entry.syntax || null,
	                    token: entry.token.value,
	                    node: entry.token.node
	                });
	        }

	        cursor = cursor.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list$$1) {
	                if (node === start) {
	                    var nodes = new list();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list$$1,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof list;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error$1.SyntaxReferenceError;
	var MatchError$1 = error$1.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords = buildMatchGraph$1(parse_1('inherit | initial | unset'));
	var cssWideKeywordsWithExpression = buildMatchGraph$1(parse_1('inherit | initial | unset | <expression>'));

	function dumpMapSyntax(map, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst ? map[name].syntax : generate_1(map[name].syntax);
	        }
	    }

	    return result;
	}

	function valueHasVar(value) {
	    var hasVar = false;

	    this.syntax.walk(value, function(node) {
	        if (node.type === 'Function' && node.name.toLowerCase() === 'var') {
	            hasVar = true;
	        }
	    });

	    return hasVar;
	}

	function buildMatchResult(match$$1, error, iterations) {
	    return {
	        matched: match$$1,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, node, useCommon) {
	    if (!node) {
	        return buildMatchResult(null, new Error('Node is undefined'));
	    }

	    if (valueHasVar.call(lexer, node)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    var tokens = lexer.syntax.generate(node, astToTokens);
	    var result;

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, lexer, syntax.syntax, node, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure$$1) {
	    this.valueCommonSyntax = cssWideKeywords;
	    this.syntax = syntax;
	    this.generic = false;
	    this.properties = {};
	    this.types = {};
	    this.structure = structure$$1 || getStructureFromConfig(config);

	    if (config) {
	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure$$1 = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure$$1.hasOwnProperty(node.type)) {
	                structure$$1[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic.expression) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (!syntax || !syntax.type) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (!syntax.match) {
	            syntax = this.createDescriptor(syntax);
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var grammar = {
	    SyntaxParseError: error$2.SyntaxParseError,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var TYPE$3 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$3.WhiteSpace;
	var COMMENT$2 = TYPE$3.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var noop$3 = function() {};

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new tokenizer(),
	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new list();
	        },
	        createSingleNodeList: function(node) {
	            return new list().appendData(node);
	        },
	        getFirstListNode: function(list$$1) {
	            return list$$1 && list$$1.first();
	        },
	        getLastListNode: function(list$$1) {
	            return list$$1.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.currentToken;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.scanner.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list$$1) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list$$1);
	                var tail = this.getLastListNode(list$$1);
	                return this.scanner.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        parser.scanner.setSource(source, options.offset, options.line, options.column);
	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.scanner.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var binarySearch = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;

	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}

	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }

	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }

	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }

	  return index;
	};
	});
	var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
	var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
	var binarySearch_3 = binarySearch.search;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	var quickSort_1 = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};

	var quickSort = {
		quickSort: quickSort_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$2 = arraySet.ArraySet;

	var quickSort$1 = quickSort.quickSort;

	function SourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap)
	    : new BasicSourceMapConsumer(sourceMap);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      if (source != null && sourceRoot != null) {
	        source = util.join(sourceRoot, source);
	      }
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: Optional. the column number in the original source.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    if (this.sourceRoot != null) {
	      needle.source = util.relative(this.sourceRoot, needle.source);
	    }
	    if (!this._sources.has(needle.source)) {
	      return [];
	    }
	    needle.source = this._sources.indexOf(needle.source);

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	var SourceMapConsumer_1 = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The only parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet$2.fromArray(names.map(String), true);
	  this._sources = ArraySet$2.fromArray(sources, true);

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64Vlq.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort$1(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          if (this.sourceRoot != null) {
	            source = util.join(this.sourceRoot, source);
	          }
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    if (this.sourceRoot != null) {
	      aSource = util.relative(this.sourceRoot, aSource);
	    }

	    if (this._sources.has(aSource)) {
	      return this.sourcesContent[this._sources.indexOf(aSource)];
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + aSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    if (this.sourceRoot != null) {
	      source = util.relative(this.sourceRoot, source);
	    }
	    if (!this._sources.has(source)) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    source = this._sources.indexOf(source);

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The only parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet$2();
	  this._names = new ArraySet$2();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        if (section.consumer.sourceRoot !== null) {
	          source = util.join(section.consumer.sourceRoot, source);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = section.consumer._names.at(mapping.name);
	        this._names.add(name);
	        name = this._names.indexOf(name);

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
	  };

	var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

	var sourceMapConsumer = {
		SourceMapConsumer: SourceMapConsumer_1,
		BasicSourceMapConsumer: BasicSourceMapConsumer_1,
		IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex];
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex];
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator$1(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	var SourceNode_1 = SourceNode;

	var sourceNode = {
		SourceNode: SourceNode_1
	};

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
	var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
	var SourceNode$1 = sourceNode.SourceNode;

	var sourceMap = {
		SourceMapGenerator: SourceMapGenerator$2,
		SourceMapConsumer: SourceMapConsumer$1,
		SourceNode: SourceNode$1
	};

	var SourceMapGenerator$3 = sourceMap.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap$1 = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$3();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap$1(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof list === false) {
	                        node.children = new list().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof list) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = reverse ? config.fields.slice().reverse() : config.fields;
	    var body = fields.map(function(field) {
	        var ref = 'node.' + field.name;
	        var line;

	        if (field.type === 'list') {
	            line = reverse
	                ? ref + '.forEachRight(walk);'
	                : ref + '.forEach(walk);';
	        } else {
	            line = 'walk(' + ref + ');';
	        }

	        if (field.nullable) {
	            line = 'if (' + ref + ') {\n    ' + line + '}';
	        }

	        return line;
	    });

	    if (config.context) {
	        body = [].concat(
	            'var old = context.' + config.context + ';',
	            'context.' + config.context + ' = node;',
	            body,
	            'context.' + config.context + ' = old;'
	        );
	    }

	    return new Function('node', 'context', 'walk', body.join('\n'));
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    return function walk(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof list) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        var res = {};
	        for (var key in value) {
	            if (hasOwnProperty$5.call(value, key)) {
	                res[key] = value[key];
	            }
	        }
	        return res;
	    } else {
	        return value;
	    }
	}

	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function assign$1(dest, src) {
	    for (var key in src) {
	        dest[key] = src[key];
	    }

	    return dest;
	}

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: list,
	        Tokenizer: tokenizer,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        grammar: grammar,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        parse: parse,
	        walk: walk,
	        generate: generate,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, assign$1)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var appearance = {
		syntax: "auto | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var border = {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	};
	var opacity = {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var quotes = {
		syntax: "none | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var rotate = {
		syntax: "none | [ x | y | z | <number>{3} ]? && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-timing-function": {
		syntax: "<single-timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		appearance: appearance,
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		border: border,
		"border-block-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-bottom": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-inline-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-left": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-style": {
		syntax: "<br-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-width": {
		syntax: "<br-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-after": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-before": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		margin: margin,
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-block-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-block-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angle",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-style": {
		syntax: "auto | <br-style>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-width": {
		syntax: "<br-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overflow-inline": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		padding: padding,
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		scale: scale,
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-type": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"shape-image-threshold": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-timing-function": {
		syntax: "<single-transition-timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		default: properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"br-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"br-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color> <length-percentage>?"
	},
		"color-stop-list": {
		syntax: "<color-stop>#{2,}"
	},
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | subgrid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> {\n  <feature-value-declaration-list>\n}"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frames-timing-function": {
		syntax: "frames(<integer>)"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( [ [ <image> | <string> ]? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <border-radius> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number> [, <number> ]{5,5} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number> [, <number> ]{15,15} )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> {\n  <declaration-list>\n}"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( <angle> )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , <angle> )"
	},
		"rotateX()": {
		syntax: "rotateX( <angle> )"
	},
		"rotateY()": {
		syntax: "rotateY( <angle> )"
	},
		"rotateZ()": {
		syntax: "rotateZ( <angle> )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> [, <number> ]? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( <angle> [, <angle> ]? )"
	},
		"skewX()": {
		syntax: "skewX( <angle> )"
	},
		"skewY()": {
		syntax: "skewY( <angle> )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function> | <frames-timing-function>"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>"
	},
		"single-transition-timing-function": {
		syntax: "<single-timing-function>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, [ start | end ] ]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> [, <length-percentage> ]? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | integer | color | url | integer | number | length | angle | time | frequency | em | ex | px | rem | vw | vh | vmin | vmax | mm | q | cm | in | pt | pc | deg | grad | rad | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> [, <declaration-value> ]? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		attachment: attachment,
		box: box,
		color: color$1,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		default: syntaxes
	});

	var properties$3 = {
		"--*": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-line-clamp": {
			comment: "non-standard and deprecated but may still using by some sites",
			syntax: "<positive-integer>"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-mask-clip": {
			comment: "change type to <-webkit-mask-clip-style> since it differ from <mask-clip>, extra space between [ and ,",
			syntax: "<-webkit-mask-clip-style> [, <-webkit-mask-clip-style> ]*"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			refenrences: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter>"
		},
		font: {
			comment: "extend with non-standard fonts",
			syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | <-non-standard-font>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		"line-height-step": {
			comment: "fix extra spaces around",
			syntax: "none | <length>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "visible | hidden | scroll | auto | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"transform-origin": {
			comment: "move first group to the end since less collecting",
			syntax: "[ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>? | [ <length-percentage> | left | center | right | top | bottom ]"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<unicode-range>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"word-break": {
			comment: "extend with non-standard keywords",
			syntax: "normal | break-all | keep-all | <-non-standard-word-break>"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to duoble sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			preferences: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-non-standard-word-break": {
			comment: "non-standard keywords https://css-tricks.com/almanac/properties/w/word-break/",
			syntax: "break-word"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter": {
			syntax: "[ <progid> | FlipH | FlipV ]+"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr()": {
			comment: "drop it since it's a generic",
			syntax: null
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"inset()": {
			comment: "changed <border-radius> to <'border-radius'>",
			syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added -webkit-gradient() since may to be used for legacy support",
			syntax: "<-legacy-gradient> | <linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"matrix()": {
			comment: "redundant max",
			syntax: "matrix( <number> [, <number> ]{5} )"
		},
		"matrix3d()": {
			comment: "redundant max",
			syntax: "matrix3d( <number> [, <number> ]{15} )"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "replaced <ident> to list of colors according to https://www.w3.org/TR/css-color-4/#named-colors",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		"outline-radius": {
			comment: "missed, looks like it's a similar to <border-radius> https://developer.mozilla.org/en/docs/Web/CSS/-moz-outline-radius",
			syntax: "<border-radius>"
		},
		paint: {
			comment: "simplified SVG syntax (omit <icccolor>, replace <funciri> for <url>) https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | currentColor | <color> | <url> [ none | currentColor | <color> ]?"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( [ [ <top>, <right>, <bottom>, <left> ] | [ <top> <right> <bottom> <left> ] ] )"
		},
		"single-transition": {
			comment: "moved <single-transition-timing-function> in the beginning to avoid wrong match to <single-transition-property>",
			syntax: "<single-transition-timing-function> || [ none | <single-transition-property> ] || <time> || <time>"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		"var()": {
			comment: "drop it since it's a generic (also syntax is incorrect and can't be parsed)",
			syntax: null
		},
		"an-plus-b": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"general-enclosed": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-plain": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-range": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-value": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-and": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-not": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-in-parens": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-feature": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition-without-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		nth: {
			comment: "syntax has <an-plus-b> that doesn't support currently, drop for now",
			syntax: null
		},
		"page-selector": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-selector-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-body": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"pseudo-page": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		properties: properties$3,
		syntaxes: syntaxes$2,
		default: patch
	});

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    properties: buildDictionary(mdnProperties, patch$2.properties),
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes)
	};

	var cmpChar$1 = tokenizer.cmpChar;
	var isNumber$3 = tokenizer.isNumber;
	var TYPE$4 = tokenizer.TYPE;

	var IDENTIFIER$3 = TYPE$4.Identifier;
	var NUMBER$2 = TYPE$4.Number;
	var PLUSSIGN$4 = TYPE$4.PlusSign;
	var HYPHENMINUS$4 = TYPE$4.HyphenMinus;
	var N$5 = 110; // 'n'.charCodeAt(0)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function checkTokenIsInteger(scanner, disallowSign) {
	    var pos = scanner.tokenStart;

	    if (scanner.source.charCodeAt(pos) === PLUSSIGN$4 ||
	        scanner.source.charCodeAt(pos) === HYPHENMINUS$4) {
	        if (disallowSign) {
	            scanner.error();
	        }
	        pos++;
	    }

	    for (; pos < scanner.tokenEnd; pos++) {
	        if (!isNumber$3(scanner.source.charCodeAt(pos))) {
	            scanner.error('Unexpected input', pos);
	        }
	    }
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = start;
	        var prefix = '';
	        var a = null;
	        var b = null;

	        if (this.scanner.tokenType === NUMBER$2 ||
	            this.scanner.tokenType === PLUSSIGN$4) {
	            checkTokenIsInteger(this.scanner, ALLOW_SIGN);
	            prefix = this.scanner.getTokenValue();
	            this.scanner.next();
	            end = this.scanner.tokenStart;
	        }

	        if (this.scanner.tokenType === IDENTIFIER$3) {
	            var bStart = this.scanner.tokenStart;

	            if (cmpChar$1(this.scanner.source, bStart, HYPHENMINUS$4)) {
	                if (prefix === '') {
	                    prefix = '-';
	                    bStart++;
	                } else {
	                    this.scanner.error('Unexpected hyphen minus');
	                }
	            }

	            if (!cmpChar$1(this.scanner.source, bStart, N$5)) {
	                this.scanner.error();
	            }

	            a = prefix === ''  ? '1'  :
	                prefix === '+' ? '+1' :
	                prefix === '-' ? '-1' :
	                prefix;

	            var len = this.scanner.tokenEnd - bStart;
	            if (len > 1) {
	                // ..n-..
	                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS$4) {
	                    this.scanner.error('Unexpected input', bStart + 1);
	                }

	                if (len > 2) {
	                    // ..n-{number}..
	                    this.scanner.tokenStart = bStart + 2;
	                } else {
	                    // ..n- {number}
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
	                b = '-' + this.scanner.getTokenValue();
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	            } else {
	                prefix = '';
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	                this.scanner.skipSC();

	                if (this.scanner.tokenType === HYPHENMINUS$4 ||
	                    this.scanner.tokenType === PLUSSIGN$4) {
	                    prefix = this.scanner.getTokenValue();
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                if (this.scanner.tokenType === NUMBER$2) {
	                    checkTokenIsInteger(this.scanner, prefix !== '');

	                    if (!isNumber$3(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
	                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);
	                        this.scanner.tokenStart++;
	                    }

	                    if (prefix === '') {
	                        // should be an operator before number
	                        this.scanner.error();
	                    } else if (prefix === '+') {
	                        // plus is using by default
	                        prefix = '';
	                    }

	                    b = prefix + this.scanner.getTokenValue();

	                    this.scanner.next();
	                    end = this.scanner.tokenStart;
	                } else {
	                    if (prefix) {
	                        this.scanner.eat(NUMBER$2);
	                    }
	                }
	            }
	        } else {
	            if (prefix === '' || prefix === '+') { // no number
	                this.scanner.error(
	                    'Number or identifier is expected',
	                    this.scanner.tokenStart + (
	                        this.scanner.tokenType === PLUSSIGN$4 ||
	                        this.scanner.tokenType === HYPHENMINUS$4
	                    )
	                );
	            }

	            b = prefix;
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, end),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' :
	                node.a ===  '1' ?  'n' :
	                node.a === '-1' ? '-n' :
	                node.a + 'n'
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$5 = tokenizer.TYPE;

	var ATKEYWORD$2 = TYPE$5.AtKeyword;
	var SEMICOLON = TYPE$5.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$5.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$5.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, SEMICOLON, LEFTCURLYBRACKET$2, false, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$2) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$2 ||
	            type === ATKEYWORD$2) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.scanner.eat(ATKEYWORD$2);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.currentToken);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$2:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$6 = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$6.Semicolon;
	var LEFTCURLYBRACKET$3 = TYPE$6.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$3 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.scanner.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$7 = tokenizer.TYPE;

	var IDENTIFIER$4 = TYPE$7.Identifier;
	var STRING$2 = TYPE$7.String;
	var DOLLARSIGN = TYPE$7.DollarSign;
	var ASTERISK$1 = TYPE$7.Asterisk;
	var COLON = TYPE$7.Colon;
	var EQUALSSIGN = TYPE$7.EqualsSign;
	var LEFTSQUAREBRACKET$2 = TYPE$7.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$7.RightSquareBracket;
	var CIRCUMFLEXACCENT = TYPE$7.CircumflexAccent;
	var VERTICALLINE$1 = TYPE$7.VerticalLine;
	var TILDE = TYPE$7.Tilde;

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.scanner.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdentifier = false;
	    var checkColon = true;

	    if (this.scanner.tokenType === ASTERISK$1) {
	        expectIdentifier = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (this.scanner.tokenType !== VERTICALLINE$1) {
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    if (this.scanner.tokenType === VERTICALLINE$1) {
	        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.scanner.eat(IDENTIFIER$4);
	        } else if (expectIdentifier) {
	            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdentifier) {
	        this.scanner.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var tokenType = this.scanner.tokenType;

	    if (tokenType !== EQUALSSIGN &&        // =
	        tokenType !== TILDE &&             // ~=
	        tokenType !== CIRCUMFLEXACCENT &&  // ^=
	        tokenType !== DOLLARSIGN &&        // $=
	        tokenType !== ASTERISK$1 &&          // *=
	        tokenType !== VERTICALLINE$1         // |=
	    ) {
	        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    if (tokenType === EQUALSSIGN) {
	        this.scanner.next();
	    } else {
	        this.scanner.next();
	        this.scanner.eat(EQUALSSIGN);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' S* attrib_name ']'
	// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$2);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$2) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENTIFIER$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING$2
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENTIFIER$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.scanner.eat(RIGHTSQUAREBRACKET$2);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$8 = tokenizer.TYPE;

	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var COMMENT$3 = TYPE$8.Comment;
	var SEMICOLON$2 = TYPE$8.Semicolon;
	var ATKEYWORD$3 = TYPE$8.AtKeyword;
	var LEFTCURLYBRACKET$4 = TYPE$8.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$3 = TYPE$8.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, 0, 0, false, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$2, true, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.currentToken);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.scanner.eat(LEFTCURLYBRACKET$4);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$3:
	                    break scan;

	                case WHITESPACE$3:
	                case COMMENT$3:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$3:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTCURLYBRACKET$3);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$9 = tokenizer.TYPE;
	var LEFTSQUAREBRACKET$3 = TYPE$9.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$3 = TYPE$9.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$3);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTSQUAREBRACKET$3);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC$2 = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDC$2); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO$2 = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDO$2); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$a = tokenizer.TYPE;
	var IDENTIFIER$5 = TYPE$a.Identifier;
	var FULLSTOP$2 = TYPE$a.FullStop;

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(FULLSTOP$2);

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$b = tokenizer.TYPE;

	var PLUSSIGN$5 = TYPE$b.PlusSign;
	var SOLIDUS = TYPE$b.Solidus;
	var GREATERTHANSIGN$2 = TYPE$b.GreaterThanSign;
	var TILDE$1 = TYPE$b.Tilde;

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        switch (this.scanner.tokenType) {
	            case GREATERTHANSIGN$2:
	            case PLUSSIGN$5:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();
	                this.scanner.expectIdentifier('deep');
	                this.scanner.eat(SOLIDUS);
	                break;

	            default:
	                this.scanner.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$c = tokenizer.TYPE;

	var ASTERISK$2 = TYPE$c.Asterisk;
	var SOLIDUS$1 = TYPE$c.Solidus;

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        this.scanner.next();

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$d = tokenizer.TYPE;

	var IDENTIFIER$6 = TYPE$d.Identifier;
	var COLON$1 = TYPE$d.Colon;
	var EXCLAMATIONMARK$2 = TYPE$d.ExclamationMark;
	var SOLIDUS$2 = TYPE$d.Solidus;
	var ASTERISK$3 = TYPE$d.Asterisk;
	var DOLLARSIGN$1 = TYPE$d.DollarSign;
	var HYPHENMINUS$5 = TYPE$d.HyphenMinus;
	var SEMICOLON$3 = TYPE$d.Semicolon;
	var PLUSSIGN$6 = TYPE$d.PlusSign;
	var NUMBERSIGN$2 = TYPE$d.NumberSign;

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.currentToken;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.tokenType !== EXCLAMATIONMARK$2 &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.scanner.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.currentToken;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.scanner.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.currentToken);
	        }

	        if (this.scanner.tokenType === EXCLAMATIONMARK$2) {
	            important = getImportant(this.scanner);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.scanner.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;
	    var prefix = 0;

	    // hacks
	    switch (this.scanner.tokenType) {
	        case ASTERISK$3:
	        case DOLLARSIGN$1:
	        case PLUSSIGN$6:
	        case NUMBERSIGN$2:
	            prefix = 1;
	            break;

	        // TODO: not sure we should support this hack
	        case SOLIDUS$2:
	            prefix = this.scanner.lookupType(1) === SOLIDUS$2 ? 2 : 1;
	            break;
	    }

	    if (this.scanner.lookupType(prefix) === HYPHENMINUS$5) {
	        prefix++;
	    }

	    if (prefix) {
	        this.scanner.skip(prefix);
	    }

	    this.scanner.eat(IDENTIFIER$6);

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant(scanner) {
	    scanner.eat(EXCLAMATIONMARK$2);
	    scanner.skipSC();

	    var important = scanner.consume(IDENTIFIER$6);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$e = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$4 = TYPE$e.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$4, true, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$4:
	                case COMMENT$4:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var NUMBER$3 = tokenizer.TYPE.Number;

	// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
	function readUnit(scanner) {
	    var unit = scanner.getTokenValue();
	    var backSlashPos = unit.indexOf('\\');

	    if (backSlashPos > 0) {
	        // patch token offset
	        scanner.tokenStart += backSlashPos;

	        // return part before backslash
	        return unit.substring(0, backSlashPos);
	    }

	    // no backslash in unit name
	    scanner.next();

	    return unit;
	}

	// number ident
	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value = this.scanner.consume(NUMBER$3);
	        var unit = readUnit(this.scanner);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value,
	            unit: unit
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$f = tokenizer.TYPE;
	var RIGHTPARENTHESIS$3 = TYPE$f.RightParenthesis;

	// <function-token> <sequence> ')'
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.scanner.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$3);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var isHex$2 = tokenizer.isHex;
	var TYPE$g = tokenizer.TYPE;

	var IDENTIFIER$7 = TYPE$g.Identifier;
	var NUMBER$4 = TYPE$g.Number;
	var NUMBERSIGN$3 = TYPE$g.NumberSign;

	function consumeHexSequence(scanner, required) {
	    if (!isHex$2(scanner.source.charCodeAt(scanner.tokenStart))) {
	        if (required) {
	            scanner.error('Unexpected input', scanner.tokenStart);
	        } else {
	            return;
	        }
	    }

	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on non-hex char
	        if (!isHex$2(code)) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return;
	        }
	    }

	    // token is full hex sequence, go to next token
	    scanner.next();
	}

	// # ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(NUMBERSIGN$3);

	        scan:
	        switch (this.scanner.tokenType) {
	            case NUMBER$4:
	                consumeHexSequence(this.scanner, true);

	                // if token is identifier then number consists of hex only,
	                // try to add identifier to result
	                if (this.scanner.tokenType === IDENTIFIER$7) {
	                    consumeHexSequence(this.scanner, false);
	                }

	                break;

	            case IDENTIFIER$7:
	                consumeHexSequence(this.scanner, true);
	                break;

	            default:
	                this.scanner.error('Number or identifier is expected');
	        }

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1) // skip #
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$h = tokenizer.TYPE;
	var IDENTIFIER$8 = TYPE$h.Identifier;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;
	var IDENTIFIER$9 = TYPE$i.Identifier;
	var NUMBERSIGN$4 = TYPE$i.NumberSign;

	// '#' ident
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(NUMBERSIGN$4);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$9)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$j = tokenizer.TYPE;

	var IDENTIFIER$a = TYPE$j.Identifier;
	var NUMBER$5 = TYPE$j.Number;
	var LEFTPARENTHESIS$3 = TYPE$j.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$j.RightParenthesis;
	var COLON$2 = TYPE$j.Colon;
	var SOLIDUS$3 = TYPE$j.Solidus;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.scanner.eat(LEFTPARENTHESIS$3);
	        this.scanner.skipSC();

	        name = this.scanner.consume(IDENTIFIER$a);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$4) {
	            this.scanner.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$5:
	                    if (this.scanner.lookupType(1) === IDENTIFIER$a) {
	                        value = this.Dimension();
	                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case IDENTIFIER$a:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.scanner.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.scanner.eat(RIGHTPARENTHESIS$4);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$k = tokenizer.TYPE;

	var WHITESPACE$5 = TYPE$k.WhiteSpace;
	var COMMENT$5 = TYPE$k.Comment;
	var IDENTIFIER$b = TYPE$k.Identifier;
	var LEFTPARENTHESIS$4 = TYPE$k.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$5:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$5:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENTIFIER$b:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$4:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.scanner.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	// https://drafts.csswg.org/css-syntax-3/#the-anb-type
	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$6 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(NUMBER$6)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$l = tokenizer.TYPE;
	var LEFTPARENTHESIS$5 = TYPE$l.LeftParenthesis;
	var RIGHTPARENTHESIS$5 = TYPE$l.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTPARENTHESIS$5);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$5);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var NUMBER$7 = TYPE$m.Number;
	var PERCENTSIGN = TYPE$m.PercentSign;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var number = this.scanner.consume(NUMBER$7);

	        this.scanner.eat(PERCENTSIGN);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: number
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$n = tokenizer.TYPE;

	var IDENTIFIER$c = TYPE$n.Identifier;
	var FUNCTION$2 = TYPE$n.Function;
	var COLON$3 = TYPE$n.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$n.RightParenthesis;

	// : ident [ '(' .. ')' ]?
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$c);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENTIFIER$d = TYPE$o.Identifier;
	var FUNCTION$3 = TYPE$o.Function;
	var COLON$4 = TYPE$o.Colon;
	var RIGHTPARENTHESIS$7 = TYPE$o.RightParenthesis;

	// :: ident [ '(' .. ')' ]?
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$4);
	        this.scanner.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$3) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$7);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$d);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isNumber$4 = tokenizer.isNumber;
	var TYPE$p = tokenizer.TYPE;
	var NUMBER$8 = TYPE$p.Number;
	var SOLIDUS$4 = TYPE$p.Solidus;
	var FULLSTOP$3 = TYPE$p.FullStop;

	// Terms of <ratio> should to be a positive number (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without exponent part.
	// Additional checks may to be applied on lexer validation.
	function consumeNumber$1(scanner) {
	    var value = scanner.consumeNonWS(NUMBER$8);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isNumber$4(code) && code !== FULLSTOP$3) {
	            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$1(this.scanner);
	        var right;

	        this.scanner.eatNonWS(SOLIDUS$4);
	        right = consumeNumber$1(this.scanner);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(
	                startToken,
	                endTokenType1,
	                endTokenType2,
	                includeTokenType2
	            )
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = this.scanner.getOffsetExcludeWS();
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var LEFTCURLYBRACKET$5 = TYPE$q.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, LEFTCURLYBRACKET$5, 0, false, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$5) {
	        this.scanner.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.currentToken;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.scanner.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var COMMA$2 = TYPE$r.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$3 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(STRING$3)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var WHITESPACE$6 = TYPE$s.WhiteSpace;
	var COMMENT$6 = TYPE$s.Comment;
	var EXCLAMATIONMARK$3 = TYPE$s.ExclamationMark;
	var ATKEYWORD$4 = TYPE$s.AtKeyword;
	var CDO$3 = TYPE$s.CDO;
	var CDC$3 = TYPE$s.CDC;

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, 0, 0, false, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$6:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$3: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$3: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // 2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$4:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$t = tokenizer.TYPE;

	var IDENTIFIER$e = TYPE$t.Identifier;
	var ASTERISK$4 = TYPE$t.Asterisk;
	var VERTICALLINE$2 = TYPE$t.VerticalLine;

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENTIFIER$e &&
	        this.scanner.tokenType !== ASTERISK$4) {
	        this.scanner.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.tokenType === VERTICALLINE$2) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.tokenType === VERTICALLINE$2) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHex$3 = tokenizer.isHex;
	var TYPE$u = tokenizer.TYPE;

	var IDENTIFIER$f = TYPE$u.Identifier;
	var NUMBER$9 = TYPE$u.Number;
	var PLUSSIGN$7 = TYPE$u.PlusSign;
	var HYPHENMINUS$6 = TYPE$u.HyphenMinus;
	var FULLSTOP$4 = TYPE$u.FullStop;
	var QUESTIONMARK$1 = TYPE$u.QuestionMark;

	function scanUnicodeNumber(scanner) {
	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on fullstop or hyperminus/plussign after exponent
	        if (code === FULLSTOP$4 || code === PLUSSIGN$7) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return false;
	        }
	    }

	    return true;
	}

	// https://drafts.csswg.org/css-syntax-3/#urange
	function scanUnicodeRange(scanner) {
	    var hexStart = scanner.tokenStart + 1; // skip +
	    var hexLength = 0;

	    scan: {
	        if (scanner.tokenType === NUMBER$9) {
	            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP$4 && scanUnicodeNumber(scanner)) {
	                scanner.next();
	            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS$6) {
	                break scan;
	            }
	        } else {
	            scanner.next(); // PLUSSIGN
	        }

	        if (scanner.tokenType === HYPHENMINUS$6) {
	            scanner.next();
	        }

	        if (scanner.tokenType === NUMBER$9) {
	            scanner.next();
	        }

	        if (scanner.tokenType === IDENTIFIER$f) {
	            scanner.next();
	        }

	        if (scanner.tokenStart === hexStart) {
	            scanner.error('Unexpected input', hexStart);
	        }
	    }

	    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
	    // where x is [0-9a-fA-F]
	    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
	        var code = scanner.source.charCodeAt(i);

	        if (isHex$3(code) === false && (code !== HYPHENMINUS$6 || wasHyphenMinus)) {
	            scanner.error('Unexpected input', i);
	        }

	        if (code === HYPHENMINUS$6) {
	            // hex sequence shouldn't be an empty
	            if (hexLength === 0) {
	                scanner.error('Unexpected input', i);
	            }

	            wasHyphenMinus = true;
	            hexLength = 0;
	        } else {
	            hexLength++;

	            // too long hex sequence
	            if (hexLength > 6) {
	                scanner.error('Too long hex sequence', i);
	            }
	        }

	    }

	    // check we have a non-zero sequence
	    if (hexLength === 0) {
	        scanner.error('Unexpected input', i - 1);
	    }

	    // U+abc???
	    if (!wasHyphenMinus) {
	        // consume as many U+003F QUESTION MARK (?) code points as possible
	        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
	            if (scanner.tokenType !== QUESTIONMARK$1) {
	                break;
	            }

	            hexLength++;
	        }
	    }
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next(); // U or u
	        scanUnicodeRange(this.scanner);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$v = tokenizer.TYPE;

	var STRING$4 = TYPE$v.String;
	var URL$3 = TYPE$v.Url;
	var RAW$2 = TYPE$v.Raw;
	var RIGHTPARENTHESIS$8 = TYPE$v.RightParenthesis;

	// url '(' S* (string | raw) S* ')'
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        this.scanner.eat(URL$3);
	        this.scanner.skipSC();

	        switch (this.scanner.tokenType) {
	            case STRING$4:
	                value = this.String();
	                break;

	            case RAW$2:
	                value = this.Raw(this.scanner.currentToken, 0, RAW$2, true, false);
	                break;

	            default:
	                this.scanner.error('String or Raw is expected');
	        }

	        this.scanner.skipSC();
	        this.scanner.eat(RIGHTPARENTHESIS$8);

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$7 = tokenizer.TYPE.WhiteSpace;
	var SPACE$4 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.scanner.eat(WHITESPACE$7);
	        return SPACE$4;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.scanner.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$w = tokenizer.TYPE;

	var IDENTIFIER$g = TYPE$w.Identifier;
	var STRING$5 = TYPE$w.String;
	var NUMBER$a = TYPE$w.Number;
	var FUNCTION$4 = TYPE$w.Function;
	var URL$4 = TYPE$w.Url;
	var NUMBERSIGN$5 = TYPE$w.NumberSign;
	var LEFTPARENTHESIS$6 = TYPE$w.LeftParenthesis;
	var LEFTSQUAREBRACKET$4 = TYPE$w.LeftSquareBracket;
	var PLUSSIGN$8 = TYPE$w.PlusSign;
	var HYPHENMINUS$7 = TYPE$w.HyphenMinus;
	var COMMA$3 = TYPE$w.Comma;
	var SOLIDUS$5 = TYPE$w.Solidus;
	var ASTERISK$5 = TYPE$w.Asterisk;
	var PERCENTSIGN$1 = TYPE$w.PercentSign;
	var BACKSLASH = TYPE$w.Backslash;
	var U = 117; // 'u'.charCodeAt(0)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case NUMBERSIGN$5:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case SOLIDUS$5:
	        case ASTERISK$5:
	        case PLUSSIGN$8:
	        case HYPHENMINUS$7:
	            return this.Operator();

	        case LEFTPARENTHESIS$6:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$4:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$5:
	            return this.String();

	        case NUMBER$a:
	            switch (this.scanner.lookupType(1)) {
	                case PERCENTSIGN$1:
	                    return this.Percentage();

	                case IDENTIFIER$g:
	                    // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
	                    if (cmpChar$2(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
	                        return this.Number();
	                    } else {
	                        return this.Dimension();
	                    }

	                default:
	                    return this.Number();
	            }

	        case FUNCTION$4:
	            return this.Function(this.readSequence, context.recognizer);

	        case URL$4:
	            return this.Url();

	        case IDENTIFIER$g:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$2(this.scanner.source, this.scanner.tokenStart, U) &&
	                cmpChar$2(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$8)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$x = tokenizer.TYPE;

	var IDENTIFIER$h = TYPE$x.Identifier;
	var NUMBER$b = TYPE$x.Number;
	var NUMBERSIGN$6 = TYPE$x.NumberSign;
	var LEFTSQUAREBRACKET$5 = TYPE$x.LeftSquareBracket;
	var PLUSSIGN$9 = TYPE$x.PlusSign;
	var SOLIDUS$6 = TYPE$x.Solidus;
	var ASTERISK$6 = TYPE$x.Asterisk;
	var FULLSTOP$5 = TYPE$x.FullStop;
	var COLON$5 = TYPE$x.Colon;
	var GREATERTHANSIGN$3 = TYPE$x.GreaterThanSign;
	var VERTICALLINE$3 = TYPE$x.VerticalLine;
	var TILDE$2 = TYPE$x.Tilde;

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case PLUSSIGN$9:
	        case GREATERTHANSIGN$3:
	        case TILDE$2:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Combinator();

	        case SOLIDUS$6:  // /deep/
	            return this.Combinator();

	        case FULLSTOP$5:
	            return this.ClassSelector();

	        case LEFTSQUAREBRACKET$5:
	            return this.AttributeSelector();

	        case NUMBERSIGN$6:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENTIFIER$h:
	        case ASTERISK$6:
	        case VERTICALLINE$3:
	            return this.TypeSelector();

	        case NUMBER$b:
	            return this.Percentage();
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression '(' raw ')'
	var expression$1 = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	};

	var TYPE$y = tokenizer.TYPE;

	var IDENTIFIER$i = TYPE$y.Identifier;
	var COMMA$4 = TYPE$y.Comma;
	var SEMICOLON$5 = TYPE$y.Semicolon;
	var HYPHENMINUS$8 = TYPE$y.HyphenMinus;
	var EXCLAMATIONMARK$4 = TYPE$y.ExclamationMark;

	// var '(' ident (',' <value>? )? ')'
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    var identStart = this.scanner.tokenStart;

	    this.scanner.eat(HYPHENMINUS$8);
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS$8) {
	        this.scanner.error('HyphenMinus is expected');
	    }
	    this.scanner.eat(IDENTIFIER$i);

	    children.push({
	        type: 'Identifier',
	        loc: this.getLocation(identStart, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(identStart)
	    });

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$4, SEMICOLON$5, false, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression$1,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var STRING$6 = TYPE$z.String;
	var IDENTIFIER$j = TYPE$z.Identifier;
	var URL$5 = TYPE$z.Url;
	var LEFTPARENTHESIS$7 = TYPE$z.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$6:
	                    children.push(this.String());
	                    break;

	                case URL$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.scanner.error('String or url() is expected');
	            }

	            if (this.scanner.lookupNonWSType(0) === IDENTIFIER$j ||
	                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS$7) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$A = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$A.WhiteSpace;
	var COMMENT$7 = TYPE$A.Comment;
	var IDENTIFIER$k = TYPE$A.Identifier;
	var FUNCTION$5 = TYPE$A.Function;
	var LEFTPARENTHESIS$8 = TYPE$A.LeftParenthesis;
	var HYPHENMINUS$9 = TYPE$A.HyphenMinus;
	var COLON$6 = TYPE$A.Colon;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	}

	function parentheses() {
	    var index = 0;

	    this.scanner.skipSC();

	    // TODO: make it simplier
	    if (this.scanner.tokenType === IDENTIFIER$k) {
	        index = 1;
	    } else if (this.scanner.tokenType === HYPHENMINUS$9 &&
	               this.scanner.lookupType(1) === IDENTIFIER$k) {
	        index = 2;
	    }

	    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$8:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$7:
	                this.scanner.next();
	                continue;

	            case FUNCTION$5:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENTIFIER$k:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$8:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.scanner.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}

		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let href = node.value.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					node.value.value = url.toString();
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-bleed-top: 0;
	--pagedjs-bleed-right: 0;
	--pagedjs-bleed-bottom: 0;
	--pagedjs-bleed-left: 0;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}


.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

img {
	height: auto;
}

@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: var(--pagedjs-width);
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || 'get', url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials=='include';

			request.onload = () => {
	 			// Chrome returns a status code of 0 for local files
	 			const status = request.status === 0 && url.startsWith('file://') ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "mm"
			},
			height: {
				value: 14,
				unit: "mm"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "mm"
			},
			height: {
				value: 17,
				unit: "mm"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;

			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin : {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclartations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;


				if ((width && height) &&
						(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed);

					this.emit("size", { width, height, orientation, format, bleed });
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclartations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);
					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);
					} else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									default:
										// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;
		}

		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let {value, unit} = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					margins.push(node);
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages && !pages["*"].added) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
				pages["*"].added = true;
			}
			// Add :left & :right
			if (":left" in pages && !pages[":left"].added) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
				pages[":left"].added = true;
			}
			if (":right" in pages && !pages[":right"].added) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
				pages[":right"].added = true;
			}
			// Add :first & :blank
			if (":first" in pages && !pages[":first"].first) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
				pages[":first"].added = true;
			}
			if (":blank" in pages && !pages[":blank"].added) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
				pages[":blank"].added = true;
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth && !pages[pg].added) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
					pages[pg].added = true;
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name && !pages[pg].added) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
					pages[pg].added = true;
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};
			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());

			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}

			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);
				}
			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent$$1 = false;

				if(block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent$$1 = false;
							} else {
								hasContent$$1 = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
							 loc === "top-center" ||
							 loc === "top-right" ||
							 loc === "bottom-left" ||
							 loc === "bottom-center" ||
							 loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
							 loc === "left-middle" ||
							 loc === "left-bottom" ||
							 loc === "right-top" ||
							 loc === "right-middle" ||
							 loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent$$1
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if(content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(bleedTop, bleedRight, bleedBottom, bleedLeft, pageWidthVar, pageHeightVar);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			rules.push(wVar, hVar);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let dimensions = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});


			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if(centerWidth === "none" || centerWidth === "auto") {
						if(!leftContent && !rightContent){
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						}else if(leftContent){
							if(!rightContent){
								if(leftWidth !== "none" && leftWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							}else{
								if(leftWidth !== "none" && leftWidth !== "auto"){
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								}else{
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if(newcenterWidth > 40){
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										}else{
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						}else{
							if(rightWidth !== "none" && rightWidth !== "auto"){
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							}else{
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					}else if(centerWidth !== "none" && centerWidth !== "auto"){
						if(leftContent && leftWidth !== "none" && leftWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						}else if(rightContent && rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				}else{
					if(leftContent){
						if(!rightContent){
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						}else{
							if(leftWidth !== "none" && leftWidth !== "auto"){
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							}else{
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth  + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					}else{
						if(rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if(middleHeight === "none" || middleHeight === "auto") {
						if(!topContent && !bottomContent){
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						}else if(topContent){
							if(!bottomContent){
								if(topHeight !== "none" && topHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							}else{
								if(topHeight !== "none" && topHeight !== "auto"){
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									}else{
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								}else{
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						}else{
							if(bottomHeight !== "none" && bottomHeight !== "auto"){
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					}else{
						if(topContent && topHeight !== "none" && topHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = topHeight +" " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						}else if(bottomContent && bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				}else{
					if(topContent){
						if(!bottomContent){
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						}else{
							if(topHeight !== "none" && topHeight !== "auto"){
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							}else{
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					}else{
						if(bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator="+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child$$1 = declaration.value.children.first();
				let value = child$$1.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			splits.forEach((split) => {
				let ref = split.dataset.ref;
				let from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}

					this.handleAlignment(from);
				}
			});
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			if (align === "justify" && alignLast === "auto") {
				node.style["text-align-last"] = "justify";
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number: number || 1
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				this.addCounterValues(parsed, counter);
			}
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (var i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
				}
			}
		}

		addCounterValues(parsed, counter) {
			let counterName = counter.name;
			let elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;

			for (var i = 0; i < elements.length; i++) {
				element = elements[i];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					count = parseInt(reset);
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");

					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-reset: ${counterName} ${count} }`, this.styleSheet.cssRules.length);
					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-increment: ${counterName} ${increment}}`, this.styleSheet.cssRules.length);

					count += parseInt(increment);

					element.setAttribute("data-counter-"+counterName+"-value", count);
				}

			}
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				let value = reset.datasetCounterPageReset;
				this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-reset: page ${value} }`, this.styleSheet.cssRules.length);
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
				list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + 1);
			}
		}

	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier: identifier,
					value: value,
					selector: selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

				funcNode.children.append(funcNode.children.createItem({
					type: "Identifier",
					loc: null,
					name: "--pagedjs-string-" + identifier
				}));
			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.stringSetSelectors)) {
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					let cssVar;
					if (set.value === "content" || set.value === "content()" || set.value === "content(text)") {
						cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --pagedjs-string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--pagedjs-string-${name}`, `"${cssVar}"`);
						set.first = cssVar;
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					} else {
						console.warn(set.value + "needs css replacement");
					}
				} else {
					// Use the previous values
					if (set.first) {
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					}
				}
			}
		}
	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (var i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								pg += 1;

								if (pages[i].contains( element )){
									break;
								}
							}

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				selector.split(",").forEach((s) => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach((name) => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						if (target.style === "content") {
							let selector = UUID();
							selected.setAttribute("data-target-text", selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}

							let textContent = element.textContent.trim().replace(/["']/g, (match) => {
								return "\\" + match;
							}).replace(/[\n]/g, (match) => {
								return "\\00000A";
							});

							// this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { content: "${element.textContent}" }`, this.styleSheet.cssRules.length);
							this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { ${target.variable}: "${textContent}" }`, this.styleSheet.cssRules.length);

						}
					} else {
						console.warn("missed target", val);
					}
				});

			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		if (typeof Symbol !== 'function') return false;
		try { } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor() {
			// this.preview = this.getParams("preview") !== "false";

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker();

			// Hooks
			this.hooks = {};

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			let counter = 0;
			this.chunker.on("page", (page) => {
				counter += 1;
				this.emit("page", page);
				if (typeof window.PuppeteerLogger !== "undefined") {
					window.PuppeteerLogger("page", counter);
				}
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();
			let msg = "Rendering " + flow.total + " pages took " + (endTime - startTime) + " milliseconds.";

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			if (typeof window.onPagesRendered !== "undefined") {
				window.onPagesRendered(msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			}

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);



	var Paged = /*#__PURE__*/Object.freeze({
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined
	};

	let previewer = new Previewer(config.content, config.stylesheets, config.renderTo);


	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview();
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

}));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      const abbreviations = content.querySelectorAll('abbr');
      if(abbreviations.length === 0) return;
      const loaTitle = 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });
}
</script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<style type="text/css">@page {
size: 8.5in 11in; 
}
@page :blank {
}
.pagedjs_page {
--pagedjs-pagebox-width: 8.5in;
--pagedjs-pagebox-height: 11in;
}
.level1 {
break-before: avoid;
}
.red {
color: red;
}
.yourturn {
color: blue;
font-size: 2em;
}
.pagebreak {
break-after: always;
}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Chapter 3: Methods for Simulating Data</h1>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p>Statisticians (and other users of data) need to simulate data for many reasons.</p>
<p>For example, I simulate as a way to check whether a model is appropriate. If the observed data are similar to the data I generated, then this is one way to show my model may be a good one.</p>
<p>It is also sometimes useful to simulate data from a distribution when I need to estimate an expected value (approximate an integral).</p>
<p><code>R</code> can already generate data from many (named) distributions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">400</span>) <span class="co">#reproducibility</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">rnorm</span>(<span class="dv">10</span>) <span class="co"># 10 observations of a N(0,1) r.v.</span></a></code></pre></div>
<pre><code>##  [1] -1.0365488  0.6152833  1.4729326 -0.6826873 -0.6018386 -1.3526097
##  [7]  0.8607387  0.7203705  0.1078532 -0.5745512</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">rnorm</span>(<span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">5</span>) <span class="co"># 10 observations of a N(0,5^2) r.v.</span></a></code></pre></div>
<pre><code>##  [1] -4.5092359  0.4464354 -7.9689786 -0.4342956 -5.8546081  2.7596877
##  [7] -3.2762745 -2.1184014  2.8218477 -5.0927654</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">rexp</span>(<span class="dv">10</span>) <span class="co"># 10 observations from an Exp(1) r.v.</span></a></code></pre></div>
<pre><code>##  [1] 0.67720831 0.04377997 5.38745038 0.48773005 1.18690322 0.92734297
##  [7] 0.33936255 0.99803323 0.27831305 0.94257810</code></pre>
<p><strong>But what about when we dont have a function to do it?</strong></p>
<div id="inverse-transform-method" class="section level1">
<h1><span class="header-section-number">1</span> Inverse Transform Method</h1>

<div class="theorem">
<span id="thm:unnamed-chunk-4" class="theorem"><strong>Theorem 1.1  (Probability Integral Transform)  </strong></span>If <span class="math inline">\(X\)</span> is a continuous r.v. with cdf <span class="math inline">\(F_X\)</span>, then <span class="math inline">\(U = F_X(X) \sim \text{Uniform}[0, 1]\)</span>.
</div>

<p><br /><br /></p>
<p>This leads to to the following method for simulating data.</p>
<p><br /><br /><br /></p>
<p><strong>Inverse Transform Method</strong>:</p>
<p>First, generate <span class="math inline">\(u\)</span> from Uniform<span class="math inline">\([0,1]\)</span>. Then, <span class="math inline">\(x = F_X^{-1}(u)\)</span> is a realization from <span class="math inline">\(F_X\)</span>.</p>
<p><br />
<strong>Note:</strong>
<br /><br /><br /></p>
<div id="algorithm" class="section level2">
<h2><span class="header-section-number">1.1</span> Algorithm</h2>
<ol style="list-style-type: decimal">
<li><p>Derive the inverse function <span class="math inline">\(F_X^{-1}\)</span>. <br /><br /></p></li>
<li><p>Write a function to compute <span class="math inline">\(x = F_X^{-1}(u)\)</span>. <br /><br /></p></li>
<li><p>For each realization,</p>
<ol style="list-style-type: lower-alpha">
<li><p><br /><br /></p></li>
<li><p><br /><br /></p></li>
</ol></li>
</ol>
<p><span class="pagebreak"></span></p>

<div class="example">
<span id="exm:unnamed-chunk-5" class="example"><strong>Example 1.1  </strong></span>Simulate a random sample of size <span class="math inline">\(1000\)</span> from the pdf <span class="math inline">\(f_X(x) = 3x^2, 0 \le x \le 1\)</span>.
</div>

<ol style="list-style-type: decimal">
<li><br /><br /><br /><br /><br /></li>
<li><br /><br /><br /><br /><br /></li>
<li><div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co"># write code for inverse transform example</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co"># f_X(x) = 3x^2, 0 &lt;= x \&lt;= 1</span></a></code></pre></div></li>
</ol>
<p><br /><br /></p>
</div>
<div id="discrete-rvs" class="section level2">
<h2><span class="header-section-number">1.2</span> Discrete RVs</h2>
<p>If <span class="math inline">\(X\)</span> is a discrete random variable and <span class="math inline">\(\cdots &lt; x_{i-1} &lt; x_i &lt; \cdots\)</span> are the points of discontinuity of <span class="math inline">\(F_X(x)\)</span>, then the inverse transform is <span class="math inline">\(F_X^{-1}(u) = x_i\)</span> where <span class="math inline">\(F_X(x_{i-1}) &lt; u \le F_X(x_i)\)</span>. This leads to the following algorithm:</p>
<ol style="list-style-type: decimal">
<li><p>Generate a r.v. <span class="math inline">\(U\)</span> from Unif<span class="math inline">\((0,1)\)</span>.</p></li>
<li><p>Select <span class="math inline">\(x_i\)</span> where <span class="math inline">\(F_X(x_{i-1}) &lt; U \le F_X(x_{i})\)</span>.</p></li>
</ol>
<p><span class="pagebreak"></span></p>

<div class="example">
<span id="exm:unnamed-chunk-7" class="example"><strong>Example 1.2  </strong></span>Generate 1000 samples from the following discrete distribution.
</div>

<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">p &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.7</span>)</a></code></pre></div>
<table>
<tbody>
<tr class="odd">
<td align="left">x</td>
<td align="right">1.0</td>
<td align="right">2.0</td>
<td align="right">3.0</td>
</tr>
<tr class="even">
<td align="left">f</td>
<td align="right">0.1</td>
<td align="right">0.2</td>
<td align="right">0.7</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co"># write code to sample from discrete dsn</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">n &lt;-<span class="st"> </span><span class="dv">1000</span></a></code></pre></div>
</div>
</div>
<div id="acceptance-reject-method" class="section level1">
<h1><span class="header-section-number">2</span> Acceptance-Reject Method</h1>
<p>The goal is to generate realizations from a <em>target density</em>, <span class="math inline">\(f\)</span>.</p>
<p>Most cdfs cannot be inverted in closed form.</p>
<p>The Acceptance-Reject (or Accept-Reject) samples from a distribution that is <em>similar</em> to <span class="math inline">\(f\)</span> and then adjusts by only accepting a certain proportion of those samples.</p>
<p><br /><br /></p>
<p>The method is outlined below:</p>
<p>Let <span class="math inline">\(g\)</span> denote another density from which we <strong>know how to sample</strong> and we can <strong>easily calculate <span class="math inline">\(g(x)\)</span></strong>.</p>
<p>Let <span class="math inline">\(e(\cdot)\)</span> denote an <em>envelope</em>, having the property <span class="math inline">\(e(x) = c g(x) \ge f(x)\)</span> for all <span class="math inline">\(x \in \mathcal{X} = \{x:f(x) &gt; 0\}\)</span> for a given constant <span class="math inline">\(c \ge 1\)</span>.</p>
<p>The Accept-Reject method then follows by sampling <span class="math inline">\(Y \sim g\)</span> and <span class="math inline">\(U \sim \text{Unif}(0,1)\)</span>.</p>
<p>If <span class="math inline">\(U &lt; f(Y)/e(Y)\)</span>, accept <span class="math inline">\(Y\)</span>. Set <span class="math inline">\(X = Y\)</span> and consider <span class="math inline">\(X\)</span> to be an element of the target random sample.</p>
<p><strong>Note:</strong> <span class="math inline">\(1/c\)</span> is the expected proportion of candidates that are accepted.</p>
<p><br /><br /></p>
<div id="algorithm-1" class="section level2">
<h2><span class="header-section-number">2.1</span> Algorithm</h2>
<ol style="list-style-type: decimal">
<li><p>Find a suitable density <span class="math inline">\(g\)</span> and envelope <span class="math inline">\(e\)</span>.</p></li>
<li><p>Sample <span class="math inline">\(Y \sim g\)</span>.</p></li>
<li><p>Sample <span class="math inline">\(U \sim \text{Unif}(0, 1)\)</span>.</p></li>
<li><p>If <span class="math inline">\(U &lt; f(Y)/e(Y)\)</span>, accept <span class="math inline">\(Y\)</span>.</p></li>
<li><p>Repeat from Step 2 until you have generated your desired sample size.</p></li>
</ol>
<p><span class="pagebreak"></span></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAJACAYAAABMocy1AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N0JeFXVufDxN/OckAQCBFAiQxkkEsMos9CKODHJLKIiKALirLVWb3ttb/WKAxWLUriiiLXYyqBUREAcsFxRQEUrCMg8B5JAZvh41/0OZUhIcnKGPfz386wn4Zy993rXbx2SnPesIeTkqUM4EEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBwqEOrBNNAkBBBBAAAEEEEAAAQQQQAABBBBAAAEEEDACJEB5ISCAAAIIIIAAAggggAACCCCAAAIIIICAYwVIgDq2a2kYAggggAACCCCAAAIIIIAAAggggAACCJAA5TWAAAIIIIAAAggggAACCCCAAAIIIIAAAo4VIAHq2K6lYQgggAACCCCAAAIIIIAAAggggAACCCBAApTXAAIIIIAAAggggAACCCCAAAIIIIAAAgg4VoAEqGO7loYhgAACCCCAAAIIIIAAAggggAACCCCAAAlQXgMIIIAAAggggAACCCCAAAIIIIAAAggg4FgBEqCO7VoahgACCCCAAAIIIIAAAggggAACCCCAAAIkQHkNIIAAAggggAACCCCAAAIIIIAAAggggIBjBUiAOrZraRgCCCCAAAIIIIAAAggggAACCCCAAAIIkADlNYAAAggggAACCCCAAAIIIIAAAggggAACjhUgAerYrqVhCCCAAAIIIIAAAggggAACCCCAAAIIIEAClNcAAggggAACCCCAAAIIIIAAAggggAACCDhWINyxLbNBw/bs2WODKKsfYlxcnCQmJpoLjxw5IgUFBdW/CVcgYBOB5ORkCQkJkcOHD9skYsJEoPoC0dHRoq91PfLy8iQ/P7/6N+EKBGwioH/DREZGysGDB20SMWEiUH0BfY2npqaaC48dOya5ubnVvwlXIGATgfj4eNH3qPv27bNJxISJQPUFwsLCJC0tzVxYWFgoOTk51b+J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aZ2GI/HGZI7FtbkGAggggAACCCCAAALFFSAAWlxBzkcAgWIJaLxPdZs855xz7KOPPrLWrVsX63qRJ6s14ZNPPmm7d+9244PyhTxSxz/rqh+1/L311lv9kylyggAChRbo3r27vfDCC7Z//37jh6dC83ECAggggAACCCCAQBwFCIDGEZdLI4BA/gKR433+5je/KdR4n/lf9eg9AwYMsOeff959Iadr5tE+yd6ioLSC4D//+c+tbdu2yc4O90cAgWIKXHrppW4sZv2wwRAkxcTkdAQQQAABBBBAAIGYCTALfMwouRACCBRUICsry9auXWslS5Z0wck+ffoU9NQiHde7d2+rVKmSm11crU0bNWrk7l2ki3FSTAU0/IHGf6X1Z0xZuRgCSRW44oorXMt7DUOi93kNb0JCAAEEEEAAAQQQQCCZArQATaY+90YgRQU0Q3vp0qXdeJ/xDn56xBdddJG9/vrrbpIOBV8VhCUlX0CtP9u0aWNdunRJfmbIAQIIxExg0KBBprGYNb7vtm3bYnZdLoQAAggggAACCCCAQFEECIAWRY1zEECgyAL79u2zXbt22f333x/T8T4LkiF1s37zzTetfPnyrgWqxp0kJU9Ar4UDBw7Q+jN5VcCdEYirwO23324ai1kB0B07dsT1XlwcAQQQQAABBBBAAIFjCRAAPZYO+xBAIKYCGvdz8+bN1q5dO7vhhhtieu2CXqx9+/b27rvvWtWqVQmCFhQtTsepZVjTpk3tkksuidMduCwCCCRbQN3gNRazxgPVj18kBBBAAAEEEEAAAQSSIUAANBnq3BOBFBVQKyBNevP0008ndQzO0047zd577z2rWLGiC8imaHUktdgHDx40jf95yy23JPW1kFQEbo5Aigg8/vjjprGYNTP8nj17UqTUFBMBBBBAAAEEEEDATwIEQP1UG+QFgRALqKuzWvzddttt1qJFi6SX9JRTTrHHHnvMBeF27tyZ9PykWgY09me9evWsf//+qVZ0yotAygloIqTx48ebxmLeuHGje99NOQQKjAACCCCAAAIIIJBUAQKgSeXn5gikhoBafarr+6mnnmoaE84v6fLLLzct6pqZkZHhl2yFPh+y3r17t/3mN7+xsmXLhr68FBABBMxNfPenP/3JOnXqZBs2bLD9+/fDggACCCCAAAIIIIBAwgQIgCaMmhshkLoCavmpLs/q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IIAAAggggAACCCCAAAIIIBAXAQKgcWHloggggAACCCCAAAIIIIAAAggggAACCCDgBwECoH6oBfKAAAIIIIAAAggggAACCCCAAAIIIIAAAnERIAAaF1YuigACCCCAAAIIIIAAAggggAACCCCAAAJ+ECAA6odaIA8IIIAAAggggAACCCCAAAIIIIAAAgggEBcBAqBxYeWiCCCAAAIIIIAAAggggAACCCCAAAIIIOAHAQKgfqgF8oAAAggggAACCCCAAAIIIIAAAggggAACcREgABoXVi6KAAIIIIAAAggggAACCCCAAAIIIIAAAn4QIADqh1ogDwgggAACCCCAAAIIIIAAAggggAACCCAQFwECoHFh5aIIIIAAAggggAACCCCAAAIIIIAAAggg4AeB0n7IBHlAAAEEEEAAAQQQQCCRAt9++63t2bPH3bJJkyZWt27dqLdftWqVpaWluX2NGze2Bg0aRD2OjQgggAACCCCAAAL+FSAA6t+6IWcIIIAAAggggAACcRKYP3++XX/99e7q7dq1s7lz51rp0rk/Gq9fv97at29v27dvt9q1a9tXX30Vp9xwWQQQQAABBBBAAIF4CtAFPp66XBsBBBBAAAEEEEDAlwLXXXed9e/f3+VtwYIF9tRTT+XKZ3Z2tukYBT+VJk2aZI0aNcp1DE8QQAABBBBAAAEEgiFQ4vCRFIyskksEEEAAAQQQQAABBGInkJ6ebq1btza19CxXrpxr4dmyZUt3gyeffNLuvfdet37HHXfYM888E7sbcyUEEEAAAQQQQACBhAoQAE0oNzdDAAEEEEAAAQQQ8JPA9OnT7cILLzS1CejUqZPNmjXLBUI7dOhgGRkZpu7xc+bMsbJly/op2+QFAQQQQAABBBBAoBACdIEvBBaHIoAAAggggAACCIRL4Pzzz7c777zTFWr27Nn23HPP2YABA1zws0qVKvbmm28S/AxXlVMaBBBAAAEEEEhBAVqApmClU2QEEEAAAQQQQACBnwQOHjxoZ511li1evPinjUfW/vrXv9o111yTaxtPEEAAAQQQQAABBIInQAvQ4NUZOUYAAQQQQAABBBCIoYDG/5w8ebIbB9S7rGaIJ/jpafCIAAIIIIAAAggEW4AAaLDrj9wjgAACCCCAAAIIxECgTp06Vrly5Zwr7d69O2edFQQQQAABBBBAAIFgCxAADXb9kXsEEEAAAQQQQACBGAj8+te/tm3btuVc6R//+If95S9/yXnOCgIIIIAAAggggEBwBQiABrfuyDkCCCCAAAIIIIBADAT+8Ic/2JQpU9yVHnjgAWvTpo1bv/32223FihUxuAOXQAABBBBAAAEEEEimAJMgJVOfeyOAAAIIIIAAAggkVWDZsmXWrl07279/v7Vt29bmzZtnixYtsg4dOlhWVpadc845NmvWLCtVqlRS88nNEUAAAQQQQAABBIouQAvQottxJgIIIIAAAggggECABTIyMtxERwp+lilTxiZNmuQe27dvb8OHD3clmzNnjo0dOzbApSTrCCCAAAIIIIAAAgRAeQ0ggAACCCCAAAIIpKTAyJEjbcGCBa7s6vquFqBeGjVqlLVq1co9HT16tGsZ6u3jEQEEEEAAAQQQQCBYAnSBD1Z9kVsEEEAAAQQQQACBGAioW3u3bt0sOzvb/t//+3/2xRdfuNafkZeeO3eunXvuue6YZs2a2cKFC61SpUqRh7COAAIIIIAAAgggEAABWoAGoJLIIgIIIIAAAggggEDsBHbt2mXXXnutC2yq6/srr7xyVPBTd9M4oMOGDXM3Xr58ec567HLClRBAAAEEEEAAAQQSIUAL0EQocw8EEEAAAQQQQAABBBBAAAEEEEAAAQQQSIoALUCTws5NEUAAAQQQQAABBBBAAAEEEEAAAQQQQCARAgRAE6HMPRBAAAEEEEAAAQQQQAABBBBAAAEEEEAgKQIEQJPCzk0RQAABBBBAAAEEEEAAAQQQQAABBBBAIBECBEATocw9EEAAAQQQQAABBBBAAAEEEEAAAQQQQCApAgRAk8LOTRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgEQIEQBOhzD0QQAABBBBAAAEEEEAAAQQQQAABBBBAICkCBECTws5NEUAAAQQQQAABBBBAAAEEEEAAAQQQQCARAgRAE6HMPRBAAAEEEEAAAQQQQAABBBBAAAEEEEAgKQIEQJPCzk0RQAABBBBAAAEEEEAAAQQQQAABBBBAIBECBEATocw9EEAAAQQQQAABBBBAAAEEEEAAAQQQQCApAgRAk8LOTRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgEQIEQBOhzD0QQAABBBBAAAEEEEAAAQQQQAABBBBAICkCBECTws5NEUAAAQQQQAABBBBAAAEEEEAAAQQQQCARAgRAE6HMPRBAAAEEEEAAAQQQQAABBBBAAAEEEEAgKQIEQJPCzk0RQAABBBBAAAEEEEAAAQQQQAABBBBAIBECBEATocw9EEAAAQQQQAABBBBAAAEEEEAAAQQQQCApAgRAk8LOTRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgEQIEQBOhzD0QQAABBBBAAAEEEEAAAQQQQAABBBBAICkCBECTws5NEUAAAQQQQAABBBBAAAEEEEAAAQQQQCARAv8fe8Fdn965mSIAAAAASUVORK5CYII=" width="672" /></p>
<p><br /><br /><br /></p>
</div>
<div id="envelopes" class="section level2">
<h2><span class="header-section-number">2.2</span> Envelopes</h2>
<p>Good envelopes have the following properties:</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>A simple approach to finding the envelope:</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p><span class="pagebreak"></span></p>

<div class="example">
<span id="exm:unnamed-chunk-12" class="example"><strong>Example 2.1  </strong></span>We want to generate a random variable with pdf <span class="math inline">\(f(x) = 60x^3(1-x)^2\)</span>, <span class="math inline">\(0 \le x \le 1\)</span>. This is a Beta<span class="math inline">\((4, 3)\)</span> distribution.
</div>

<p>Can we invert <span class="math inline">\(F(x)\)</span> analytically?</p>
<p><br /></p>
<p>If not, find the maximum of <span class="math inline">\(f(x)\)</span>.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># pdf function, could use dbeta() instead</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">f &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="dv">60</span><span class="op">*</span>x<span class="op">^</span><span class="dv">3</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="co"># plot pdf</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">length.out =</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="kw">ggplot</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(x, <span class="kw">f</span>(x)))</a></code></pre></div>
<p><img src="data:image/png;base64,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5I0AAggggAACCCDgCIHDhw+bVmkapDlz5owps87qvmDBAjOLNa0+HXEbKWSQCoSHh0u/fv1k1qxZ9izxhw4dkrp164rOHG+NrxukxadYCCCAAAIuECAA6oKbSBUQQAABBBBAAAEEUi+wcuVKefzxx01XXSuXWrVqyaeffirly5e3NvGKAAJpFKhcubKsXr1a7r33XpOTjgU6dOhQadq0qRw/fjyNuXM6AggggAACCQsQAE3Yhj0IIIAAAggggAACLhbQlp49evSQli1bik7QoklndX/77bfNT65cuVxce6qGQGAEChUqJB988IE0b97cLoB+2fDss8/Kjh077G0sIIAAAggg4E0BAqDe1CQvBBBAAAEEEEAAAUcI6BifOtHR/Pnz7fLqzO4//PCDaY1mb2QBAQS8LpAxY0Z5/fXXZcqUKZItWzaT/65du6Rq1ary+eefe/16ZIgAAggggAABUJ4BBBBAAAEEEEAAgZAS0ImOtIv77t27Tb0zZMggffr0Ma3SChcuHFIWVBaBQApUr15dPvroI9FWoZpOnDghjRo1Mi2wA1kuro0AAggg4D4BAqDuu6fUCAEEEEAAAQQQQMCDgI4x2KJFCxk4cKBcunTJHFGsWDETgGnfvr2kS8dbYw9sbELApwL6f/Djjz+Whx56yFwnNjZWevbsKa+++qroMgkBBBBAAAFvCPAuzxuK5IEAAggggAACCCAQ1AJbt26Vp556SlatWmWXU1ua6QRId999t72NBQQQ8L9Anjx5ZPHixVKvXj374m+99ZYZjuLUqVP2NhYQQAABBBBIrQAB0NTKcR4CCCCAAAIIIICAIwRmzJghNWrUkH379pnyZsmSRcaPHy8jR46UzJkzO6IOFBIBtwvouKBjx46V3r17S1hYmKnu+vXrzbig1nAVbjegfggggAACvhMgAOo7W3JGAAEEEEAAAQQQCKDAyZMn5YUXXpB+/frJxYsXTUm0u622+qxTp04AS8alEUAgIYEOHTqItv7ULyo0bd++3cwQ/9VXXyV0CtsRQAABBBBIUoAAaJJEHIAAAggggAACCCDgNAGdzV27vOvYglaqX7++Wb/tttusTbwigEAQCjz99NOybNkyyZ8/vynd0aNHpUGDBrJo0aIgLC1FQgABBBBwggABUCfcJcqIAAIIIIAAAgggkGyB2bNni84uvWfPHnOOtiQb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V6T1SoBAawuUub57asMUR/rJJ5/k+8zuu++ejjjiiGJ13VdtmLosVhL4Vwv0FIcp0yYqk6ad8Xf7q5H333Y+AHVvjMDbb7+dpk6dmntnxj+08WtkBBlicO7+/funGF+vdmblSy65JMU/8Ndee22aMGFCR0W2bduWrr/++rRq1arcuzPyiy8R8QtmBFPji8P06dPzY/BFojJpirReCRBobYEy1/crr7yS7r777hRfDt566618gFu2bEkxUUAxsHds62k59thjc0+u2B7lT5w4MT8yH59HjRqV//vss89S9EqPJe5ZxZecvMIfAgTaRqCRbZglS5akSZMm5eBEjH1+3nnn5ftQlPHVV1+lo446KsWPL8W4e4FU5h7XNrgqSuBfLlDm+q7XhunMGD/m3nfffbmDydy5cztv6vZeG6YbiRUEdmmBaG/cdttteULGBx98sO6x9hSHiZ3LtInKpKlbsTZYKQDaBiepqiouW7YsBya/++67jiKjZ2gEDmKA7tplRxdeBCpmzpyZJygpxgKNYEUEL6677rq011571WaXyqTplokVBAi0pMDOXt/1vjxEj4n4weXvLMccc0zuwVXsG723okf7/Pnz82RHxfp4fP7GG29M8eunhQCB9hVoZBsmHnN/4IEH8g+5hcjee++dzjjjjBwcLYbwKbbF687e4zqn9Z4AgdYW2Nnru14bpvMRRg/zxx9/PEUnkWnTpnXeVPe9NkxdFisJ7JIC/zQAGig72yYqm6YdT4AAaDuetT6uc/TSjMH8Y0DcQw45pEtPzZ0tOnp+xiOn0dE4Ag0DBgzoNYsyaXrN1A4ECLSEQLOv7yj/m2++ST///HM6+uij08CBA1vCRSUIEGiMQCPbMDFxY7SHYnK0aMP85z+9jxzV7HtcYxTlQoBAPYFmX9/aMPXOinUECPQkUKZNVCZNT+W34noB0FY8K+pEgAABAgQIECBAgAABAgQIECBAgEBDBHr/KbshxciEAAECBAgQIECAAAECBAgQIECAAAEC1QsIgFZvrkQCBAgQIECAAAECBAgQIECAAAECBCoSEACtCFoxBAgQIECAAAECBAgQIECAAAECBAhULyAAWr25EgkQIECAAAECBAgQIECAAAECBAgQqEhAALQiaMUQIECAAAECBAgQIECAAAECBAgQIFC9gABo9eZKJECAAAECBAgQIECAAAECBAgQIECgIgEB0IqgFUOAAAECBAgQIECAAAECBAgQIECAQPUCAqDVmyuRAAECBAgQIECAAAECBAgQIECAAIGKBARAK4JWDAECBAgQIECAAAECBAgQIECAAAEC1QsIgFZvrkQCBAgQIECAAAECBAgQIECAAAECBCoSEACtCFoxBAgQIECAAAECBAgQIECAAAECBAhULyAAWr25EgkQIECAAAECBAgQIECAAAECBAgQqEhAALQiaMUQIECAAAECBAgQIECAAAECBAgQIFC9gABo9eZKJECAAAECBAgQIECAAAECBAgQIECgIgEB0IqgFUOAAAECBAgQIECAAAECBAgQIECAQPUCAqDVmyuRAAECBAgQIECAAAECBAgQIECAAIGKBPpVVI5iCBAgQIAAAQIECLSMwMcff5w2bdqU6zN06NA0ePDgunVbs2ZNWrduXd52+OGHpyFDhtTdz0oCBAgQIECAAIHWFRAAbd1zo2YECBAgQIAAAQJ9JLBkyZJ01VVX5dxHjhyZFi9enPr169o0/vrrr9OoUaPSTz/9lA488MC0fPnyPqqNbAkQIECAAAECBPpSwCPwfakrbwIECBAgQIAAgZYUmDBhQho/fnyu29KlS9OMGTO61HP79u0p9ongZyyzZ89Ohx56aJd9fCBAgAABAgQIEGgPgd3++9fSHlVVSwIECBAgQIAAAQKNE9iwYUM68cQTU/T03HPPPXMPz2HDhuUC7rvvvnTrrbfm9zfffHOaOXNm4wqWEwECBAgQIECAQKUCAqCVciuMAAECBAgQIECglQRef/31dO6556boEzB27Nj0zjvv5EDomDFj0tatW1M8Hr9o0aK0xx57tFK11YUAAQIECBAgQGAnBDwCvxNYdiVAgAABAgQIENi1BM4+++w0ceLEfFDvvfdemjVrVrriiity8HPfffdNzz77rODnrnXKHQ0BAgQIECDwLxTQA/RfeNIdMgECBAgQIECAwP8EtmzZkkaPHp1WrFjxv5V/vZs7d266/PLLu6zzgQABAgQIECBAoP0E9ABtv3OmxgQIECBAgAABAg0UiPE/582bl8cBLbKNGeIFPwsNrwQIECBAgACB9hYQAG3v86f2BAgQIECAAAECDRA46KCD0sCBAzty+vXXXzvee0OAAAECBAgQINDeAgKg7X3+1J4AAQIECBAgQKABAldffXVav359R07PP/98euKJJzo+e0OAAAECBAgQINC+AgKg7Xvu1JwAAQIECBAgQKABAg899FBasGBBzmnKlCnppJNOyu9vuumm9MUXXzSgBFkQIECAAAECBAg0U8AkSM3UVzYBAgQIECBAgEBTBT755JM0cuTItHnz5jRixIj0/vvvp48++iiNGTMmbdu2LZ122mnpnXfeSbvvvntT66lwAgQIECBAgACB8gJ6gJa3k5IAAQIECBAgQKCNBbZu3ZonOorgZ//+/dPs2bPz66hRo9Itt9ySj2zRokVp+vTpbXyUqk6AAAECBAgQICAA6v8BAgQIECBAgACBf6XA1KlT09KlS/Oxx6Pv0QO0WO644440fPjw/HHatGm5Z2ixzSsBAgQIECBAgEB7CXgEvr3Ol9oSIECAAAECBAg0QCAeax83blzavn17Ovnkk9MHH3yQe392znrx4sXp9NNPz/scd9xxadmyZWnAgAGdd/GeAAECBAgQIECgDQT0AG2Dk6SKBAgQIECAAAECjRP45Zdf0pVXXpkDm/Ho+5w5c7oFP6O0GAd00qRJueDVq1d3vG9cTeREgAABAgQIECBQhYAeoFUoK4MAAQIECBAgQIAAAQIECBAgQIAAgaYI6AHaFHaFEiBAgAABAgQIECBAgAABAgQIECBQhYAAaBXKyiBAgAABAgQIECBAgAABAgQIECBAoCkCAqBNYVcoAQIECBAgQIAAAQIECBAgQIAAAQJVCAiAVqGsDAIECBAgQIAAAQIECBAgQIAAAQIEmiIgANoUdoUSIECAAAECBAgQIECAAAECBAgQIFCFgABoFcrKIECAAAECBAgQIECAAAECBAgQIECgKQICoE1hVygBAgQIECBAgAABAgQIECBAgAABAlUICIBWoawMAgQIECBAgAABAgQIECBAgAABAgSaIiAA2hR2hRIgQIAAAQIECBAgQIAAAQIECBAgUIWAAGgVysogQIAAAQIECBAgQIAAAQIECBAgQKApAgKgTWFXKAECBAgQIECAAAECBAgQIECAAAECVQgIgFahrAwCBAgQIECAAAECBAgQIECAAAECBJoiIADaFHaFEiBAgAABAgQIECBAgAABAgQIECBQhYAAaBXKyiBAgAABAgQIECBAgAABAgQIECBAoCkCAqBNYVcoAQIECBAgQIAAAQIECBAgQIAAAQJVCAiAVqGsDAIECBAgQIAAAQIECBAgQIAAAQIEmiIgANoUdoUSIECAAAECBAgQIECAAAECBAgQIFCFgABoFcrKIECAAAECBAgQIECAAAECBAgQIECgKQICoE1hVygBAgQIECBAgAABAgQIECBAgAABAlUI/B8YPwd+3lsR3AAAAABJRU5ErkJggg==" width="672" /></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">envelope &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="co">## create the envelope function</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="co"># Accept reject algorithm</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">n &lt;-<span class="st"> </span><span class="dv">1000</span> <span class="co"># number of samples wanted</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">accepted &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># number of accepted samples</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">samples &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, n) <span class="co"># store the samples here</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="cf">while</span>(accepted <span class="op">&lt;</span><span class="st"> </span>n) {</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  <span class="co"># sample y from g</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  <span class="co"># sample u from uniform(0,1)</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">  u &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb11-16" data-line-number="16">  <span class="cf">if</span>(u <span class="op">&lt;</span><span class="st"> </span><span class="kw">f</span>(y)<span class="op">/</span><span class="kw">envelope</span>(y)) {</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">    <span class="co"># accept</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">    accepted &lt;-<span class="st"> </span>accepted <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb11-19" data-line-number="19">    samples[accepted] &lt;-<span class="st"> </span>y</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">  }</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">}</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">ggplot</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(sample, <span class="dt">y =</span> ..density..), <span class="dt">bins =</span> <span class="dv">50</span>, ) <span class="op">+</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(x, <span class="kw">f</span>(x)), <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;x&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;f(x)&quot;</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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AsErkHfTeKm4RPF/esKpZPwjZlh8RCSrwwdvk1MzBBAIQgECoEHYqFQJAQQQQAABBBBoDIGOObmaahY7apdf4GRXagKeT5vA599NAJSEAAIIhJJA3i0T5CkpdobB23rbYfHlkRHKv+bqUGKgrggggEDAChAADdimo+AIIIAAAggggID/BAbv2afJS5crvqTUuUmOGer+gBnyvtQMfSchgAACoSjgLIBk3hO9q8MnTHvA9ATlK3UovhaoMwIIBJ5AWOAVmRIjgAACCCCAAAII+FPgJDPX592LvvUFP7fFxmjiqKEEP/2JTt4IIBAQAnZ1+Lyx6b6yJtw5TaM3bvY9ZwMBBBBAwJ0C/LnKne1CqRBAAAEEEEAAgWYRuHDDD7pk/Q++e69ISda0oQOVHRXp28cGAgggEMoCuXdNMcPhSxU7+yWHYdzq9c6cyEwPEsqvCuqOAAJuFyAA6vYWonwIIIAAAggggEATCISVleu6lWt02pYDK71/0raNHhncTyVhDBpqgibgFgggEEACOdPudBZGin15jlPq369aJztP8j87tQ+gWlBUBBBAIHQECICGTltTUwQQQAABBBBAoFoBT06OWezoWw03835607yunfR87+4SK717SfiJAAIIHBAw740506dJpSWKfXWuPObIdSvXOkHQDzq2O3AeWwgggAACrhDgz/muaAYKgQACCCCAAAIINI9A2PYdSjn3177gp13y6Kl+vfR8nx4EP5unSbgrAggEioANgj50vz5on+aU2AZBx69YoxO37giUGlBOBBBAIGQE6AEaMk1NRRFAAAEEEEAAgaoC4avXKPnidIVv3eYcKDBD3R8yK71/ldq66ok8QwABBBCoXsC8b84Y2Efh5eU6adsO2R5GNy1frbyIcC3gvbR6M/YigAACzSBAD9BmQOeWCCCAAAIIIIBAcwtEfvq5Us4e4wt+ZphFjv549BCCn83dMNwfAQQCTqDc9AR9bFBf2XmTbbLB0EnfrNTAvRkBVxcKjAACCASrAAHQYG1Z6oUAAggggAACCNQgEP3mPCX/v0sVlp3tnFHSo7tuHjVM65KTariC3QgggAACtQmUmSDow2bRuEWtWzqnRZWVacriZeqZuf99trZrOYYAAggg4H8BAqD+N+YOCCCAAAIIIICAawTi/vSEksbfLE9JiVOm4qNHKOPdt7QjLtY1ZaQg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AgQIECBAgAABAgQIECBAgAABAgSqREAAtEp2lG4SIECAAAECBAgQIECAAAECBAgQIFC8gABo8WZKECBAgAABAgQIECBAgAABAgQIECBQJQICoFWyo3STAAECBAgQIECAAAECBAgQIECAAIHiBQRAizdTggABAgQIECBAgAABAgQIECBAgACBKhEQAK2SHaWbBAgQIECAAAECBAgQIECAAAECBAgULyAAWryZEgQIECBAgAABAgQIECBAgAABAgQIVImAAGiV7CjdJECAAAECBAgQIECAAAECBAgQIECgeAEB0OLNlCBAgAABAgQIECBAgAABAgQIECBAoEoEBECrZEfpJgECBAgQIECAAAECBAgQIECAAAECxQsIgBZvpgQBAgQIECBAgAABAgQIECBAgAABAlUicN6Zs0uV9FU3a1DgT3/6U5g8eXIysve///3hrrvuqsFRGhIBAm0tUFdXFz7+8Y8nzXz4wx8OCxcubOsm1U+AQA0K/O53vwu33XZbMrKPfexjYe7cuTU4SkMiQKCtBR555JFwxx13JM3MnDkzfPrTn27rJtVPgEANCvz0pz8NCxYsSEZ2++23h+nTp9fgKNtvSB3bryktEWgscPr06XDixIlkw8mTJxtnkEKAAIFWCOTPJadOnWpFCVkIECDQWCB/LnFc0thHCgECrRPIn0scl7TOTC4CBBoL5M8lcd1ybgIugT83P6UJECBAgAABAgQIECBAgAABAgQIEKhgAQHQCt45ukaAAAECBAgQIECAAAECBAgQIECAwLkJCICem5/SBAgQIECAAAECBAgQIECAAAECBAhUsIAAaAXvHF0jQIAAAQIECBAgQIAAAQIECBAgQODcBARAz81PaQIECBAgQIAAAQIECBAgQIAAAQIEKljgvDNnlwrun67VuMDRo0fD448/noyyT58+YciQITU+YsMjQKAtBA4fPhw2b96cVP3GN74xXHHFFW3RjDoJEKhxgYMHD4atW7cmo+zfv38YNGhQjY/Y8AgQaAuBAwcOhO3btydVv+lNbwrxPwsBAgSKFdi/f3/YsWNHUuzNb35zuOyyy4qtQv48AQHQPAyrBAgQIECAAAECBAgQIECAAAECBAjUloBL4GtrfxoNAQIECBAgQIAAAQIECBAgQIAAAQJ5AgKgeRhWCRAgQIAAAQIECBAgQIAAAQIECBCoLQEB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gLaPc822Es/SjDfljTfb7d27d70zNYsddDzzc8+ePcnZWH379m3Vk5uzlCm2X/ITIND2AqWcS7L0Nj50Lc5lPXr0CHH+iQ9fsxAgUH0CpZxLsswLjkuq729Gjwk0JVDKuaSp+ltKyzL/tFSn7QQIVLdAlmOMLGWqW6lw7wVAC/vYSoAAAQIECBAgQIAAAQIECBAgQIBAFQs4xaWKd56uEyBAgAABAgQIECBAgAABAgQIECBQWEAAtLCPrQQIECBAgAABAgQIECBAgAABAgQIVLGAAGgV7zxdJ0CAAAECBAgQIECAAAECBAgQIECgsIAAaGEfWwkQIECAAAECBAgQIECAAAECBAgQqGIBAdAq3nm6ToAAAQIECBAgQIAAAQIECBAgQIBAYQEB0MI+thIgQIAAAQIECBAgQIAAAQIECBAgUMUCAqBVvPN0nQABAgQIECBAgAABAgQIECBAgACBwgICoIV9bCVAgAABAgQIECBAgAABAgQIECBAoIoFBECreOfpOgECBAgQIECAAAECBAgQIECAAAEChQUEQAv72EqAAAECBAgQIECAAAECBAgQIECAQBULCIBW8c7TdQIECBAgQIAAAQIECBAgQIAAAQIECgsIgBb2sZUAAQIECBAgQIAAAQIECBAgQIAAgSoWEACt4p2n6wQIECBAgAABAgQIECBAgAABAgQIFBYQAC3sYysBAgQIECBAgAABAgQIECBAgAABAlUsIABaxTtP1wkQIECAAAECBAgQIECAAAECBAgQKCwgAFrYx1YCBAgQIECAAAECBAgQIECAAAECBKpYoGMV913XCRAgQIAAAQIECGQS2LlzZ3jxxReTsv379w+9evVqsp6//vWv4eDBg8m2vn37hksuuaTJfBIJECBAgAABAgQqV0AAtHL3jZ4RIECAAAECBAi0kcCWLVvCLbfcktQ+YsSIUFdXFzp2rH9ovH///nDVVVeFw4cPh549e4bt27e3UW9US4AAAQIECBAg0JYCLoFvS111EyBAgAABAgQIVKTAlClTwqRJk5K+bd26Ndx77731+nn69OkQ88TgZ1xWrlwZ+vTpUy+PNwQIECBAgAABAtUhcN6Zs0t1dFUvCRAgQIAAAQIECJRO4MiRI2HIkCEhnunZpUuX5AzPQYMGJQ3cc8894XOf+1yyPmvWrLBs2bLSNawmAgQIECBAgACBdhUQAG1Xbo0RIECAAAECBAhUksBvfvObcN1114V4TsCYMWPChg0bkkDoyJEjw4kTJ0K8PH7Tpk2hc+fOldRtfSFAgAABAgQIEChCwCXwRWDJSoAAAQIECBAgUFsCEydODLNnz04GtXHjxrBixYrwkY98JAl+9ujRI3z/+98X/KytXW40BAgQIECAwCtQwBmgr8CdbsgECBAgQIAAAQIvCxw/fjxcffXVYceOHS8nnl373ve+FyZPnlwvzRsCBAgQIECAAIHqE3AGaPXtMz0mQIAAAQIECBAooUC8/+fq1auT+4Cm1cYnxAt+phpeCRAgQIAAAQLVLSAAWt37T+8JECBAgAABAgRKIHDxxReHCy64IFfTCy+8kFu3QoAAAQIECBAgUN0CAqDVvf/0ngABAgQIECBAoAQCU6dODYcOHcrV9KMf/Sh8+9vfzr23QoAAAQIECBAgUL0CAqDVu+/0nAABAgQIECBAoAQCDzzwQFi7dm1S0xe+8IUwdOjQZP32228Pe/fuLUELqiBAgAABAgQIECingIcglVNf2wQIECBAgAABAmUVePrpp8OIESPCSy+9FIYNGxY2b94cnnjiiTBy5Mhw6tSpcM0114QNGzaEDh06lLWfGidAgAABAgQIEMgu4AzQ7HZKEiBAgAABAgQIVLHAiRMnkgcdxeBnp06dwsqVK5PXq666KsybNy8Z2aZNm8LSpUureJS6ToAAAQIECBAgIADqb4AAAQIECBAgQOAVKbBo0aKwdevWZOzx0vd4Bmi6LF68OAwePDh5u2TJkuTM0HSbVwIECBAgQIAAgeoScAl8de0vvSVAgAABAgQIECiBQLys/R3veEc4ffp0uPLKK8Mf/vCH5OzP/Krr6urC6NGjkzwDBw4M27ZtC927d8/PYp0AAQIECBAgQKAKBJwBWgU7SRcJECBAgAABAgRKJ3Ds2LHw0Y9+NAlsxkvfV61a1Sj4GVuL9wGdM2dO0vDu3btz66XriZoIECBAgAABAgTaQ8AZoO2hrA0CBAgQIECAAAECBAgQIECAAAECBMoi4AzQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hAQAG0PZW0QIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrBrlAABAgQIECBAgAABAgQIECBAgACB9hD4P6dq1BgrQssMAAAAAElFTkSuQmCC" width="672" /></p>
</div>
<div id="why-does-this-work" class="section level2">
<h2><span class="header-section-number">2.3</span> Why does this work?</h2>
<p>Recall that we require
<span class="math display">\[
cg(y) \ge f(y) \qquad \forall y \in \{y: f(y) &gt; 0\}.
\]</span>
Thus,</p>
<p><br /><br /><br /><br /><br /></p>
<p>The larger the ratio <span class="math inline">\(\frac{f(y)}{cg(y)}\)</span>, the more the random variable <span class="math inline">\(Y\)</span> looks like a random variable distributed with pdf <span class="math inline">\(f\)</span> and the more likely <span class="math inline">\(Y\)</span> is to be accepted.</p>
</div>
<div id="additional-resources" class="section level2">
<h2><span class="header-section-number">2.4</span> Additional Resources</h2>
<p>See p.g. 69-70 of Rizzo for a proof of the validity of the method.</p>
</div>
</div>
<div id="transformation-methods" class="section level1">
<h1><span class="header-section-number">3</span> Transformation Methods</h1>
<p>We have already used one transformation method  <strong>Inverse transform method</strong>  but there are many other transformations we can apply to random variables.</p>
<ol style="list-style-type: decimal">
<li><p>If <span class="math inline">\(Z \sim N(0, 1)\)</span>, then <span class="math inline">\(V = Z^2 \sim\)</span></p></li>
<li><p>If <span class="math inline">\(U \sim \chi^2_{m}\)</span> and <span class="math inline">\(V \sim \chi^2_{n}\)</span> are independent, then <span class="math inline">\(F = \frac{U/m}{V/n} \sim\)</span></p></li>
<li><p>If <span class="math inline">\(Z \sim N(0, 1)\)</span> and <span class="math inline">\(V \sim \chi^2_{n}\)</span> are independendent, then <span class="math inline">\(T = \frac{Z}{\sqrt{V/n}}\sim\)</span></p></li>
<li><p>If <span class="math inline">\(U \sim \text{Gamma}(r, \lambda)\)</span> and <span class="math inline">\(V \sim \text{Gamma}(s, \lambda)\)</span> are independent, then <span class="math inline">\(X = \frac{U}{U + V}\sim\)</span></p></li>
</ol>
<p><br /></p>

<div class="definition">
<span id="def:unnamed-chunk-17" class="definition"><strong>Definition 3.1  </strong></span>A <em>transformation</em> is any function of one or more random variables.
</div>

<p>Sometimes we want to transform random variables if observed data dont fit a model that might otherwise be appropriate. Sometimes we want to perform inference about a new statistic.</p>

<div class="example">
<span id="exm:unnamed-chunk-18" class="example"><strong>Example 3.1  </strong></span>If <span class="math inline">\(X_1, \dots, X_n \stackrel{iid}{\sim} \text{Bernoulli}(p)\)</span>. What is the distribution of <span class="math inline">\(\sum_{i = 1}^n X_i\)</span>?
</div>

<p><br /><br /></p>

<div class="example">
<span id="exm:unnamed-chunk-19" class="example"><strong>Example 3.2  </strong></span>If <span class="math inline">\(X\sim N(0,1)\)</span>, what is the distribution of <span class="math inline">\(X + 5\)</span>?
</div>

<p><br /><br /></p>

<div class="example">
<span id="exm:unnamed-chunk-20" class="example"><strong>Example 3.3  </strong></span>For <span class="math inline">\(X_1, \dots, X_n\)</span> iid random variables, what is the distribution of the median of <span class="math inline">\(X_1, \dots, X_n\)</span>? What is the distribution of the order statistics? <span class="math inline">\(X_{[i]}\)</span>?
</div>

<p><br /><br /></p>
<p>There are many approaches to deriving the pdf of a transformed variable.</p>
<p><span class="pagebreak"></span></p>
<p>But the theory isnt always available. What can we do?</p>
<div id="algorithm-2" class="section level2">
<h2><span class="header-section-number">3.1</span> Algorithm</h2>
<p>Let <span class="math inline">\(X_1, \dots, X_p\)</span> be a set of independent random variables with pdfs <span class="math inline">\(f_{X_1}, \dots, f_{X_p}\)</span>, respectively, and let <span class="math inline">\(g(X_1, \dots, X_p)\)</span> be some transformation we are interested in simulating from.</p>
<ol style="list-style-type: decimal">
<li><p>Simulate <span class="math inline">\(X_1 \sim f_{X_1}, \dots, X_p \sim f_{X_p}\)</span>.</p></li>
<li><p>Compute <span class="math inline">\(G = g(X_1, \dots, X_p)\)</span>. This is one draw from <span class="math inline">\(g(X_1, \dots, X_p)\)</span>.</p></li>
<li><p>Repeat Steps 1-2 many times to simulate from the target distribution.</p></li>
</ol>
<p><br /><br /></p>

<div class="example">
<span id="exm:unnamed-chunk-21" class="example"><strong>Example 3.4  </strong></span>It is possible to show for <span class="math inline">\(X_1, \dots, X_p \stackrel{iid}{\sim} N(0,1)\)</span>, <span class="math inline">\(Z = \sum_{i = 1}^p X_i^2 \sim \chi^2_p\)</span>. Imagine that we cannot use the <code>rchisq</code> function. How would you simulate <span class="math inline">\(Z\)</span>?
</div>

<p><br /></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">library</span>(tidyverse)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="co"># function for squared r.v.s</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">squares &lt;-<span class="st"> </span><span class="cf">function</span>(x) x<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">sample_z &lt;-<span class="st"> </span><span class="cf">function</span>(n, p) {</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  <span class="co"># store the samples</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  samples &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(n<span class="op">*</span>p), <span class="dt">nrow =</span> n))</a>
<a class="sourceLine" id="cb13-9" data-line-number="9"></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  samples <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="st">    </span><span class="kw">mutate_all</span>(<span class="st">&quot;squares&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># square the rvs</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12"><span class="st">    </span><span class="kw">rowSums</span>() <span class="co"># sum over rows</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb13-14" data-line-number="14"></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="co"># get samples</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16">n &lt;-<span class="st"> </span><span class="dv">1000</span> <span class="co"># number of samples</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17"></a>
<a class="sourceLine" id="cb13-18" data-line-number="18"><span class="co"># apply our function over different degrees of freedom</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">samples &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">chisq_2 =</span> <span class="kw">sample_z</span>(n, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">                      <span class="dt">chisq_5 =</span> <span class="kw">sample_z</span>(n, <span class="dv">5</span>),</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">                      <span class="dt">chisq_10 =</span> <span class="kw">sample_z</span>(n, <span class="dv">10</span>),</a>
<a class="sourceLine" id="cb13-22" data-line-number="22">                      <span class="dt">chisq_100 =</span> <span class="kw">sample_z</span>(n, <span class="dv">100</span>))</a>
<a class="sourceLine" id="cb13-23" data-line-number="23"></a>
<a class="sourceLine" id="cb13-24" data-line-number="24"><span class="co"># plot results</span></a>
<a class="sourceLine" id="cb13-25" data-line-number="25">samples <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb13-26" data-line-number="26"><span class="st">  </span><span class="kw">gather</span>(distribution, sample, <span class="kw">everything</span>()) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># make easier to plot w/ facets</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27"><span class="st">  </span><span class="kw">separate</span>(distribution, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;dsn_name&quot;</span>, <span class="st">&quot;df&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># get the df</span></a>
<a class="sourceLine" id="cb13-28" data-line-number="28"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">df =</span> <span class="kw">as.numeric</span>(df)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># make numeric</span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pdf =</span> <span class="kw">dchisq</span>(sample, df)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># add density function values </span></a>
<a class="sourceLine" id="cb13-30" data-line-number="30"><span class="st">  </span><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="co"># plot</span></a>
<a class="sourceLine" id="cb13-31" data-line-number="31"><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(sample, <span class="dt">y =</span> ..density..)) <span class="op">+</span><span class="st"> </span><span class="co"># samples</span></a>
<a class="sourceLine" id="cb13-32" data-line-number="32"><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(sample, pdf), <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="co"># true pdf</span></a>
<a class="sourceLine" id="cb13-33" data-line-number="33"><span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span>df, <span class="dt">scales =</span> <span class="st">&quot;free&quot;</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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oY7rkpESFZlBAiRAAiRAAiRAAiRQYQKBls38kRv9aVPhibMDEiABEiABEiABEiCBEgQsrQDt0aOHNGvWTDZu3CgzZ850gzNhwgQ5fPiwwLF89+7d3coWLFggP/zwg2zdutUtf+DAgfp83Lhxbo6hDxw4IJ9++qku69+/v1sbnpAACZAACZAACZAACQSHgD+yGfytQ86bPXu226D8kRv9aeN2UZ6QAAmQAAmQAAmQAAkEhIAK+InwoNZN8+bNk2eeeUZbZ8LBPJanr169WhYtWiSI6vjmm2/KOeec4wZowIABAuF46NChMmjQIGcZnL7ff//9sm7dOoHVAfpD4BpYmEKZigjvL730kl4G72xUzoNyR+MqZ/++VP/vf/8r+/bt01X/9Kc/iWtQJF/as075CSC6KqySsTEFlwAsuHfs2KEvAsudikSZC+5II6d3fr4r717+9ttv+qUfrnjxxRdLvXr1Ku/iFr0SgidA1OLzu/wfAAQZMZHFy9+6sIU/stmsWbPkxRdfFNy7uXPnul3aH7nRnzZuFy3jBAGQqjqgGV72//zzz3qkLVu2lE6dOpUx6sgpxucUnxXI/FZKMAjZs2ePnnLv3r2levXqlpm+CYqD54tV0unTp+Xbb7/V001PT5eePXtaZep6npBVcb+tpDpZtWqVbNiwQc//oosukvr161vmnsNtITarPde/+OILLa9CvwM9T6imlJQUv4dmeQUoyK1YsUIrJo1SD3mwDH344Yelc+fOOHVL3hSgqIRIYaNHj5bvv//e6QsU/yT79Okj9957ryQkJLj1FY4nd911l8yfP18PHW4CSotaH47z45itTeDRRx+V6dOnawj4J9C+fXtrA+HsI4rACy+8IB9//LGe0wcffCAQaJlIINIJlFc2K00BClbllRv9bRNO92XhwoUyZMgQPeRbb71VGxeE0/g51vITgNGHcReGlXQtWrQofydsETYEoOyGcQ8SjHr+85//hM3YOVD/CLzyyivO+/yvf/3Lef/9642twoEAfvcing30O+b5Hg7jLs8YY8pT2Ze6y5cvl3bt2kl8fLwv1UOiDt5ST548WVtpIogRHNbjzRa0/p7S559/7ilb52HeTzzxhAwfPlw2b96s3xI1btyYVpJeibGABEiABEiABEiABIJHoLyyGazZsHlL5ZUb0Y8/bbxdn/kkQAIkQAIkQAIkQALlJxBwBejTTz8tv/zyi8Dn0uDBg6Vr167lH1UVtahdu7ZgC0SCmXzr1q0D0RX7IAESIAESIAESIAESqCCBQMtm/siN/rSp4LTZnARIgARIgARIgARIQBHwbOJYQTRHjhyRf/7zn9KtWzdtDfrqq69qn5kV7JbNSYAESIAESIAESIAESIAESIAESIAESIAESIAESKBcBAKuAB05cqTAR6RxWr927Vp57LHHBMvA4UgVy8fhi4mJBEiABEiABEiABEiABEiABEiABEiABEiABEiABIJNIOAKUFh9jh07VkcJ//TTT+Waa67RkRERNQ0Osm+66SYdQWzYsGGCaMtMJEACJEACJEACJEACJEACJEACJEACJEACJEACJBAsAgH3AWoGmpiYKDfffLPeEF194sSJ8tFHH8nKlSvl6NGj8u677+qtbdu22lfo7bffLg0aNDDNuQ9hAmlpac7I7/CnxUQCkUSgVq1azs93XFxcJE2NcyEBSU1NdX6+ExISSIQESIAEAkIAzxNEjUXCc4Yp8gnAn62557GxsZE/YYvPMDo62nm/8VuQKfIJUGaM/HtcfIZ4piMKPAKCR2qyOVSqzMmtWrVKJk2aJF9//bWsWbPGeWk8VK+88kq588475c9//rNQ8eBEwwMSIAESIAESIAESIAESIAESIAESIAESIAESIAE/CVS6AtR1nFCCPvjgg7Jjxw7XbKlTp47cf//98vDDD/MtshsZnpAACZAACZAACZAACZAACZAACZAACZAACZAACZSHQKUrQJctWyafffaZTJs2TTZu3Og21latWuk8Y5TasmVLmT59urRu3dqtHk9IgARIgARIgARIgARIgARIgARIgARIgARIgARIwBcClaIA3bZtm0yYMEE++eQTWb9+vdu44Gdg8ODBcscdd0hGRoa2Bv3ggw/k9ddfl1OnTmkLUESSr1+/vls7npAACZAACZAACZAACZAACZAACZAACZAACZAACZBAWQSCpgA9cuSITJ48WSs9FyxYIMaqEwOKj4+XG264QYYMGaL9fkZFlQxGj4jxf/rTn/T4EVX+rrvuKmsuLCcBEiABEiABEiABEiABEiABEiABEiABEiABEiABNwIBV4D++OOP8s9//lNmzJghubm5bhc777zztNJz4MCBUrNmTbcyTyeIxoyI8VB+QgnKRAIkQAIkQAIkQAIk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nJwcDsPmGEmgwgTw2YcLCCwKgeI/KSmpwn2yAxIgAesQ4DPEOvcaM6W8ZK37XdZs+duwLEKRVY5AmdAFIDgsZMaoKHpVjKw7XHI2kfQdrxIF6O7du3VQHfzQuu6665yRJEuiZg4JkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJ+E8gKOp6vBWcNm2a/PnPf3ZGCDdDHDVqlDRq1EgHFLn77rulfv36MmjQIG11YupwTwIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAKBIBAUBeiTTz6p/Yd9/fXXsmHDBuc4p0+fLs8995zzHAd2u10+/vhjefbZZ93yeUICJEACJEACJEACJEACJEACJEACJEACJEACJEACFSUQcAXozz//LG+88YYeV0xMjLg6w33hhRe0pScCLCBwzrJly+SBBx7QdaEYxTkTCZAACZAACZAACZAACZAACZAACZAACZAACZAACQSKQEygOjL9fPDBB9qqs3379vLFF19Iq1atdNH27dtl8eLF+rhv375OJSmih69bt05mz54t8+fPly5dupiuuCcBEiABEiABEiABEiABEiABEiABEiABEiABEiCBChEIuAXo2rVr9YAGDx7sVH4iY8aMGc6B9uvXz3mMg/79++vz5cuXu+XzhARIgARIgARIgARIgARIgARIgARIgARIgARIgAQqQiCgClBEdV+/fr0ez9VXX+02rpkzZ+pzLH+/6qqr3MoQCAlpzZo1bvk8IQESIAESIAESIAESIAESIAESIAESIAESIAESIIGKEAioAhQBjXJzc/V4qlev7hwX8ubMmaPPu3btKjVr1nSW4eDAgQP6PDU11S2fJyRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRQEQIBVYDCurNp06Z6PMYSFCcIjHTy5EmdX9wyFJnw/4nUpEkTvecfEiABEiABEiABEiABEiABEiABEiABEiABEiABEggEgYAqQDGgHj166HGNGjVKNm/eLKdPn5Ynn3zSOdYBAwY4j7Ozs3UwpM8++0znXXTRRc4yHpAACZAACZAACZAACZAACZAACZAACZAACZAACZBARQnYlN9OR0U7cW2PQEYmkntsbKzEx8c7rT979+4txhfoggULBMrQPXv26OaNGzeWTZs2SVxcnGt3PCYBEiABEiABEiABEiABEiABEiABEiABEiABEiABvwkE3AK0c+fOMn78eIHyMy8vz6n8bNeunUyaNMk50MzMTKfys06dOrqMyk8nHh6QAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAkEgEDALUDNmH7//XeZMWOGbN26VS655BKB9WdKSoopli1btsgFF1wg/fr1k8cee8zpO9RZgQckQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkUEECQVOAljUurLzHFhUVcCPUsi7NchIgARIgARIgARIgARIgARIgARIgARIgARIgAYsQqDIFqEX4cpokQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAJVSCAmmNc+cOCAbNiwQUeCz8/PL/NSrVq1koyMjDLrsQIJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJ+EIgKApQKD2feuopmTZtmvii+DQDHTlypIwaNcqcck8CJEACJEACJEACJEACJEACJEACJEACJEACJEACFSIQcAXoiRMn5Prrr5c//vijQgNjYxIgARIgARIgARIgARIgARIgARIgARIgARIgARKoKIGAK0Cfe+45p/ITy9kHDhwozZo1k/T0dLHZbKWOt2XLlqWWs1Dk999/JwYSIAESIAESIAESiHgC0dHR0rZt24ifZ0UnuGvXLjl27FhFu2F7EiABEiABEiABEgh5Au3bt/d7jAFXgM6fP18PplOnTvLjjz9KrVq1/B4cG5YkUFBQUDKTOSRAAiRAAiRAAiRAApYkYLfbhfKhJW89J00CJEACJEACJFAOAlHlqFtmVQhfK1eu1PXuvPNOKj/LJMYKJEACJEACJEACJEACJEACJEACJEACJEACJEACwSQQUAUoliolJSXp8cIClIkESIAESIAESIAESIAESIAESIAESIAESIAESIAEqpJAQBWgmMj555+v57Nt2za95x8SIAESIAESIAESIAESIAESIAESIAESIAESIAESqCoCAVeAXnbZZXouY8eOrao58bokQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkoAkEXAH64IMPSt++fWXu3Lny0EMPyYkTJ4iaBEiABEiABEiABEiABEiABEiABEiABEiABEiABKqEQMCjwK9Zs0aGDh0qS5YskbffflsmTZokXbp0kaZNm0qdOnVKnSSsRy+99NJS67CQBEiABEiABEiABEiABEiABEiABEiABEiABEiABHwlEHAF6JNPPikzZsxwXv/gwYMya9Ys53lpBzExMVSAlgaIZSRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAuUiEPAl8OW6OiuTAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQQBAJBNwC9LPPPpP8/Hy/hpyQkOBXOzYiARIgARIgARIgARIgARIgARIgARIgARIgARIgAU8EAq4ATU5O9nQd5pEACZAACZAACZAACZAACZAACZAACZAACZAACZBApRPgEvhKR84LkgAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJVBaBSlWAnjp1Sk6ePFlZc+N1SIAESIAESIAESIAESIAESIAESIAESIAESIAELE4gqApQRIAfPny49OrVSxo0aCBYHj9y5EiNfOvWrdKzZ0+ZMmWK2O12i98GTp8ESIAESIAESIAESIAESIAESIAESIAESIAESCAYBALuAxSDdDgcMmbMGHn22Wfl2LFjHse9bds2mT9/vt5uueUWGT9+vMTGxnqsy0wSIAESIIHgE5g1a5ZMmDBBRowYIW3atPF6wQ0bNsiXX34pO3bskKSkJGnfvr1+0dW8eXOvbVhAAiRAAiRAAiRAAiQQmgSCKQNSbgzNe85RkYAVCQRFAfrmm2/KI488onnGxMRIhw4d5MSJE7Jp0yYnY0SKh8IzLy9PJk6cKImJiTJ27FhnOQ9IgARIgAQqj8CaNWsEz248m3Nzc71eeOrUqfLPf/5Tl0P5iWf4b7/9Jl988YU8//zz0rFjR69tWUACJEACJEACJEACJBBaBIIpA1JuDK17zdGQgNUJBHwJ/OrVq+XJJ5/UXK+99lrZvHmzLF++XHDsmq688kpdhmXwSLAAxdshJhIgARIggcolsHLlSu2eBMrP0hIE5HfeeUfi4uJk1KhRMm3aNPnqq69k2LBhkpWVpZ/9+/fvL60LlpEACZAACZAACZAACYQIgWDKgJQbQ+QmcxgkQAJOAgFXgI4ePVpycnKkU6dOMnnyZGnSpInzYsUPGjduLN99953UqlVLCgoK5IMPPiheheckQAIkQAJBInD69Glt9fnoo49qdyVRUaX/S/jkk0+0i5OBAwfKRRddJDabTVvy9+3bV/r06aOtQb/55psgjZbdkgAJkAAJkAAJkAAJBIJAZciAlBsDcafYBwmQQCAJlP5r148rYSkkEqxAsay9rIQ6xjp048aNZVVnOQmQAAmQQIAIwHJz+vTpUq1aNf3Mbtq0qdeeISgvXbpUl19xxRUl6pm8GTNm6GX0JSowgwRIgARIgARIgARIICQIBFsGpNwYEreZgyABEihGIKAKUFhxwtQdqUuXLsUu5f20d+/euhABNZhIgARIgAQqhwCC1EFx+f7778vll19e6kXhogQB7ho1aiT169cvUbd169ZSvXp1OX78uOzcubNEOTNIgARIgARIgARIgARCg0CwZUDKjaFxnzkKEiABdwIBDYIUHR0tycnJcuTIEcnMzHS/UilnBw8e1KUNGjQopRaLSIAESIAEAkngvffek3r16vnU5e7du3W91NRUr/VTUlJ0wLtdu3YJI8J7xcQCEiABEiABEiABEqhSAsGWASk3Vunt5cVJgAS8EAioBSiuce655+pLzZ4928slS2bDDyhS+/btSxYyhwRIgARIICgEfFV+4uJYyoRUo0YNvff0x5SZup7qMI8ESIAESIAESIAESKBqCQRbBjSyoJENPc3WlJm6nuowjwRIgAQCSSDgCtDu3bvr8T333HOyadOmMsc6btw4mTlzpq5XnmXzZXbMCiRAAiRAAgEjYIRTI6x66jgpKUlnZ2dneypmHgmQAAmQAAmQAAmQQJgR8EcG9KdNmGHhcEmABMKQQMAVoI8//rgguvuJEyfkvPPOk3/961+yf//+Emi2b98ud999t9x11126DBGFEUmYiQRIgARIIPQIGOVmTk6O18Hl5ubqsri4OK91WEACJEACJEACJEACJBA+BPyRAf1pEz5EOFISIIFwJRBwBSj8w3344YcSFRWl/YDef//9kp6erhWhgPTpp59KnTp1pFmzZvLBBx/ooBqIQAxLULRhIgESIAESCD0CaWlpelB4ueUtIQASkhF6vdVjPgmQAAmQAAmQAAmQQHgQ8EcG9KdNeNDgKEmABMKZQFA0jpdeeqn88ssv0qNHDycbYzW0d+9eOXTokDMfkYeXLl0qLVu2dObxgARIgARIILQI1K5dWw+oNAWoKatZs2ZoDZ6jIQESIAESIAESIAES8IuAPzKgP238GhwbkQAJkEA5CAQ0Crzrdbt27SoLFy6UKVOm6P3GjRsFm8PhkFatWklGRoZAUXr99de7NuMxCZAACZBACBKA5T4SIrzn5eVJbGys2ygzMzPlyJEj2pKfL7Tc0PCEBEiABEiABEiABMKWgD8yoD9twhYQB04CJBA2BIKmAAUBm80m/fv311vYEOFASYAESIAEShCoX7++tG7dWjZs2CC//vqrXHDBBW515s2bJ3a7Xdq0aSOJiYluZTwhARIgARIgARIgARIITwL+yID+tAlPOhw1CZBAOBEIyhL4cALAsZIACZAACfhGAC+0kD766CMd6M60OnjwoHz++ef6tF+/fiabexIgARIgARIgARIggQgg4I8M6E+bCEDFKZAACYQwAb8tQPft2yfw5xnIhDdFCJjERAIkQAIkEHoEevbs6bQCHTZsmPTq1Uvy8/Nlzpw5cvjwYTn//PN1XuiNnCMiARIgARIgARIgARLwl4A/MqA/bfwdH9uRAAmQgC8E/FaAvvfeezJq1ChfruFzHfQ3cuRIn+uzIgmQAAmQQOURiI6OltGjR8tbb70ls2fPlkmTJumLI79Pnz5y1113aR+glTciXokESIAESIAESIAESCDYBPyRAf1pE+x5sH8SIAFrE7CpoEQOfxA8++yzVID6A66CbVauXFnBHticBEiABCpOAJafW7du1X4/GzVqJElJSRXvlD2QAAmQgAsB/Hhu3769Sw4PPRHYsWOHHD161FMR80iABEgg4AT8kQH9aRPwgbNDEiCBiCBw7rnn+j0Pvy1Ab7jhBmnevLnHC//xxx/y4osv6rKmTZvKPffco6O+40dyXFycQFBDII133nlHdu7cKfXq1ZOJEydK27ZtPfbHTBIgARIggdAiEBMTo5/roTUqjoYESIAESIAESIAESCCYBPyRAf1pE8w5sG8SIAFrEvDbAtQbrkOHDkmPHj1k8+bN8vzzz8vjjz8usbGxHqvn5ubK//3f/+nllIgo/P3339OKyCOpM5m0AD3DgkckQAIkQAIkQAKRS4AWoL7dW1qA+saJtUiABEiABEiABMKfQEUsQAMeBR6Wn1B+3n777fLUU095VX4CO6xB4U8ODpIXLlyorUDD/3ZwBiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAqFCIOAK0Hnz5um5DR482Kc5RkVFyY033qjrLliwwKc2rEQCJEACJEACJEACJEACJEACJEACJEACJEACJEACvhAIqAIUzo3NEm34/vQ1paWl6aq///67r01YjwRIgARIgARIgARI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AiRAAiRAApVDYP369TJ58mTZvn27DnDXoUMHueyyy6RFixblHkBOTo5MmTJFli5dKkePHpWMjAzp2LGj9O7dW/v89dThoUOHZOLEibJx40bJysqSdu3aSadOneSSSy7xVJ15JEACJEACJEACJEACASZABWiAgbI7EiABEiABEiABEiCB0CEAZeWYMWP0gOBTFL5Uly9fLp9//rm8/PLL0rlzZ58He+zYMRk2bJjs3LlTt6lVq5bMmjVLbwsXLpSRI0dqv7+uHS5evFieeuopp/92+CvfsGGDfPnll/KnP/1JHnvsMa+KU9d+eEwCJEACJEACJEACJOA/AS6B958dW5IACZAACZAACZAACYQwgdWrV8tbb72llZIvvviizJgxQysrH3roIW2JOXz4cNm3b5/PM3j++ee18rN79+4yffp0+eqrr2TSpEly1llnybx58/S1XDs7cOCAPPvss1r5eeONN8pnn30m33zzjbz66qvSrFkzPZ53333XtQmPSYAESIAESIAESIAEgkCAFqBBgMouSaA0AkOGDCmtmGUkQAIkQAIkQAIBIvDhhx+Kw+GQ2267TS6++GLda2xsrPTv31/27Nmjl7JPmzZN7rvvvjKvuHbtWlmyZIkkJibKCy+8IAkJCbpNw4YN5Y033pC+ffvKzJkz5d577xVYeSLBOvTEiROCOg8++KBERRXaHvTo0UPnP/fcczJ37lx54IEHdH3+IQESIAESIAESIAESCA4BWoAGhyt7JYEyCSTk50tqTq7aciQpL09s6gcaEwmQAAmQAAmQQGAInD59Wiss0dvVV19dolOTB0vOfPU/uawERSVSr169nMpPnaH+YCl8t27d9PJ6KEFNgiIU+YMGDXIqP01Zz5499eH+/fu1L1GTzz0JkAAJkAAJkAAJkEDgCdACNPBM2SMJuBMoKJCYFSsldtFiiV25St6Zv0TqZWVLvN3uVq9AnR2Nj5dlaTUlJzpaNqTUkN9rpcrhhHi3ejwhARIgARIgARIom8C6deu09Wfjxo2lQYMGJaRFOtIAAEAASURBVBq0adNGW2pmZmbKjh07ygyItGbNGt0Hlr97SlB0Llq0SFatWiUDBgzQVfr06SPYPKUtW7bobIytZs2anqowjwRIgARIgARIgARIIEAEqAANEEh2QwLFCcQsWSoJk7+Q+JnfSdSRo87iJs4j94No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QAIkQAIkQAIkQAIkQAIkQAJRQYAC0Ki4jOwECZAACZAACZAACZAACZAACZAACZAACZAACZCAEwEKQJ2oMI4ESIAESIAESIAESIAESIAESIAESIAESIAESCAqCFAAGhWXkZ0gARIgARIgARIgARIgARIgARIgARIgARIgARJwIkABqBMVxpEACZAACZAACZAACZAACZAACZAACZAACZAACUQFAQpAo+IyshMkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAJOBCgAdaLCOBIgARIgARIgARIgARKoIAIbNmwQj8djtr/+9a8V1Ar+LAmQAAmQAAmQAAlEDwEKQKPnWrInJEACJEACJEACJEACJEACJEACJEACJEACJEACQQQoAA0CwlMSIAESIAESIAESIAESIAESIAESIAESIAESIIHoIUABaPRcS/aEBEiABEiABEiABEiABEiABEiABEiABEiABEggiAAFoEFAeEoCJEACJEACJEACJEACJEACJEACJEACJEACJBA9BBKipyvsCQmQAAmQAAmQAAmQQGUj8NNPP8lXX30la9askeTkZGnfvr3ZmjVrZpwAldSfLVu2yKpVq8y2fft2adq0qbRq1crUUadOnSLF8/LyZNGiRSYev5Weni65ubny7bffyieffCK1atWS8847T1q0aBFQ1pabN2+exMfHS7t27eSCCy6QhISiw+mNGzcK2oK68Rter1dWrlwpn332mWzevFnQt/PPP18aNGgQ8BulPUG94Pf999/L8uXLpX79+tK5c2fp2LGjpKSklLY65icBEiABEiABEiCBqCVQdMQWtV1lx0iABEiABEiABEiABCKFwO7du+Waa66R9957zwgIg9vVr18/efnll6Vhw4bBSeYcQkaU//jjjx3TIUx98MEHZfTo0QFCyoMHD0qPHj1Mmfnz50t2drYMGzZM9u/fH1APBIlIr1q1qixYsEAGDx4se/bsKZLnjTfekLZt2wbEjxs3TsaPH29+5z//+Y8MGjRIvvzyy4A8VapUkREjRsjTTz8tOC5tWL16tVxxxRWycOHCIkUzMzPlxRdflP/5n/8pksYIEiABEiABEiABEohFAlwCH4tXnX0mARIgARIgARIggQokcPToUbn44ovl3XffNcJPCCSvuuoqGTJkiFSvXt20DILNTp06yfr164u09KOPPpLTTjvN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p3z/zTffBNgsRQM++eQTY/sUfcDy+AkTJoTdrvvvv18aNGhg8kMYet9998mhQ4fMeU5OjsycOVMuuugiWbVqlYm74YYbpE6dOmHXz4wkQAIkQAIkQAIkEI0EKACNxqvKPpEACZAACZAACZBABBO46qqrxApBsby9Q4cOAgc/Xbt2laysLDn33HMFnsvr1atnPMRD89GGsWPHSq1atcwpvMXXr1/fLKc/7bTTJDMzU6zAb9KkST7bm8uWLbPFT/m+W7duMmfOHNNO2PCEMPK8884zdkwTExPlxRdfNEvVw21Yenq6ce4EjVFolj722GMCb/LQ8kTdEH5++umnprohQ4bIk08+GW7VzEcCJEACJEACJEACUUvgxGgyarvIjpEACZAACZAACZAACUQagRdeeMFoa8KuJbQ14RF98eLFZll7jRo15OKLLxZoT1qNT9t+CEqhQdm/f38ThbJYTr98+XLjFAgapdB+vPbaa6Vnz54mz7Rp0wI0Qm1dp2KPtl5zzTXGdufq1atl9+7d5mf79OkjsGcayg5qcW0755xzBELdkSNHGuEnbIHCKRKWviM0a9ZMJk6cKG+++abA5AADCZAACZAACZAACcQ6AY8OGr2xDoH9JwESIAESIAESIAESqBgCEN5t3rxZ4BF93759RhsUArxwArysr1mzRg4cOGDKNW7cWDweTzhFT2oeOGcaP368+Q1oaUKDFcvdFy1aZISU0NYMx+ZnuI2EtiwEwHCQ1Lx5c6NN6681G249zEcCJEACJEACJEAC0UqAAtBovbLsFwmQAAmQAAmQAAmQQIUQcBKAVkhD+KMkQAIkQAIkQAIkQAKGAJfA80YgARIgARIgARIgARIgARIgARIgARIgARIgARKIWgIUgEbtpWXHSIAESIAESIAESIAESIAESIAESIAESIAESIAEKADlPUACJEACJEACJEACJEACJEACJEACJEACJEACJBC1BBKitmfsGAmQAAmQAAmQAAmQAAlUAIGsrCzjlKkCfpo/SQIkQAIkQAIkQAIk4ECATpAcoDCKBEiABEiABEiABEiABEiABEiABEiABEiABEggOghwCXx0XEf2ggRIgARIgARIgARIgARIgARIgARIgARIgARIwIEABaAOUBhFAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiQQHQQoAI2O68hekAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJOBCgANQBCqNIgARIgARIgARIgARIgARIgARIgARIgARIgASigwAFoNFxHdkLEiABEiABEiABEiABEiABEiABEiABEiABEiABBwIUgDpAYRQJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkEB0EKAANDquI3tBAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiTgQIACUAcojCIBEiABEiABEiABEiABEiABEiABEiABEiABEogOAhSARsd1ZC9IgARIgARIgARIgARIgARIgARIgARIgARIgAQcCFAA6gCFUSRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAtFBgALQ6LiO7AUJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkIADAQpAHaAwigRIgARIgARIgARIgARIgARIgARIgARIgARIIDoIUAAaHdeRvSABEiABEiABEiABEiABEiABEiABEiABEiABEnAg8P/3eEltXLuP2QAAAABJRU5ErkJggg==" width="672" /></p>
</div>
</div>
<div id="mixture-distributions" class="section level1">
<h1><span class="header-section-number">4</span> Mixture Distributions</h1>
<p>The <code>faithful</code> dataset in <code>R</code> contains data on eruptions of Old Faithful (Geyser in Yellowstone National Park).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">head</span>(faithful)</a></code></pre></div>
<pre><code>##   eruptions waiting
## 1     3.600      79
## 2     1.800      54
## 3     3.333      74
## 4     2.283      62
## 5     4.533      85
## 6     2.883      55</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">faithful <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="st">  </span><span class="kw">gather</span>(variable, value) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="st">  </span><span class="kw">ggplot</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(value), <span class="dt">bins =</span> <span class="dv">50</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span>variable, <span class="dt">scales =</span> <span class="st">&quot;free&quot;</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAJACAYAAABMocy1AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N0JnB1VnSjgk6SzL2RPCIY9k/BYBgSBQZFNSRRllCGOPFyIgjguPLZBngtBQNxQDDqgiBOUAWWEN6AgUcMyLC4MiMCwGVZZhEAWErJvz385Fbs793bf7r63+9bt7/x+ndu36tSpc75T96b6X3VO9dn055QkAgQIECBAgAABAgQIECBAgAABAgQINKBA3wZskyYRIECAAAECBAgQIECAAAECBAgQIEAgExAAdSAQIECAAAECBAgQIECAAAECBAgQINCwAgKgDdu1GkaAAAECBAgQIECAAAECBAgQIECAgACoY4AAAQIECBAgQIAAAQIECBAgQIAAgYYVEABt2K7VMAIECBAgQIAAAQIECBAgQIAAAQIEBEAdAwQIECBAgAABAgQIECBAgAABAgQINKyAAGjDdq2GESBAgAABAgQIECBAgAABAgQIECAgAOoYIECAAAECBAgQIECAAAECBAgQIECgYQUEQBu2azWMAAECBAgQIECAAAECBAgQIECAAAEBUMcAAQIECBAgQIAAAQIECBAgQIAAAQINKyAA2rBdq2EECBAgQIAAAQIECBAgQIAAAQIECAiAOgYIECBAgAABAgQIECBAgAABAgQIEGhYAQHQhu1aDSNAgAABAgQIECBAgAABAgQIECBAQADUMUCAAAECBAgQIECAAAECBAgQIECAQMMKNDVsy+qkYc8880xaunRpndRGNQgQIECAAAECxRDo169f2m233YpR2Q7W8v777+/gFrITIECAAAECBAj87d/+bacR3AHaaTobEiBAgAABAgQIECBAgAABAgQIECBQ7wICoPXeQ+pHgAABAgQIECBAgAABAgQIECBAgECnBQRAO01nQwIECBAgQIAAAQIECBAgQIAAAQIE6l1AALTee0j9CBAgQIAAAQIECBAgQIAAAQIECBDotIAAaKfpbEiAAAECBAgQIECAAAECBAgQIECAQL0LCIDWew+pHwECBAgQIECAAAECBAgQIECAAAECnRYQAO00nQ0JECBAgAABAgQIECBAgAABAgQIEKh3AQHQeu8h9SNAgAABAgQIECBAgAABAgQIECBAoNMCAqCdprMhAQIECBAgQIAAAQIECBAgQIAAAQL1LiAAWu89pH4ECBAgQIAAAQIECBAgQIAAAQIECHRaQAC003Q2JECAAAECBAgQIECAAAECBAgQIECg3gUEQOu9h9SPAAECBAgQIECAAAECBAgQIECAAIFOCwiAdprOhgQIECBAgAABAgQIECBAgAABAgQI1LuAAGi995D6ESBAoMYCGzZsSH/6059a7OXmm29O//RP/5SuuOKKFsu9IUCAAAECBAgQaAyBts73nnvuuS0aeeqpp2bnh4sXL95inQUECBCodwEB0HrvIfUjQIBADQUee+yx9NGPfjTdeuutLfayZMmStGDBgvTiiy+2WO4NAQIECBAgQIBAYwiUOt+LC+OXXXZZdn7YupWPP/54dn64bt261qu8J0CAQN0LNNV9DVWQAAECBGom8Itf/CI99dRT6ZBDDmmxj5133jm9613vStOmTWux3BsCBAgQIECAAIHGECh1vvfaa6+lH/3oR6mpactQwTve8Y60du3aNGTIkMYA0AoCBHqVwJbfar2q+RpLgAABAqUE9txzzxQ/EgECBAgQIECAQGMKdPR87yMf+UhjQmgVAQK9QkAAtFd0s0YSINAdAhs3bkwxX9ITTzyRYvhQXFWfPHly6tev3xa7f+aZZ1Lfvn2z9THM/MEHH0y77rprmjRpUpb36aefzl633XbbLF/zAuLK+wsvvJBdmX/d6163eVXzMmNo0h/+8Ifs7s4xY8ZkwczBgwdvzhv1e/bZZ9Py5cuzZTEEKva51VZbpVGjRqVXX301xbJhw4alsWPHbt4u/2X9+vXpySefTLHPaN+OO+5YUVs3bdqU7feRRx5JI0aMSFOmTClZfuwn8ka+fA6q7bbbLoVH83bk9fFKgAABAgQIECiiQJyPxXnZ1ltvnQYOHNiiCYsWLcrO1eKcafTo0S3WrVq1Kr300kvZedGECRNarHvllVey863nn38+O9+K88U4J+3fv3+LfK3P92J/+bzwcR4W54aR8vPRP/7xjynOd6O8/A7RvIw43xw+fHhasWJFevTRR9PChQuz88M4R2y936zQ//knplyKc8po+y677JKiLcuWLUsxz2ick8a5qUSAAIFqCPT58xfbpmoUpIzSAhEcWLp0aemVlhIg0DACcYJ4/vnnZydwzRu1/fbbp09/+tPZCWDz5TNmzMhOZD/2sY+lc845JzuZjPUnnnhimjlzZnrLW96SZb/uuuuyIGTzbeNEMR5QFCfKzR9SFMOS4gTzggsuSGeeeWYWwMy3ixPSf/7nf04HHHBAtiiCm7Gf1unoo4/O5ny65ppr0re//e00ffr0bLvm+e6+++508cUXbw5M5uvixPpTn/rUFsPmo14RtLzkkkuyeuUn0/l2xxxzTDruuONaBIojiHzeeedlJ+95vniNcj7xiU9k9Wq+3O8ECDSeQFxc2W233RqvYX9u0f3339+Q7dIoAgQ6LhDnTvfee2867bTT0tve9rYWBZxyyinZRfI3vOEN6Ytf/GKLdddee212bpWfu8XKl19+OX3ta19L99xzT4u88SbOG+NccI899ti8rvX53pw5c9JPf/rTzevzX2JZnIMdeeSRaeXKlenKK6/MApWx/sc//nH6zne+k04++eS0evXq7PfmIYYIlp511llbnAtHoPSzn/1s1r58P/Ea541xThnnjbNmzUrHHnts89V+J0Cglwv87d/+bacF3AHaaTobEiBA4C8CcZU7TlDjrssDDzwwvelNb8ru2vyv//qvFHNsfvzjH09xQvk3f/M3LcjiBPLrX/96GjBgQNppp52yOzb33XffFnk6+iZOPOMJnXHFPIKp48ePT7/5zW+yk9M4cf7Wt76V4k7KmLspgq+33357+u///u+03377pb333ju7I7Otff7+97/PArqR5+CDD077779/Fry96667UvycdNJJ2Ql6lNU8xV0KsS7SBz/4wTRy5Mh03333Zfv/4Q9/mJ2Uv/3tb8/Wh0sEjeMuhCOOOCLFSX/Yhuctt9ySvvrVr2ZB4Te+8Y1Zfv8QIECAAAECBIoqEBenIwAaP80DoHHu9PDDD2fNipFCMfomv+syFsb5XaT8fCjm7jzhhBNSvEaAIM7FYmRRnLtF3riz8+yzz05x3tX6TtOsoD//c9BBB6Vx48alf/3Xf83OZeNBmZHauoMzy/Dnf+KifVzkjvPD2H/chfrLX/4yu2Aegc64aJ+PiooAaZyXRrt2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BAgQIECAAIGeFogHH8X8ffFgg8svv7zF/JYxB96Xv/zlbC65N77xjWnatGk9XV37J0CAAAECBAgQqFDAHaAVQslGgAABAgQIECDQ2ALxQIDZs2enU089Nc2fPz/de++96fDDD8+ehnz77ben5557Lu2www7plFNOaWwIrSNAgAABAgQINJiAAGiDdajmECBAgAABAgQIdF5gn332SZdcckmaM2dOeuSRR9LVV1+dFTZ48OA0ffr0LDgac4RKBAgQIECAAAECxREQAC1OX6kpAQIECBAgQIBAFwViaHt7Keb3vPTSS9Orr76ann322TR8+PA0efLk1Lev2aPas7OeAAECBAgQIFCPAgKg9dgr6kSAAAECBAgQINDjAltttVWKH4kAAQIECBAgQKDYAg0XAF20aFH693//9/TEE0+kl156KY0fPz6bq+kf//Ef07hx40r21po1a9I111yT7rnnnhRP/5wyZUqKSfBnzJiRzflUciMLCRAgQIAAAQIECBAgQIAAAQIECBCoe4GGCoDedttt6fzzz8+eztmvX780ZsyYbPL6u+++O/3kJz9Jn/rUp9Jhhx3WolOWLl2aPvaxj2XDm2LF6NGj07x587KfX/3qV9lE+AMGDGixjTcECBAgQIAAAQIECBAgQIAAAQIECBRDoGEmMnr++ec3Bz9nzZqVfv7zn6drr702e/3ABz6QBUW/9KUvbQ505t1z7rnnZsv222+/dMMNN6Trr78+/ehHP0o77bRTiqd9XnTRRXlWrwQIECBAgAABAgQIECBAgAABAgQIFEygYQKgP/3pT7Mg51ve8pb0oQ99KA0cODDring94YQT0sEHH5xWr16dIl+eHn744RR3h8ZTPc8777zNczxts8026etf/3o2/P2mm25Ky5cvzzfxSoAAAQIECBAgQIAAAQIECBAgQIBAgQQaJgB63333ZewHHnhgSf64wzPS448/vnl9DJmPdNBBB6VBgwZlv+f/xFD4fffdN61duzZFEFQiQIAAAQIECBAgQIAAAQIECBAgQKB4Ag0TAI2h6ldffXXaf//9S/bC4sWLs+UjR47cvP6hhx7Kfs+Do5tX/M8vEQCN9MADD/zPEi8ECBAgQIAAAQIECBAgQIAAAQIECBRJoGEeghRD3SdNmlTSfv369Zvv4tx1110354l5QyM1D4puXtls+bPPPtt88Ra///KXv0wbNmzYYnks2HHHHcs+fb7kBhUs7NOnTzY8v/VdqxVsWsgsXWlnWEWK166UU0i4TlS6b9++rCp0y4+tyO7Yah8tHkznc9i+U+SIz2Ge4v+2TZs25W+9lhBoavrLqYzPYQmcVovic5inOLZyu3xZvb069uutR9SHAAECBAgQIFBcgYYJgLbVBd/5znfSc889l2JuzyOOOGJz1hUrVmS/lwuAjhgxIluf59u8YatfTjvttLRmzZpWS//yNh689O53v7vkuq4ujD9eekMaNWpUl5sZAYVqlNPlihSkAFaVd1QE9XhV7sWqcqvIWe7/p46V0jtyO7Y61s/5OU7Hture3HEBWyJAgAABAgQIECBQDYG/3mZSjdLqsIx4onv8RADs05/+9OY7tTZu3Jg9FCmqPHz48JI1HzZsWLa8XHCz5EYWEiBAgAABAgQIECBAgAABAgQIECBQNwINfQfopZdemq644oos+PnZz3427bHHHpvhIyAaT39ftWpV2bs388DngAEDNm9X6pePfOQjqdxdCtttt13VnyI/ZMiQ1DyAW6pOjbRs+fLlnW5OBLHjDr3wau9O3k7vpIE2jM9EpPhcSG0LDB06NPtuiSGar732WtuZrU1xx3oMv125ciWNdgTic5gPTY5jyzDgtsHi/+j48Tls2ynWxjQB/fv3zzLG/4nxf2M9pzj2i3Cnaj0bqhsBAgQIECBAgMBfBBoyALpu3boUQ89/8YtfZH8UnXXWWdmT3lt3+tixY1PM71kuwJYvj0BHW+kTn/hE2dVLliyp+h9lEUiIgGtv+WOvK+2MvosAqCBV2UO0xYr4wzi8umLeosAGfhNBqnyuRl7td3RYObbad4ocEczLA6BFCFJV1qra5YoLXfHd5XPYvnEcV3kANC5GlLt4235J3ZMjvjMEQLvH2l4IECBAgAABAo0u0HBD4CNoGXNyRvAzTpq/8Y1vlAx+RsdGADRSHujM3jT7Z9myZdk784o1Q/ErAQIECBAgQIAAAQIECBAgQIAAgQIJNFQANAKWn/zkJ9N9992XXve616Vvf/vbaffddy/bHePHj8/WPfnkkyXz5Mt32WWXkustJECAAAECBAgQIECAAAECBAgQIECgvgUaJgAaQ5zPPPPM9MQTT6SpU6dmwc/Jkye3qX/YYYdl6+fPn79FvpgX65ZbbsmW77nnnlust4AAAQIECBAgQIAAAQIECBAgQIAAgfoXaJgA6E9/+tP04IMPZsPav/rVr6atttqqXf39998/bb/99mnBggXppptuapH/yiuvTIsWLUrxEKP99tuvxTpvCBAgQIAAAQIECBAgQIAAAQIECBAohkBDPAQpntYew90jvfLKK+nd7353Wf2dd945XXbZZdn6mFz/hBNOSPGQpPPPPz/9+te/TlOmTMkCqfF7PCjgjDPOyB7cUbZAKwgQIECAAAECBAgQIECAAAECBAgQqFuBhgiAPvXUUy0eZLRhw4ay4K2fePrmN785XXjhhVkA9NZbb03xEynuDD3llFPSHnvsUbYsKwgQIECAAAECBAgQIECAAAECjSQwa9asipszd+7civPKSKAnBRoiADpt2rR0xx13dNpxr732Sj/+8Y+zIe/PPvtsiocjTZw4MfXt2zAzBHTaxoYECBAgQIAAAQIECBAgQIAAAQIEiizQEAHQanXAmDFjUvxIBAgQIECAAAECBAgQIECAAAECBAg0hoBbHBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAgKgJVAsIkCAAAECBAgQIECAAAECBAgQIECgMQQEQBujH7WCAAECBAgQIECAAAECBAgQIECAAIESAk0llllEgAABAgQIECBAgAABAgSqIjBr1qyKypk3b15F+WQiQOCvApV+vubOnfvXjfxGoBcKuAO0F3a6JhMgQIAAAQIECBAgQIAAAQIECBDoLQICoL2lp7WTAAECBAgQIECAAAECBAgQIECAQC8UEADthZ2uyQQIECBAgAABAgQIECBAgAABAgR6i4AAaG/pae0kQIAAAQIECBAgQIAAAQIECBAg0AsFBEB7YadrMgECBAgQIECAAAECBAgQIECAAIHeIiAA2lt6WjsJECBAgAABAgQIECBAgAABAgQI9EIBAdBe2OmaTIAAAQIECBAgQIAAAQIECBAgQKC3CAiA9pae1k4CBAgQIECAAAECBAgQIECAAAECvVBAALQXdromEyBAgAABAgQIECBAgAABAgQIEOgtAgKgvaWntZMAAQIECBAgQIAAAQIECBAgQIBALxQQAO2Fna7JBAgQIECAAAECBAgQIECAAAECBHqLQFNvaWhPtXPAgAFp2LBhVd19v379UlNTU+rfv39Vy63XwsaOHdvpqvXp0yfbtm/fvqkr5XS6AgXbMI6tSKza77jcilf7VpEjPoM+h5VZNT+2Ro8eXdlGvThXHFfxXe97q/2DoPmxNXLkyPY36OEcGzdu7OEa1G73RT9e8/OrIhxHlfRinFcXuU/iezBSkdvQvJ8GDRqU4m+ooqb8u7bI/ZEfU9EHw4cPr/rfs93Zt9GWwYMHp4EDB3bnbkvuq7PHRH5MRaGjRo0qWXYlCzu7//bK7mi5I0aMSJs2bWqv2Lpdn/8fGMdWR9teT43K29Gb/t4QAK3xERgn72vXrq3qXuKkIL4wql1uVStZxcK60s44oY3Um7y6Qh8nBvFF2BXzruy/SNvGiUj+nwav9nsu/pBxbLXvFDniOz5Pjq1covxrXAyME1BW5Y3yNfEdn/9Ru379+lTvAcb4v7se/mDN/ar5WvTjNY6jOMcqwnHUVr/lNxMU/Twx+iL+ny36cZX3VS3+fsrL7o7XRjifjs9GHnSLz/mGDRu6g64m+4h2RP3XrVtXk/I7UmhnP6PN//+OdsR3VmdSZ/ff3r4qLTf+Fohjq+jHVB5jCJdK296eYU+sj89GtKUrx1RP1Dv/v7sz+xYA7YxaB7aJD/fq1as7sEX7WfMvjWXLlrWfuQFydKWdcbUvvmjjP4mulNMAjBU1Ia4ohher9rman4jwat8rrvTGH2es2reKE5H8j47XXnut7oNU7beotjlilEWYObbad4679fKT9ji24hylnlP8f1TtUTT10t6iH69xLhrnWEU4jsr1eRxfQ4cOzVZHcKTIfRLtaKT/YyOgUOT+iO/auEhQ5DbEd28cU5FWrVpV9b9ns4K76Z+4sBzH1PLly7tpj+V309ljIv5Ga/7/d2cD0p3df/kW/WVNpeXG52LIkCFp5cqVac2aNe0VW7fr8xhDXKyptO312Jj4bMRPfDbq/aJ4c7/8/+7myyr93RyglUrJR4AAAQIECBAgQIAAAQIECBAgQIBA4QQEQAvXZSpMgAABAgQIECBAgAABAgQIECBAgEClAgKglUrJR4AAAQIECBAgQIAAAQIECBAgQIBA4QQEQAvXZSpMgAABAgQIECBAgAABAgQIECBAgEClAgKglUrJR4AAAQIECBAgQIAAAQIECBAgQIBA4QQEQAvXZSpMgAABAgQIECBAgAABAgQIECBAgEClAgKglUrJR4AAAQIECBAgQIAAAQIECBAgQIBA4QSaCldjFSZAgAABAgR6rcCsWbMqbvvcuXMrzisjAQIECBAgQIAAAQKNK+AO0MbtWy0jQIAAAQIECBAgQIAAAQIECBAg0OsFBEB7/SEAgAABAgQIECBAgAABAgQIECBAgEDjCgiANm7fahkBAgQIECBAgAABAgQIECBAgACBXi9gDtBefwgAIECAAAECBAgQIECAAAECBEKgI/ONF0msUdtVpD5Q154VcAdoz/rbOwECBAgQIECAAAECBAgQIECAAAECNRQQAK0hrqIJECBAgAABAgQIECBAgAABAgQIEOhZAQHQnvW3dwIECBAgQIAAAQIECBAgQIAAAQIEaiggAFpDXEUTIECAAAECBAgQIECAAAECBAgQINCzAgKgPetv7wQIECBAgAABAgQIECBAgAABAgQI1FBAALSGuIomQIAAAQIECBAgQIAAAQIECBAgQKBnBQRAe9bf3gkQIECAAAECBAgQIECAAAECBAgQqKGAAGgNcRVNgAABAgQIECBAgAABAgQIECBAgEDPCgiA9qy/vRMgQIAAAQIECBAgQIAAAQIECBAgUEMBAdAa4iqaAAECBAgQIECAAAECBAgQIECAAIGeFRAA7Vl/eydAgAABAgQIECBAgAABAgQIECBAoIYCAqA1xFU0AQIECBAgQIAAAQIECBAgQIAAAQI9KyAA2rP+9k6AAAECBAgQIECAAAECBAgQIECAQA0FBEBriKtoAgQIECBAgAABAgQIECBAgAABAgR6VkAAtGf97Z0AAQIECBAgQIAAAQIECBAgQIAAgRoKCIDWEFfRBAgQIECAAAECBAgQIECAAAECBAj0rIAAaM/62zsBAgQIECBAgAABAgQIECBAgAABAjUUEACtIa6iCRAgQIAAAQIECBAgQIAAAQIECBDoWQEB0J71t3cCBAgQIECAAAECBAgQIECAAAECBGooIABaQ1xFEyBAgAABAgQIECBAgAABAgQIECDQswICoD3rb+8ECBAgQIAAAQIECBAgQIAAAQIECNRQQAC0hriKJkCAAAECBAgQIECAAAECBAgQIECgZwUEQHvW394JECBAgAABAgQIECBAgAABAgQIEKihgABoDXEVTYAAAQIECBAgQIAAAQIECBAgQIBAzwoIgPasv70TIECAAAECBAgQIECAAAECBAgQIFBDgaYalt3jRa9cuTKdfvrpaeLEiemss84qWZ/I893vfrfkunzhEUcckXbeeef8rVcCBAgQIECAAAECBAgQIECAAAECBAoi0LAB0E2bNqVzzjknPfjgg6mpqXwzH3/88XTNNde02V177rmnAGibQlYSIECAAAECBAgQIECAAAECBAgQqE+B8pHB+qxvRbVatWpVmjNnTrrrrrvazb9gwYIsz957750OPfTQkvmnTJlScrmFBAgQIECAAAECBAgQIECAAAECBAjUt0DDBUDvueee9OUvfzm9+OKLqW/fvmnjxo1t9kAeAI3g55FHHtlmXisJECBAgAABAgQIECBAgAABAgQIECiWQEM9BOmXv/xlOuWUU7Lg53777ZdOPfXUdnsjhsBHmjp1art5ZSBAgAABAgQIECBAgAABAgQIECBAoFgCDXUH6OLFi9OkSZPSBz7wgfT2t7893XHHHW32xvr169OTTz6ZzRG64447ZnmXLVuWBg4cmP20ubGVBAgQIECAAAECBAgQIECAAAECBAjUvUBDBUAPO+yw9A//8A9tPvSoeY8888wzad26dWnbbbdNV111VfqP//iPtGjRomzofCx7//vfnw4//PDmm5T8/bjjjktr164tue74449Pb3rTm0qu6+zCeKhTv3790pgxYzpbRKG260o7+/Tpk7U1pkPoSjmFAutCZfMHhrFqHzE+g3nilUuUfw2v+DyyKm+Ur8k/h/F+1KhR+WKvnRBwvLVEa/69NXLkyBQPjKzntGHDhnqunroRIECAAAECBAgUSKChAqBjx47tEH0+/+cf//jHdNlll6XYPh6G9PTTT2c/5557bvrd736XzjzzzDbLjTxr1qwpmWfmzJlpwIABJdd1dWHzP2S6WlY9b18Nvwi8VKOcenaqZt1YVa7p2KrcKnI6tnh1TKBruR1v5f369+9ffmWdrImROhIBAgQIECBAgACBagg0VAC0oyD5/J/Dhw9P559/ftpzzz2zIuKOiLgb9Bvf+Ea68cYb0/77758OPvjgjhYvfw8IzJgxo+K9zps3r+K8MhIgQIAAAQIECBAgQIAAAQIECBRToFcHQD/4wQ+mGDa/1VZbZXOH5l0Yd3QdddRR2V2gEQj9t3/7tzYDoLfddlu+6RavMcT+pZde2mJ5VxbEkMi4K2L58uVdKaYw21bbL294rcrNyy/ia3wW4vhfunRpEavfrXWOobUxVDkumCxcuLBb913EnQ0bNiy7+zPmapbaFojv+PzOxTi26n2Yctut6dm1vudb+sd3/KBBg7KFMeVPEe6wnDBhQstGeEeAAAECBAgQIECgEwK9OgAad37usssuZdne8pa3ZHeCPvXUU2njxo3Z3KClMo8ePbrU4mzZkiVL0urVq8uu78qKqFNvSLVqZ63KbYQ+YdOxXuRVuRer9q2aBzzjd2btm5XLwa6lTPNjK2zq3ScuyEkECBAgQIAAAQIEqiHQtxqFNGoZ+V0H8YCjFStWNGoztYsAAQIECBAgQIAAAQIECBAgQIBAwwr06jtAf/zjH2dPfY95I7fffvstOjkfOjdixIgUd4tKBAgQIECAAAECBAgQIECAAAECBAgUS6BX3wE6f/78dOWVV6bvf//7JXvtzjvvzJbvuuuuJddbSIAAAQIECBAgQIAAAQIECBAgQIBAfQv06gDoIYcckvXOLbfckp544okWPXXvvfemuEM00oc//OEW67whQIAAAQIECBAgQIAAAQIECBAgQKAYAr16CPzMmTPTr371q3Tfffel4447Lu29997Zz+OPP55uvfXWrAc/9rGPpalTpxajN9WSAAECBAgQIECAAAECBAgQIECAAIEWAr06ANqvX7/0la98JRsGf9VVV6W46zN+Ik2ePDmddNJJaf/9928B5g0BAgQIECBAgAABAgQIECBAgAABAsURaOgA6Jvf/OZ0xx13tNkbgwYNyoa4f/CDH0wvvPBCWrp0adpxxx3TsGHD2tzOSgIECBAgQIAAAQIECBAgQIAAAQIE6l+goQOgHeFvampK2267bfbTke3kJUCAAAECBAgQKI7AjTfemH7wgx+ks88+O+2yyy5lK/7oo49m88E/88wzaejQoWn33XdPhx56aHahvOxGVhAgQIAAAQIECNSlgABoXXaLShEgQIAAAQIECFRb4MEHH0wXXHBBWr9+fVqzZk3Z4q+55po0Z86cbH2MClq7dm363e9+l/793/89felLX0qvf/3ry25rBQECBAgQIECAQP0J9OqnwNdfd6gRAQIECBAgQIBALQTioZef+cxnsuBnW+VHkPSiiy5KAwYMSF/4whfSz372szRv3rxsbvhVq1al008/Pb344ottFWEdAQIECBAgQIBAnQkIgNZZh6gOAQIECBAgQIBA9QRWrlyZ3fUZD7dcsmRJ6tu37dPf73//+2nTpk3pfe97X4r55Pv06ZP69++fZs6cmY4++ui0bt26dN1111WvgkoiQIAAAQIECBCouUDbZ4A1370dECBAgAABAgQIEKidwPHHH5+uv/76NGTIkHTWWWelHXbYoezOIlh69913Z+unT5++Rb582Q033NDunaRbbGwBAQIECBAgQIBAjwkIgPYYvR0TIECAAAECBAjUWmDp0qUpApeXX355eutb39rm7h555JHs7s/JkyenSZMmbZF32rRpafjw4enVV19Nf/zjH7dYbwEBAgQIECBAgEB9CngIUn32i1oRIECAAAECBAhUQWDu3LlpwoQJFZX0/PPPZ/lGjhxZNn+sW758eXr22WfLPhE+hsnHT6nUr1+/bFh9qXVFXBZTBBQxNa93/N78fRHbE3VuhDbk9o3QlkZoQ35cNUJb6qENna1D8+3i9+bv889MT752pj6d2aYn21hq3/XYF6XqWcmyRuiPStopAFqJkjwECBAgQIAAAQKFFKg0+BmNW7FiRdbGtgKgI0aMyPLkebM3rf65+OKLU/yUSrvttlu69tprS60q3LJx48YVrs6lKhxzvE6cOLHUqkIta4Q2BPjQoUOzn0Lhl6hso/RHW9+HJZpdl4uGDRuW4qenUzWOiXr83u1ou0aPHt3TXVGV/cec4h1te1V2XOVCOnKeVOVdd3txAqDdTm6HBAgQIECg8QVmzZpVcSPjDj2JQD0IxBygkWKYe7mU/xG9evXqclksJ0CAAAECWwjMmDFji2XlFsybN6/cqrpb3qjtqjtoFeqygABolwkVQIAAAQIECBAg0AgCcedZpLVr15Ztzpo1a7J1AwcOLJtn/Pjxaddddy25fqeddio7PL7kBnW4MIbKNTU1Fb4dcednpI0bN6YNGzbUoXRlVYq7kOJn/fr1lW1Q57miL6JPippimotIRT+m8nbEcbVp06aidkf2XRXHU9GOqebTqERfxGc8UvPlRe2URjim4v/B+FwU+Xu3qP+X5/93d+b4FwDtjJptCBAgQIAAAQIEGk5g7NixWZuWLVtWtm0x/2ekPFhaKuMxxxyT4qdc+tOf/lRuVSGWxx8fYRUPmCrqH3/xh18+dDHasGjRokLYl6pkHItx1/Irr7xSanXhlsXd1W19Buu9QTFkPIJVixcvrveqlq1f3Ome3wkf33lFvuM9LkitWrUqm7u5bIPrcEXzz/OoUaPSoEGDslouWbKk0MH1aER8vvOLiXVI326VYsh4/B8SQfXm/dTuhnWWIY6pOLbiu6pIFwi23nrrTkt6Cnyn6WxIgAABAgQIECDQSAJ5ADQPcpZqWx6YiT8aJAIECBAgQIAAgWIICIAWo5/UkgABAgQIECBAoMYCcadQpHjCe6lhhq+++mp2p0Tc3TVlypQa10bxBAgQIECAAAEC1RIQAK2WpHIIECBAgAABAgQKLTBp0qQ0bdq09Nprr6Xf/va3W7Tl1ltvzYYeRp4hQ4Zssd4CAgQIECBAgACB+hQQAK3PflErAgQIECBAgACBHhDI5+6cO3duiznjFi5cmH74wx9mNZo5c2YP1MwuCRAgQIAAAQIEOivgIUidlbMdAQIECBAgQIBAwwkcdNBBaZdddkmPPPJIOv7449MhhxySPehn/vz52YNy3vjGN6ZDDz204dqtQQQIECBAgACBRhYQAG3k3tU2AgQIECBAgACBDgn069cvffOb30wXXnhh+sUvfpGuvPLKbPtYfvTRR6cTTzwxe8JzhwqVmQABAgQIECBAoEcFBEB7lN/OCRAgQIAAAQIEulPg8ssvb3d3AwcOTGeeeWY6/fTT0xNPPJE2bdqUJk+enIYOHdrutjIQIECAAAECBAjUn4AAaP31iRoRIECAAAECBAjUgUBTU1OaOnVqHdREFQgQIECAAAECBLoi4CFIXdGzLQECBAgQIECAAAECBAgQIECAAAECdS0gAFrX3aNyBAgQIECAAAECBAgQIECAAAECBAh0RUAAtCt6tiVAgAABAgQIECBAgAABAgQIECBAoK4FBEDruntUjgABAgQIECBAgAABAgQIECBAgACBrggIgHZFz7YECBAgQIAAAQIECBAgQIAAAQIECNS1gABoXXePyhEgQIAAAQIECBAgQIAAAQIECBAg0BUBAdCu6NmWAAECBAgQIECAAAECBAgQIECppJ2YAABAAElEQVSAAIG6FhAArevuUTkCBAgQIECAAAECBAgQIECAAAECBLoiIADaFT3bEiBAgAABAgQIECBAgAABAgQIECBQ1wICoHXdPSpHgAABAgQIECBAgAABAgQIECBAgEBXBARAu6JnWwIECBAgQIAAAQIECBAgQIAAAQIE6lpAALSuu0flCBAgQIAAAQIECBAgQIAAAQIECBDoioAAaFf0bEuAAAECBAgQIECAAAECBAgQIECAQF0LCIDWdfeoHAECBAgQIECAAAECBAgQIECAAAECXREQAO2Knm0JECBAgAABAgQIECBAgAABAgQIEKhrAQHQuu4elSNAgAABAgQIECBAgAABAgQIECBAoCsCTV3Z2LbtC/Tp0ycNGDCg/YwdyBFl9uvXr+rldqAK3Zq12n555WtVbl5+EV/79v3LNRE27fdefA7zxCuXKP8a31m1+D4sv8firsk/h9GC/v37p02bNhW3MRXWvFafoVqVW2Gz6i5b62Or+fu6q6wKNYzArFmzKm7L3LlzK87bqBkr9WLVqEeAdtVSoNLPVy3roGwCBHpOQAC0xvbxx9eQIUNqspeBAwfWpNx6K3TMmDE1qVKtyq1JZbu5UDaVg0dQj1flXqwqt4qco0eP7tgGBc1dq+OiVuUWlLlFtUeOHNnifT2+Wb9+fT1WS50IECBAgAABAgQKKCAAWuNOW7t2bXrttdequpdRo0alDRs2pGXLllW13HotbOHChTWpWq3KrUllu6nQrbbaKrtLb+nSpd20x+LuJgJTTU1N2d15L7/8cnEb0k01Hz58eHY34+LFi7tpj8XdTQSm8jsX49jqDXeA1ur7uFblFvXoGjFiRBo0aFBW/fgs1nuAMS4wjRs3rqjc6k2AAAECBAgQIFBHAgKgNe6M+MM1gpXVTFHmxo0bq15uNetYzbKq7ZfXrVbl5uUX8TUPtLDpWO/xat8rvrNq8X3Y/p6LlyP/HEbNwy1+Gj3V6jNUq3KL2h/Nj62wqXef5lONFNVcvQkQIECAAAECBOpDoOoPQbr00kvTySefnB5++OGKW3juueemAw44IH3xi1+seBsZCRAgQIAAAQIECBAgQIAAAQIECBAg0J5A1QOg119/fZozZ0566qmn2tv35vW33XZb+vWvf92hoOnmjf1CgAABAgQIECBAgAABAgQIECBAgACBMgI9OgQ+hl4tWLAg3X///Vn1avWwoDJtt5gAAQIECBAgQIAAAQIECBAgQIAAgQYX6FIA9Igjjkg333xzC6J169Zl79/97nenvn3bvsE08jaf22yfffZpUZY3BAgQIECAAAECBAgQIECAAAECBAgQ6IpAlwKgX/va19Iee+yR8qBn84qUWtZ8fevfd9ttt/Sud72r9WLvCRAgQIAAAQIECBAgQIAAAQIECBAg0GmBLgVAp02bli655JL0X//1X5srcNNNN6U//vGP6W1ve1vadtttNy8v9Uv//v3T0KFD0w477JDe8573pFGjRpXKZhkBAgQIECBAgAABAgQIECBAgAABAgQ6JdClAGjs8cMf/nD2k+89hsVHAPTjH/94it8lAgQIECBAgAABAgQIECBAgAABAgQI9JRAlwOgrSv+/ve/Px1wwAFp6tSprVd5T4AAAQIECHSTwKxZsyre09y5cyvOW6SMlRo0avuL1FfqSoAAAQIECBAgQKCWAlUPgL73ve+tZX2VTYAAAQIECBAgQIAAAQIECBAgQIAAgYoFqh4Abb7nhQsXpsceeyytXLkyrV+/vvmqkr//zd/8TZoyZUrJdRYSIECAAAECBAgQIECAAAECBAgQIECgowI1CYBG0POzn/1suu666yoKfOaVnj17djr77LPzt14JECBAgAABAgQIECBAgAABAgQIECDQJYGqB0CXL1+ejjzyyPSHP/yhSxWzMQECBAgQIECAAAECBAgQIECAAAECBLoqUPUA6DnnnLM5+BnD2Y855pi0/fbbp4kTJ6Y+ffq0Wd+dd965zfVWEiBAgAABAgQIECBAgAABAgQIECBAoCMCVQ+A3nnnndn+99prrzR//vw0evTojtRHXgIECBAgQIAAAQIECBAgQIAAAQIECFRNoG/VSvpzQRs2bEj3339/VuSHPvQhwc9q4iqLAAECBAgQIECAAAECBAgQIECAAIEOC1Q1ANqvX780dOjQrBJxB6hEgAABAgQIECBAgAABAgQIECBAgACBnhSoagA0GvJ3f/d3WXuefvrp7NU/BAgQIECAAAECBAgQIECAAAECBAgQ6CmBqgdADz300Kwtl112WU+1yX4JECBAgAABAgQIECBAgAABAgQIECCQCVQ9APrJT34yHXXUUem2225LJ510Ulq+fDlqAgQIECBAgAABAgQIECBAgAABAgQI9IhA1Z8C/9BDD6UTTjgh3X333emb3/xm+tGPfpT23nvvtN1226Vx48a12ci4e/SQQw5pM4+VBAgQIECAAAECBAgQIECAAAECBAgQqFSg6gHQ//t//2/62c9+tnn/L7/8cpo3b97m92390tTUJADaFpB1BAgQIECAAAECBAgQIECAAAECBAh0SKDqQ+A7tHeZCRAgQIAAAQIECBAgQIAAAQIECBAgUEOBqt8BevXVV6f169d3qsqDBg3q1HY2IkCAAAECBAgQIECAAAECBOpTYNasWRVXbO7cuRXn7Ui5FRdaBxkbtV2V0nak/R05Xirdv3yNKVD1AOiwYcMaU0qrCBAgQIAAAQIECBAgQIAAAQIECBAonIAh8IXrMhUmQIAAAQIECBAgQIAAAQIECBAgQKBSgarfAbpgwYK0dOnSSvffIt8222yTJk2a1GKZNwQIECBAgAABAgQIECBAgAABAgQIEOisQNUDoCeffHKLp8B3pGJnn312mj17dkc2kZcAAQIECBAgQIAAAQIECBAgQIAAAQJlBQyBL0tjBQECBAgQIECAAAECBAgQIECAAAECRReo+h2gp556avrHf/zHsi4bNmxIy5YtS0899VT6yU9+kr2+/e1vT9/97nfTiBEjym5nBQECBAgQIECAAAECBAgQIECAAAECBDoqUPUA6GGHHVZxHc4555x01FFHZUPmv/rVr6YLL7yw4m1lJECAAAECBAgQIECAAAECBAgQIECAQHsCPToEPu74/NnPfpY9+Ogb3/hGuuWWW9qrr/UECBAgQIAAAQIECBAgQIAAAQIECBCoWKBHA6BRywEDBqTDDz88q/B//ud/VlxxGQkQIECAAAECBAgQIECAAAECBAgQINCeQI8HQKOCu+22W1bPO+64o736Wk+AAAECBAgQIECAAAECBAgQIECAAIGKBeoiAHrbbbdlFe7fv3/FFZeRAAECBAgQIECAAAECBAgQIECAAAEC7QlU/SFI7e2w9fqYA3T+/PnZ4n322af1au8JECBAgAABAgQINJTA2LFjC92ePn36ZPUfOXJkVdvRUy5NTU2pp/bdWcDm9e3b9y/3tDRf1tly62G7QYMGZdOk1UNdOlOHfv36ZZsVuT/yYyoaMnz48DRs2LDOUHR6myLbdbrRvWjDeBbMpk2bqtbi7j5e8v8D43PS3fuuGtqfC8rbMXr06GoWW9dlVT0A+v/+3/9LTz75ZJuNXr9+fVq5cmW677770g033JDlDfy3ve1tbW5nJQECBAgQIECAAIGiC6xdu7bQTYg/+iJoGOf0GzdurFpbutslH30Wf4h39767ita8vtEX8VyF5su6Wn5Pbh/HVJHbMnDgwCywUOQ2xGcjD+TG53zDhg3dekgU2a5boQq6s2ofU919vMR3bp66e9/5fqvxGp/xaMu6deuqGpCuRt3aKiP/v7utPOXW/bXnyuXo4PLvfe972ZPdO7hZOuOMM9Kb3vSmjm7WZv4Isp5++ulp4sSJ6ayzziqbd82aNemaa65J99xzT1qyZEmaMmVK2nPPPdOMGTM2f/GX3dgKAgQIECBAgAABAh0QWLZsWQdy11/W+ONj8ODB6bXXXsuCoNWqYXe6xM0XQ4cOzaoewZ3u3Hc1vJrXN9oRAdDmy6qxj54qIwIKRW5L3BkdFwmK3Ia44zOOqUirVq1Kq1ev7tbDoch23QpV0J1FnCZiMNVK3X28xP9/8X9IXKzp7n1XyyzKibvt42f58uVVvZhZzTqWKiv/v7vUuvaWVT0A2t4OW6/fa6+90sc+9rF03HHHtV7VpfdxJfecc85JDz74YBbVLlfY0qVLs/0/++yzWZa4/XfevHnZz69+9as0e/bszV/+5cqwnAABAgQIECBAgAABAgQIECBAgACB+hSoegB07ty52VWi9pobV47j6tiQIUPay9rh9XGVas6cOemuu+5qd9tzzz03RfBzv/32S5/73OfSVlttlZ5//vn0mc98Jt1+++3poosuyu4ibbcgGQgQIECAAAECBAgQIECAAAECBAgQqDuBqgdAx48f36ONjGHsX/7yl9OLL76YDT1oa16ihx9+ON19993ZEJ7zzjsvu/03Kr/NNtukr3/96+moo45KN910UzrxxBOzyZ97tGF2ToAAAQIECBAgQIAAAQIECBAgQIBAhwX+8sjADm9Wnxv88pe/TKecckoW/Iw7Ok899dQ2K3rbbbdl6w866KDNwc98gxgKv++++2YTcEcQVCJAgAABAgQIECBAgAABAgQIECBAoHgC3RYAjUnS77///vToo4+mxYsX1+QpU1HupEmT0plnnpm++tWvplGjRrXZIw899FC2PoKlpVIEQCM98MADpVZbRoAAAQIECBAgQIAAAQIECBAgQIBAnQtUfQh88/ZGgDHm0rz33nvTc88913xVGjNmTHr3u9+dPvrRj6a99967xbrOvjnssMPSP/zDP7T50KPmZcdcn5FiLtJSKV+ePyCpVJ5YFkHdeOhSqRRP0Isna1UzxRPH4qepqabdV80qd6msWrWzVuV2qbE9vHFvO7aqxe1Yal8ynoYaiVX7VvE5zFO/fv2y6Vzy97V67el+6e37r1W/ti639bHVer33BAgQIECAAAECBBpVoCYRtPXr12eBzwsvvDCtW7eupN2iRYvSZZddli6//PL0hS98IZ1xxhkl83Vk4dixYzuSPa1YsSLLnwc6W288YsSIbFGer/X6/P173vOetGbNmvxti9cvfelLWaC3xcIqvImHSA0ePLgKJdV/EePGjatJJWtVbk0q282FsqkcPAIKvCr3YlW5VeTs6P9rHSv9r7l7ul96+/7/2hPd91tM9VPvKc4nJQIECBAgQIAAAQLVEKhJADQCml/5yley+kVw4OCDD05Tp05N2223XVq5cmV65pln0u9///tsaHmc3H7qU59KEydOTB/4wAeq0aaKyoiHI61evTrLO3z48JLbxN2bkcoFN0tuZCEBAgQIEOiAwIwZMzqQuzGzNqpBR9o1b968xuxcrSJAgAABAgQIECBQBwJVD4Ded9992R2d0bYDDjggfetb30p77bVXyab+9Kc/Tf/n//yf9NRTT6WPf/zj6cgjjyw7HL1kAV1YGMMx4w7KVatWlQ1w5oHPAQMGtLmn+AOn3J2uEyZMyPbRZgEdXBn1iSH35fbZweLqPnv0US1SrcqtRV27q8z8WF+7dm137bKw+xk4cGA2NDk+i/nFlMI2phsqHnetx/du/r3aDbu0iw4I9Pbvw3pof3fUIT6H+XQD8b1VbvqeDhw6Nc0aF6vz+tZ0RwonQIAAAQIECBBoeIGqB0AvuuiiLDC3ww47pBtvvLHNgOY73/nOtOOOO2ZPW4+HJF155ZVZILS71GNoYczvuXz58pK7zJcPHTq05Pp8YX63a/6++euSJUvS0qVLmy/q8u8xf2rcOfvqq692uawiFFBtv7zNtSo3L7+Ir/HgsLhrm037vRdDdvN5LXm17xVTikSAnVX7Vj2Ro7f3Sz20vzvqEFP+5AHFOMep9yHm8f9Re+dgPfF5sU8CBAgQIECAAIHiCVT9KfD5E9Nnz57dZvAzp9p1113Thz/84eztrbfemi/ultd8brU80Nl6p8uWLcsWtfc0+dbbeU+AAAECBAgQIECAAAECBAgQIECAQH0IVPUO0A0bNqSHH344a9m+++5bcQvzvDE3aHem8ePHZ7t78skn0/7777/FrmN5pF122WWLdRYQIECAAAECBAgQIECgPYFZs2a1l8V6AgQIECBAoMYCVb0DNIaD5kOr2ntyevN2xYORIm211VbNF9f898MOOyzbx/z587fYV8w7dcstt2TL99xzzy3WW0CAAAECBAgQIECAAAECBAgQIECAQP0LVDUAGnM1TZs2LWv1nXfeWXHr77jjjizv7rvvXvE21cgYd31uv/32acGCBemmm25qUWTMR7po0aLsyfX77bdfi3XeECBAgAABAgQIECBAgAABAgQIECBQDIGqBkCjyXmw8Oyzz075EPK2KH7+859nDz+KPOWeFt/W9l1ZFwHbE044IfXr1y+df/756ayzzkpXXHFFOuOMM9Kll16a4mmp8XvkkwgQIECAAAECBAgQIECAAAECBAgQKJ5A1QOgn/nMZ9KwYcOyJ5QfdNBB6V//9V9TzA3aOsWDh84555x09NFHp02bNqW4+/O9731v62w1f//mN785XXjhhWnixIkpHsIUgc9f//rX2Z2hF1xwQdpjjz1qXgc7IECAAAECBAgQIECAAAECBAgQIECgNgJVfQhSVHHrrbdOX/ziF9MnP/nJ9Nxzz2VPeD/99NPTjjvumAUV165dm55++un0xBNPpHzuz7jT8vvf/34aMGBAVVsZwc18eH1bBcedpz/+8Y+zIe/PPvtsiocjRUA05jSVCBAgQIAAAQIECBAgQIAAAQIECBAorkDVA6BB8YlPfCJNnTo1fehDH8qCoEuWLEn33ntv9tOaKh4w9K1vfavbh7+3rke8HzNmTPZTap1lBAgQIECAAAECBAgQIECAAAECBAgUT6AmAdBgeOtb35r++7//O11yySXZ6yOPPJIeffTRbF7NKVOmpPg59NBD06xZs7I5OItHp8YECBAgQIAAAQIECBAgQIAAAQIECNS7QM0CoNHwrbbaKp188slp0KBBmUPM9Zk/UOi3v/1tNu9nPIBIIkCAAAECBAgQIECAAAECBAgQIECAQC0EajbJZcy9+c53vjO9/vWv31zvPPgZC973vvelsWPHpmOPPTYtXrx4cx6/ECBAgAABAgQIECBAgAABAgQIECBAoFoCNQmAxpPfDzvssHTDDTekP/zhDykefNQ8bdy4MT3zzDNp1apV6aqrrkp77713euihh5pn8TsBAgQIECBAgAABAgQIECBAgAABAgS6LFD1AOiCBQvSiSeemNatW5dVbvr06VsEQGPFf/zHf6SPfOQj2ZPW46nwH/zgB1MERiUCBAgQIECAAAECBAgQIECAAAECBAhUS6DqAdDzzjsvrV+/Pk2YMCHdfPPN6cYbb0zDhg1rUd++ffumI444In3nO99J8+fPT01NTdkT4q+88soW+bwhQIAAAQIECBAgQIAAAQIECBAgQIBAVwSqHgD91a9+ldUnnu4eT3lvLx1yyCHp+OOPz7L953/+Z3vZrSdAgAABAgQIECBAgAABAgQIECBAgEDFAlUNgG7YsCHFcPZI733ve7PXSv458MADs2yPPPJIJdnlIUCAAAECBAgQIECAAAECBAgQIECAQEUCTRXlqjBTPOU9hrdHimHwlabVq1dnWQcNGlTpJvLVqUDc+dubU0faP3fu3N5Mpe0ECNSRQKXfXb63UqrUqo66V1UIECBAgAABAgQI9HqBqt4BGsHPbbfdNkO9/fbbK8a96667srx77LFHxdvISIAAAQIECBAgQIAAAQIECBAgQIAAgfYEqhoAjZ39/d//fbbP2bNnpz/84Q/t7T97CNLll1+e5dt7773bzS8DAQIECBAgQIAAAQIECBAgQIAAAQIEKhWoegD0ox/9aIqh7MuXL0/7779/iqfCL1y4sEV9Nm3alM0VevLJJ6cjjzwybdy4Me2zzz4dmje0RYHeECBAgAABAgQIECBAgAABAgQIECBAoIRA1QOgO++8c7r44ouzXS1ZsiR97nOfSxMmTEjDhg1Lu+yyS9ppp53S4MGD0w477JDmzJmTVq1alb2/4oorUlNTVackLdFciwgQIECAAAECBAgQIECAAAECBAgQ6E0CVQ+ABl48IOC6665L22yzzWbLFStWpEcffTQ9+eSTac2aNZuXv+Md70i///3v07Rp0zYv8wsBAgQIECBAgAABAgQIECBAgAABAgSqIVCzWy5jLtDp06dnc3zeeOONWeDzpZdeSkOGDElxl2j8HHjggemQQw6pRjuUQYAAAQIECBAgQIAAAQIECBAgQIAAgS0EahYAjT3FXKBxh2f8SAQIECBAgAABAgQIECBAgAABAgQIEOhugZoMge/uRtgfAQIECBAgQIAAAQIECBAgQIAAAQIESgkIgJZSsYwAAQIECBAgQIAAAQIECBAgQIAAgYYQEABtiG7UCAIECBAgQIAAAQIECBAgQIAAAQIESgnUdA7QUju0jAABAgQIECBAgAABAvUmMGvWrIqrNHfu3Irz1iJjkepai/Yrs7EFOnJ8N7ZE47VuxowZVW9UR46Xjnx316rcqgMosGIBd4BWTCUjAQIECBAgQIAAAQIECBAgQIAAAQJFExAALVqPqS8BAgQIECBAgAABAgQIECBAgAABAhULCIBWTCUjAQIECBAgQIAAAQIECBAgQIAAAQJFExAALVqPqS8BAgQIECBAgAABAgQIECBAgAABAhULCIBWTCUjAQIECBAgQIAAAQIECBAgQIAAAQJFExAALVqPqS8BAgQIECBAgAABAgQIECBAgAABAhULCIBWTCUjAQIECBAgQIAAAQIECBAgQIAAAQJFE2gqWoXVt/sFZs2a1f07tUcCBAjUoUCl34dz586tw9qrEgECBAgQIECAAAECBHqngDtAe2e/azUBAgQIECBAgAABAgQIECBAgACBXiEgANorulkjCRAgQIAAAQIECBAgQIAAAQIECPROAQHQ3tnvWk2AAAECBAgQIECAAAECBAgQIECgVwgIgPaKbtZIAgQIECBAgAABAgQIECBAgAABAr1TQAC0d/a7VhMgQIAAAQIECBAgQIAAAQIECBDoFQICoL2imzWSAAECBAgQIECAAAECBAgQIECAQO8UEADtnf2u1QQIECBAgAABAgQIECBAgAABAgR6hUBTr2hlDzayf//+afDgwVWtQVNTU+rXr18aNWpUVcut18Jq1c5alVupY0/vv1Q943iNVI91K1XfnlzWt+9frx/xar8n4nsrzHqLVaO2U7vaP9Y7m6M7bPPv+KjjiBEj0qZNmzpb3W7ZbuPGjd2yHzshQIAAAQIECBBofAEB0G7o4z59+tRkL7UqtyaV7UKhtWpnrcqttKk9vf9y9Yx61WvdytW5p5fzar8HcqP8tf0tip2jUdupXbU7Lrvbtrv31xm5ItSxM+2yDQECBAgQIECAQPcLCIDW2HzdunVp+fLlVd3LmDFj0vr169Orr75a1XLrtbDFixfXpGq1KrfSyvb0/kvVM+5Aij8467Fuperbk8vGjRuX3dEYdeDVfk/E3WYDBgzoNVaNekxoV/vHemdzdIftyJEjN49KiXOIOJeo5xT/H1V7FE2l7b311lvTAw88UDb72LFj07HHHlt2vRUECBAgQIAAAQL1JSAAWl/9oTYECBAgQIAAAQI9LHD99dene++9t2wtdtxxRwHQsjpWECBAgAABAgTqT0AAtP76RI0IECBAgAABAgR6UGDBggXZ3k866aQ0cODALWoyfPjwLZZZQIAAAQIECBAgUL8CAqD12zdqRoAAAQIECBAg0M0CCxcuTMuWLUsx5dDMmTO7ee92R4AAAQIECBAgUAuBvz7GuBalK5MAAQIECBAgQIBAgQTyuz+nTp1aoFqrKgECBAgQIECAQFsCAqBt6VhHgAABAgQIECDQqwRaB0DjYVHd8ZCqXoWssQQIECBAgACBbhYwBL6bwe2OAAECBAgQIECgfgXyAGgEPk855ZR03333pQ0bNqSY9/MNb3hDinlBY3h8W2nt2rVp3bp1JbP069cvxRPuGyVVsy3VLKs93+b7it+bv29v21jf0fyVlFmrPEWqa25QxDrndc9fG6EN0ZZoR6O0Je8br71XoFbHcq3K7Y6e6k2fcQHQ7jii7IMAAQIECBAgQKAQAo8//nhWzyuuuCJFsHLatGkpgqFPPvlkuuWWW9I999yT5syZk3beeeey7bnkkkvSxRdfXHL9brvtlq699tqS64q2cNy4cVWt8sSJE6taXqWF9e/fP3V03x3NX2ldapGvSHWN9g8dOjT7qYVFd5ZZNPdyNiNHjiy3ynIChROo1eeyVuV2B/D48eO7Yzd1sQ8B0LroBpUgQIAAAQL1LzBr1qz6r2Qnatio7eoERa/fZMWKFemFF17IHKZPn55OO+20NHjw4Ox9LP/85z+fHn744XT++eenSy+9NDU1OZXuqYNmxowZPbXrbL89vf8ebbydE/gfAZ8DhwIBAkUScNZWpN5SVwIECBAgQIAAgZoJRLDzqquuSq+88krac889Wwz7nDRpUjrnnHPSsccem2KY/N13350OOOCAknWJuyl23XXXkut22mmnssPjS25QhwtjuFwEf8sN8+9slatdXmfr0WjbFc01ppzYuHFjYbsh7hyPFO0oaurbt292B3zUP+6A37RpU1Gbot4EWgjU6vuwVuW2qHyV39Tq//IqV3OL4mLURmeTAGhn5WxHgAABAgQIECDQUALxR//kyZOzn1INmzBhQtp9992zYfAxJL5cAPSYY45J8VMu/elPfyq3qhDL44+PsWPHpqVLl2bBkWpVOgLPUvUFiua6evXqtGzZsupDdFOJMWQ8vkuK/PC0YcOGZfMeB9ny5ctT9IlEoBEEavV9WKtya2k+aNCgNGrUqOy7qkgXnbbeeutOs3gKfKfpbEiAAAECBAgQINDbBPK5shYtWtTbmq69BAgQIECAAIHCCrgDtLBdp+IECBAgQIAAAQLVFHjsscfSb37zmzRkyJA0c+bMkkUvXLgwW/66172u5HoLCRAgQIAAAQIE6k9AALT++kSNCBAgQIAAAQIEekBgyZIl6bLLLsvm/tx3333Tdttt16IWMaT1oYceypaVm+OzxQbeECBAgAABAgQI1IWAIfB10Q0qQYAAAQIECBAg0NMC8eCjmL8vHvhx+eWXt5jfMubA+/KXv5xWrVqV3vjGN6Zp06b1dHXtnwABAgQIECBAoEIBd4BWCCUbAQIECBAgQIBAYwvEAwFmz56dTj311DR//vx07733psMPPzx7GvLtt9+ennvuubTDDjukU045pbEhtI4AAQIECBAg0GACAqAN1qGaQ4AAAQIECBAg0HmBffbZJ11yySVpzpw56ZFHHklXX311VtjgwYPT9OnTs+BozBEqESBAgAABAgQIFEdAALQ4faWmBAgQIECAAAEC3SAQ83teeuml6dVXX03PPvtsGj58eJo8eXLq29fsUd3AbxcECBAgQIAAgaoLCIBWnVSBBAgQIECAAIH/396dwMlV1IkDr5AJOUlMiOHQQAAjYDjCHeW+hJUFvKKLohARdQFxVRZR+cO6HB/EBQ90WReWiAIegLIqdwQEFLlvuW8QcIGEQIAckD+/ct/sZNIz0z3TPdOv51ufz8x0v1evXr1vve5+8+t6VQRaQWDcuHEpfiQCBAgQIECAAIFyC/gau9ztp/YECBAgQIAAAQIECBAgQIAAAQIECHQjIADaDY5VBAgQIECAAAECBAgQIECAAAECBAiUW0AAtNztp/YECBAgQIAAAQIECBAgQIAAAQIECHQjIADaDY5VBAgQIECAAAECBAgQIECAAAECBAiUW0AAtNztp/YECBAgQIAAAQIECBAgQIAAAQIECHQjIADaDY5VBAgQIECAAAECBAgQIECAAAECBAiUW0AAtNztp/YECBAgQIAAAQIECBAgQIAAAQIECHQjIADaDY5VBAgQIECAAAECBAgQIECAAAECBAiUW6Ct3NVXewK9F5g1a1bVG8+ePbvqvDISIFCbQLWvRa/D2lzlJkCAAAECBAgQIECAAIG/CegB6kwgQIAAAQIECBAgQIAAAQIECBAgQKBlBQRAW7ZpHRgBAgQIECBAgAABAgQIECBAgAABAgKgzgECBAgQIECAAAECBAgQIECAAAECBFpWQAC0ZZvWgREgQIAAAQIECBAgQIAAAQIECBAgIADqHCBAgAABAgQIECBAgAABAgQIECBAoGUFBEBbtmkdGAECBAgQIECAAAECBAgQIECAAAECAqDOAQIECBAgQIAAAQIECBAgQIAAAQIEWlagrWWPzIERIECAAAECBAgQIEBgkAvMmjWraoHZs2dXnbeWcqsutIaMtey/UcdVS7k1HNqAZ505c+aA10EFCBAgUG8BPUDrLao8AgQIECBAgAABAgQIECBAgAABAgSaRkAAtGmaQkUIECBAgAABAgQIECBAgAABAgQIEKi3wKC/Bf6VV15Jp512Wreue+yxR3rHO97RbR4rCRAgQIAAAQIECBAgQIAAAQIECBBoPoFBHwB98MEH03nnnddty0yfPl0AtFshKwkQIECAAAECBAgQIECAAAECBAg0p8CgD4A+8MADuWU222yztNNO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IECAAAECBAgQIECAAAECBJpKQAC0qZpDZQgQIECAAAECBAgQIECAAAECBAgQqKeAAGg9NZVFgAABAgQIECBAgAABAgQIECBAgEBTCQiANlVzqAwBAgQIECBAgAABAgQIECBAgAABAvUUEACtp6ayCBAgQIAAAQIECBAgQIAAAQIECBBoKgEB0KZqDpUhQIAAAQIECBAgQIAAAQIECBAgQKCeAgKg9dRUFgECBAgQIECAAAECBAgQIECAAAECTSXQ1lS1UZk+CcyaNatP29t48AlUe87Mnj17wHGqrWujKlqLQS11raXcao+tlv1XW6Z8BAgQIECAAAECBAgQIECgrAJ6gJa15dSbAAECBAgQIECAAAECBAgQIECAAIEeBQRAeySSgQABAgQIECBAgAABAgQIECBAgACBsgoIgJa15dSbAAECBAgQIECAAAECBAgQIECAAIEeBQRAeySSgQABAgQIECBAgAABAgQIECBAgACBsgoIgJa15dSbAAECBAgQIECAAAECBAgQIECAAIEeBQRAeySSgQABAgQIECBAgAABAgQIECBAgACBsgoIgJa15dSbAAECBAgQIECAAAECBAgQIECAAIEeBQRAeySSgQABAgQIECBAgAABAgQIECBAgACBsgoIgJa15dSbAAECBAgQIECAAAECBAgQIECAAIEeBdp6zDEIMixcuDCdd9556aabbkpz585NU6dOTdOnT0+77757Gjp06CAQcIgECBAgQIAAAQIdBe6999507rnnpsceeyyNHj06bbjhhmmnnXZKa6+9dsdsHhMgQIAAAQIECJRAYNAHQOfNm5cOOuig9MQTT+TmmjBhQrrkkkvyzx//+Md09NFHpxVXXLEETamKBAgQIECAAAEC9RCIL8a/+93v5qLGjBmTFi1alG655Zb0i1/8Ip1wwglp0003rcdulEGAAAECBAgQINBPAoP+FvhjjjkmBz+32mqr9Nvf/jb993//d/rZz36W1llnnXT11Ven733ve/3UFHZDgAABAgQIECAw0AJ33nlnvv6LL8CPO+64dNFFF+Uvxg899ND06quvpsMOOyw988wzA11N+ydAgAABAgQIEKhBYFAHQP/85z+nG264IY0cOTIde+yxady4cZnubW97Wzr55JPz7e8XX3xxeumll2oglZUAAQIECBAgQKCsAmeeeWZaunRp2nff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GQkQIECAAAECBJpHQAC0Q1usvPLKKX4kAgQIECBAgAABAm1tbWndddcFQYAAAQIECBAgUHKBQT0JUsnbTvUJECBAgAABAgQIECBAgAABAgQIEOhBQAC0ByCrCRAgQIAAAQIECBAgQIAAAQIECBAor4AAaHnbTs0JECBAgAABAgQIECBAgAABAgQIEOhBQAC0ByCrCRAgQIAAAQIECBAgQIAAAQIECBAor4AAaHnbTs0JECBAgAABAgQIECBAgAABAgQIEOhBQAC0ByCrCRAgQIAAAQIECBAgQIAAAQIECBAor4AAaHnbTs0JECBAgAABAgQIECBAgAABAgQIEOhBQAC0ByCrCRAgQIAAAQIECBAgQIAAAQIECBAor4AAaHnbTs0JECBAgAABAgQIECBAgAABAgQIEOhBYMjSN1MPeawmUFqBrbbaKi1YsCBNmjQpXXHFFaU9DhVvPoE99tgjPfbYY7lid911V/NVUI1KK7D//vunm266Kdf/6quvThMmTCjtsah4cwl8+ctfTpdeemmu1Pnnn5/WXXfd5qqg2hDoR4FXXnklbbnllnmP06ZNSz//+c/7ce921VnguuuuSwceeGBe/LGPfSx97Wtf65zF834U+OEPf5hOOeWUvMdvfvObKa57pYETOOigg1JcE0a6+OKL0+TJkweuMvactt566/Tiiy+m8ePHp2uuuYZIiQTaSlRXVSVQs8DixYtT8VPzxjYg0I2A86obHKv6JNDx3PIdZZ8obdxJ4PXXX8+fibHYudUJKFO83wAAIyJJREFUx9NBJxCvgXi/jbRkyZJBd/zNdsDao7lapOPnRTyWBlbAteHA+nfee9EexWdI5/WeN6+AW+Cbt23UjAABAgQIECBAgAABAgQIECBAgACBPgoIgPYR0OYECBAgQIAAAQIECBAgQIAAAQIECDSvgABo87aNmhEgQIAAAQIECBAgQIAAAQIECBAg0EcBAdA+AtqcAAECBAgQIECAAAECBAgQIECAAIHmFRAAbd62UTMCBAgQIECAAAECBAgQIECAAAECBPooMOTNGfeW9rEMmxNoWoE5c+bkmT1HjBiRdthhh6atp4qVT+Caa65JCxYsSEOGDEm77bZb+Q5AjZtW4IYbbkgvvPBCrt9OO+2UVlxxxaatq4qVS+D2229PTz/9dK701ltvnVZaaaVyHYDaEqijQMxsffnll+cSx40bl9797nfXsXRF1Srw/PPPpxtvvDFvtuaaa6b111+/1iLkr6PAQw89lB544IFc4sYbb5xWW221OpauqFoFbr755vQ///M/ebPtttsujRo1qtYi5K+jwO9+97sUM8DHNXpcq0vlERAALU9bqSkBAgQIECBAgAABAgQIECBAgAABAjUKuAW+RjDZCRAgQIAAAQIECBAgQIAAAQIECBAoj4AAaHnaSk0JECBAgAABAgQIECBAgAABAgQIEKhRQAC0RjDZCRAgQIAAAQIECBAgQIAAAQIECBAoj4AAaHnaSk0JECBAgAABAgQIECBAgAABAgQIEKhRoK3G/LITKIXAlVdemWKW7ieffDK98cYbaY011size+66666lqL9KNq/Ac889l84555w8M+arr76apk2bljbZZJO0ww47NG+l1ayUArfeemv6wQ9+kLbaaqt04IEHlvIYVHrgBV555ZV02mmndVuRPfbYI73jHe/oNo+VBMok0NvzfuHChem8885LN910U5o7d26aOnVqmj59etp9993T0KFDy0TQlHX9wx/+kK6//vp03333pSFDhqS11147/cM//EO+Tq9UYe1RSaX3y+6666502WWXVVXAe97znjRjxoxl8t57773p3HPPTY899lgaPXp02nDDDfMM2NGOUt8E4j3nkksuSY8++mh+r5kyZUp6//vfn9Zff/0uC9YeXdL0acULL7yQfvGLX6T7778/Pf/88+ltb3tbihjC9ttvn1ZYoXL/Qe9VfSLv143NAt+v3HbWaIF48/nnf/7nFIGDSGPHjs1/58+fn//GReyJJ56YRo4cmZ/7RaAWgbhoP/LII9Nrr72WN1tppZXSSy+9lB+/733vS4cffrh/kGoBlbdLgTiv9t9///TXv/417bLLLunoo4/uMq8VBLoTuOOOO9LBBx/cXZZ07LHH5gv7bjNZSaBEAr057+fNm5cOOuig9MQTT+QjnTBhQop/hCNtt912+X14xRVXzM/9qk1g8eLF6ZRTTkm/+tWv8objxo3L11Jx3R6B5bi2is+6jkl7dNSoz+Pf/va36Zvf/GZVhX36059O++23X3ve+GLgu9/9bn4+ZsyYtGjRovwT/1OdcMIJadNNN23P60FtAt/5znfS+eefnzcaPnx4Wrp0abaNLwkOOOCAZdqhKFl7FBL1/funP/0pXxO9+OKLueCJEyem6PwSqavrce9Vmac0v/QALU1TqWg1AtFbKoKf8a1ZXEytu+66ebP4huxf//Vf02233ZYvwCJQJRGoRSACUd/4xjfyBfuHP/zhNHPmzLTKKqukG2+8MffSu+iii1IERA855JBaipWXQEWBk046KQc/K660kEANAg888EDOvdlmm+WeOpU2jV5uEoFWEujNeX/MMcfk4Gf0uv9//+//pQjSPfXUU+nrX/96uvrqq9P3vve9dNhhh7USU78dyxlnnJGDn29961tzIDl6DkaQ56yzzkqnn356DsrFsriuKpL2KCTq93ejjTbKHUW6KjG+OLj00kvTqFGjlrmz6c4778znf3wBEF/IbrvttmnJkiXpggsuaH9dxN1Rq666aldFW96FQNy1GMHPsP3CF76Qdt5553z34sUXX5y+//3v59dH3G22+eabt5egPdop6vogvvCK//VefvnlfP5/+ctfTm95y1tSBEO/9a1vpTlz5qR11lkn7bvvvsvs13vVMhxN/6RyH96mr7YKElheIG53+vWvf527pkewswh+Rs711lsvHXfccXmj+PYz8koEahGI21KiV17cBvH5z38+rb766rnXQtwe9MlPfjIXddVVV9VSpLwEKgrE7Wm/+93v8kVXxQwWEqhBoAgE7bTTTmmvvfaq+BPvZxKBVhKo9bz/85//nG644YZ8h1D0iI7gZ6T4zD/55JPz530EJIq7PlrJqtHHsmDBghz8jFtH/+Vf/iVtvPHG+Vo9en5GD8P4AiburPn973/fXhXt0U5R1wcxJFhXnwNbb711/lI/dhhfAKy55prt+z7zzDNzwDoCP9EbOnomDhs2LHcGiE4B0cM3gqFS7QKXX3553ih6F0bbxNAC0aHiIx/5SPsQBPE/SMekPTpq1O9xfFETwc8YdiBiCRH8jBSfB/HeFa+f//zP/0zxRUGRvFcVEuX5KwBanrZS0x4E4tuw119/PU2ePDmttdZay+WOZfHNc3zj/PDDDy+33gIC3QnExciWW26Zg52dx3+Jb8IjPfvss3nMsO7KsY5AdwLPPPNM/mc7/uneZ599ustqHYGqBB588MGcr+OXglVtKBOBEgvUet4XX2DGGG8jRoxY5sjjVvj4/I9bfiMIKtUmEIGxCIJGoCx6IHZOX/rSl1L0tIpebkXSHoVE//2NXmzRA+4DH/hA2mab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QIAAAQIECBDoVwEB0H7ltjMCBAgQIECAAAECBAgQIECAAAECBPpTQAC0P7XtiwABAgQIECBAgAABAgQIECBAgACBfhUQAO1XbjsjQIAAAQIECBAgQIAAAQIECBAgQKA/BQRA+1PbvggQIECAAAECBAgQIECAAAECBAgQ6FcBAdB+5bYzAgQIECBAgAABAgQIECBAgAABAgT6U0AAtD+17YsAAQIECBAgQIAAAQIECBAgQIAAgX4VEADtV247I0CAAAECBAgQaBaBWbNmpSFDhqSVVlqpWaqkHgQIECBAgAABAg0QEABtAKoiCRAgQIAAAQIEyiOwdOnS8lRWTQkQIECAAAECBGoWEACtmcwGBAgQIECAAAECBAgQIECAAAECBAiURUAAtCwtpZ4ECBAgQIAAAQIECBAgQIAAAQIECNQsIABaM5kNCBAgQIAAAQIECBAgQIAAAQIECBAoi0BbWSqqngQIECBAgAABAq0jsGTJknTLLbfkA5o4cWJae+21uz24O+64I7322mtpzJgx6V3vetdyeZ966ql077335p9nnnkmTZkyJU2dOjXnjfJrSYsWLUq33XZb3mSNNdZIq666asXNn3/++fTQQw/lddOmTUujR4+umC/GGH3ggQfS7bffnu6+++60+uqrp+nTp6cNN9wwjRw5suI2FhIgQIAAAQIECNRPQAC0fpZKIkCAAAECBAgQqFKgra0t7bvvvjkwuO666+bAZVebPv3002nTTTdNr7/+evrSl76UTjrppPasjz/+ePrUpz6Vfve737Uv6/hgxIgR6eijj06HHXZYin1Wk2J/W221Vc76rW99K29babsLL7ww7bfffnnVDTfckLbYYovlsj344IP5OK+//vrl1k2aNCn913/9V/r7v//75dZZQIAAAQIECBAgUD8Bt8DXz1JJBAgQIECAAAECNQjsv//+Ofd9992Xbrzxxi63POecc3LwMzLMmjWrPd/ll1+eNthggxz8XGGFFdK2226bPvnJT6aPf/zj7cHI6DX61a9+NQdB2zfspwe//OUvc0/PCH4OGTIkbbnllrn+u+yySxo7dmz661//mvbcc8/0la98pZ9qZDcECBAgQIAAgcEpIAA6ONvdURMgQIAAAQIEBlwgek9G4DLS2Wef3WV9fvKTn+R1m2++eQ54Fhm//vWvp5deeimtvPLK+Zb1q6++Op155pnprLPOStEj8w9/+EMONEb+U089Nb3yyivFpg3/O3fu3PSZz3wmLViwIE2ePDldeeWVKQKhZ5xxRorA7cMPP5x23XXXXI8TTzwx17XhlbIDAgQIECBAgMAgFRAAHaQN77AJECBAgAABAgMt8La3vS29973vzdX42c9+1t7Ls2O97rzzzjx2Zizr2Pvzuuuua+81evzxx+fxNDtuF4/f8573pIMPPjgvjoDk/fff3zlLw54fddRRKcYIjQBvHNv222+/zL4iaHvRRReluP0/0qGHHpreeOONZfJ4QoAAAQIECBAgUB8BAdD6OCqFAAECBAgQIECgFwIxfmekZ599NveM7FxE0ftz+PDhaZ999mlf/c53vjPNmTMn/fCHP1xmeXuG/31QBBjj6csvv9x5dUOex1ilp512Wi777/7u73IgttKOYkzSCHxGigmh7rrrrkrZLCNAgAABAgQIEOijQHUjwfdxJzYnQIAAAQIECBAgUElgr732ShMmTEgvvPBCvnV99913b88WPSKLW+P33nvvNH78+PZ10YNy5513zj/tC//3QQQgH3300RS9RH/605+2r46Z5/sjxcRMCxcuzLvaeOONU/Q+7SpFILdIMVP8RhttVDz1lwABAgQIECBAoE4CAqB1glQMAQIECBAgQIBA7QLRs/NjH/tY+v73v58uuOCCPGbm6NGjc0Exs/tf/vKX/Ljj7e+d9xLja1511VXp7rvvTvfcc0+KmdcXLVrUOVu/Pe94q33cnh8/1aQIgEoECBAgQIAAAQL1FxAArb+pEgkQIECAAAECBGoQiNvgIwAaEwZFEDRmcY9U3P4eY4UWEwZ1LPaOO+5IMZP8rbfe2nFxfhxB1O222y6NGzcuj8G5XIYGLnjyySd7VfoTTzzRq+1sRIAAAQIECBAg0L2AAGj3PtYSIECAAAECBAg0WGCTTTZJcav47bffnm+DjwBoBEN/+ctf5j1/8pOfTEOHDl2mFnGLe9wu//TTT+flW2+9db4dPm4hj5911lknT0AUs8LHJES9Td1NTPTqq69WLPbtb397+/If//jH6f3vf3/78+4erLjiit2tto4AAQIECBAgQKCXAgKgvYSzGQECBAgQIECAQP0E4hb3f/qnf8oTG8WYmZdcckkOgsYeopdn5/Ttb3+7Pfh50kknpS996Uuds+TnMbZokWJs0GpSzNxepMWLFxcPl/sbs7xXSlOnTm1ffN9996WVVlqp/bkHBAgQIECAAAEC/S/wf1d3/b9veyRAgAABAgQIECCQBaLXZ/SAjImKfvOb36Rzzz03L4+enR0nCiq4YszPSDEZUgROu0p/+tOf2ldVOwnSyJEj27d57rnn2h93fnDDDTd0XpSfT5kyJY0YMSI/vvDCC1N3vUjjOKP3a0zydO2111Ysz0ICBAgQIECAAIG+CQiA9s3P1gQIECBAgAABAnUQmDhxYtpzzz1zSTH258UXX5wfdzX5UTHJ0UsvvZSeffbZijU466yz2gOpkaG73pwdC4ig6pgxY/KiuH1+3rx5HVfnx+eff34O1C634s0F0YP0C1/4Ql512223pVNPPbVStvTyyy+no446KsVYppdddllab731KuazkAABAgQIECBAoG8CAqB987M1AQIECBAgQIBAnQRiMqRIc+bMSa+99loaNWpU+shHPlKx9K222iovj0Do1772tfTMM8+054temxF0jFvnly5d2r48bq2vJg0ZMiTPTB95o9z99tsv3Xzzzbmsxx57LP3gBz9I++67bxo2bFiXxR155JEpJm+KFMHQr3/96+239C9cuDAHeN/3vvele++9N+c56KCDUgSBJQIECBAgQIAAgfoLCIDW31SJBAgQIECAAAECvRDYbbfd0mqrrda+5Yc+9KEux8889thj04QJE3LeH/3oR2n11VdPW265Zdpggw3SpEmTUhFQPP3001Nb29+Gvb/rrrvay+7pQdxWHz1BI/36179Om2++eZ5RPm5vP+SQQ9LYsWPbJ2mqVFb0II3eo5MnT04x9ujxxx+ft4lenhHojODnNddckzf94Ac/mE488cRKxVhGgAABAgQIECBQBwEB0DogKoIAAQIECBAgQKDvAjHTe8z4XqSubn+P9THT+u9///u0yy675OzR0/PGG29Md999dw6afu5zn8u9Kw844IA0Y8aMnCcCkh17hOaFXfxaf/31U9y+vuuuu7YHUON2+xindNttt83jdW666aZdbP23xdtss02KoOuBBx6Yg58xFmhMihS3vkdaa6210mmnnZZ+/vOfLzfL/d9K8JsAAQIECBAgQKAeAkPevAj8v/uC6lGiMggQIECAAAECBAj0o8DTTz+dHnrooTR//vw0bdq0tMYaa6S4jb1e6dVXX83B0JhEaYsttmif4KjW8p944okcoI0JktZee+0cxO0443yt5clPgAABAgQIECBQnYAAaHVOchEgQIAAAQIECBAgQIAAAQIECBAgUEIBt8CXsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIKCICWsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIKCICWsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIKCICWsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIKCICWsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIKCICWsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIKCICWsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIKCICWsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIKCICWsNFUmQABAgQIECBAgAABAgQIECBAgACB6gQEQKtzkosAAQIECBAgQIAAAQIECBAgQIAAgRIK/H/ODVEN6MTF8QAAAABJRU5ErkJggg==" width="672" /></p>
<p>What is the shape of these distributions?</p>
<p><br /><br /></p>

<div class="definition">
<span id="def:unnamed-chunk-24" class="definition"><strong>Definition 4.1  </strong></span>A random variable <span class="math inline">\(Y\)</span> is a discrete mixture if the distribution of <span class="math inline">\(Y\)</span> is a weighted sum <span class="math inline">\(F_Y(y) = \sum \theta_i F_{X_i}(y)\)</span> for some sequence of random variables <span class="math inline">\(X_1, X_2, \dots\)</span> and <span class="math inline">\(\theta_i &gt; 0\)</span> such that <span class="math inline">\(\sum \theta_i = 1\)</span>.
</div>

<p>For <span class="math inline">\(2\)</span> r.v.s,</p>
<p><span class="pagebreak"></span></p>

<div class="example">
<span id="exm:unnamed-chunk-25" class="example"><strong>Example 4.1  </strong></span>
</div>

<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">5</span>, <span class="dv">25</span>, <span class="dt">length.out =</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">mixture &lt;-<span class="st"> </span><span class="cf">function</span>(x, means, sd) {</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="co"># x is the vector of points to evaluate the function at</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  <span class="co"># means is a vector, sd is a single number</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  f &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">length</span>(x))</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  <span class="cf">for</span>(mean <span class="cf">in</span> means) { </a>
<a class="sourceLine" id="cb17-8" data-line-number="8">    f &lt;-<span class="st"> </span>f <span class="op">+</span><span class="st"> </span><span class="kw">dnorm</span>(x, mean, sd)<span class="op">/</span><span class="kw">length</span>(means) <span class="co"># why do I divide?</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  f</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13"><span class="co"># look at mixtures of N(mu, 4) for different values of mu</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14"><span class="kw">data.frame</span>(x, </a>
<a class="sourceLine" id="cb17-15" data-line-number="15">           <span class="dt">f1 =</span> <span class="kw">mixture</span>(x, <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>), <span class="dv">2</span>), </a>
<a class="sourceLine" id="cb17-16" data-line-number="16">           <span class="dt">f2 =</span> <span class="kw">mixture</span>(x, <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>), <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">           <span class="dt">f3 =</span> <span class="kw">mixture</span>(x, <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>), <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb17-18" data-line-number="18">           <span class="dt">f4 =</span> <span class="kw">mixture</span>(x, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">20</span>), <span class="dv">2</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb17-19" data-line-number="19"><span class="st">  </span><span class="kw">gather</span>(mixture, value, <span class="op">-</span>x) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20"><span class="st">  </span><span class="kw">ggplot</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb17-21" data-line-number="21"><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(x, value)) <span class="op">+</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22"><span class="st">  </span><span class="kw">facet_wrap</span>(.<span class="op">~</span>mixture, <span class="dt">scales =</span> <span class="st">&quot;free_y&quot;</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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o3EeaAUEIAABCEAAAhCAAAQgAAEIQAACEIAABCAQAgEUoCFApUgIQAACEIAABCAAAQhAAAIQgAAEIAABCEAgGgRQgEbjPNAKCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAIAQCKEBDgEqREIAABCAAAQhAAAIQgAAEIAABCEAAAhCAQDQIkAU+GueBVkAAAhCIFIE//vjDfPfdd0YZVNddd13bNq1TNsott9zSrL322pFqL42BAAQgAAEIQAACQRKYP3+++fnnn03jxo1NvXr1giyasiAAAQhAoAAEUIAWADpVQgACEIgigaVLl5o333zTDB061IwaNcosW7YsaTPXW289s++++5oePXqYjh07mqpVqybdj5UQgAAEIAABCECg2AjMmTPH3HvvvWbgwIFm8eLFtvk1atQwTZo0MU2bNjXNmzc3hx12mGnZsmWxdY32QgACEChpAihAS/r003kIQAACxowdO9YMHjzYvPrqq2bhwoWVIlm0aJF57rnn7F/9+vVNt27d7IuALEMRCEAAAhCAAAQgUIwEZs2aZe655x7zxBNPmCVLlpTpghSh8ozRn+Txxx83F198senXr5+pUqVKmX35AgEIQAAC0SSAAjSa54VWQQACEAidwLx588yll15qLT4TK5Pb++67725q165t1lxzTbtZFqKzZ882o0ePNsuXL7frZCXx4IMPmocffticdNJJ5txzz8U9PhEm3yEAAQhAAAIQiCwBKTevu+46q/jUWMfJGmusYT1dFAJIrvC///6722THQVdccYUZM2aMue2223CR98iwAAEIQCC6BFCARvfc0DIIQAACoREYPny4ueCCC8xvv/3m1SFFp5Secm3fa6+9jNy95O5es2ZNu48UprKIWLBggXnllVes4vTDDz+021atWmWtJl5//XVzyy23mB122MErlwUIQAACEIAABCAQRQIrVqwwJ5xwgg3949qn0D4aC51xxhlm0003dautO/z06dPteEeeMxKFDNpzzz3NXXfdZTp06ODtywIEIAABCESPAFngo3dOaBEEIACB0AjIeuHEE080ffv29ZSfSmh00UUXmS+++MI89thj5sADD7TKz1SNqFWrljniiCPM888/bz799NMy7l/ff/+9dYm//PLLzV9//ZWqCNZDAAIQgAAEIACBghJQYsczzzzTU35K8anYnu+99565/fbb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AAVoLvQ4FgIQCJXAihUrrPJzzpw5tp42bdqUsQQNs3JZ4MnN3sVjVFIhWYZ+8sknYVabUdkvv/yytU79888/7XFbb721VX66zJwZFZbnnVu2bFmmrb/++qtVgkaJ77Bhw6xlrYtTKq4vvfSSOeigg0KnVbVqVXPfffd5WVYnTpxoLrzwwtDrpQIIQAACEIBAXAjI40SJCyV169Y1l1xySV67ptjg559/vldn//79vQl9byULEIAABCCQNwIoQPOGmoogAIFMCSho/NixY+1htWvXtpaZiv+ZL9ljjz2swkvxNCVz58612dTlXl5oUeZ7WTW4+KSyaFCMKWdVWej2pVO/rFWlUGzevLndXVasSpYUhZiXir0py2PFgpW0bt3axoht1aqV/Z6Pf3KvV+xbZ2kql3vFUEUgAAEIQAACEKiYwOLFi81ll13m7XT55ZebOnXqeN/ztXD44YfbuKOqT+74Tz/9dL6qph4IQAACEEgggAI0AQhfIQCBaBBQsPgHHnjANqZKlSrm7rvvLohbtywVlXxJ1qcSKcROPvlkM2DAALNq1Sq7Lt//VPell17qJePp0qWLGTRokBdXM9/tyaU+xciSJWvbtm1tMXLzPvbYY21/cik322P/+usvI5e166+/3iti7733LmOt6m3Iw8IOO+xg9NLmRDHEnEWqW8cnBCAAAQhAAAJlCTzxxBPGeRApaeHBBx9cdoc8fZNHh8ZsThSDdNGiRe4rnxCAAAQgkEcCKEDzCJuqIACB9AlceeWVnoJPlo7KIF4oadCggRk6dKhRchonCqivWKQu8ZBbH+anrD3PPvvsMsH8jzzySPPggw8al2k0zPrDKltWq7Je3W233WwVUiyfc845RlaY+RRliO3atas9167efv36mUceecSss846blXeP48//ngjJaxE2eiViR6BAAQgAAEIQCA5AU1WK163E8XVLqTsueeepmPHjrYJmsS86667Ctkc6oYABCBQsgRQgJbsqafjEIgugTfeeMO8//77toFyAz7zzDML3lgpwKRoVEZuJwpoL8XUxx9/7FaF9qlEQQceeKB55plnvDrOOussI0sCWRcUuyjW6sCBA02PHj28rsgKs0+fPjb0gLcypAXF+5Ql7bfffmtrUIZYsZUi3iXDCqnqtIqVFajLWvvkk09aN7q0DmQnCEAAAhCAQIkR0Fhp1qxZ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CghAAAIQiCqBJ554wmvaYYcd5i2zkD8C6623npESVKKEhprIRCAAAQiUKgEUoKV65uk3BCogsGrVKuN3dT3iiCMq2JtNEIBA3AngQhf3M0z/IAABCARL4JNPPjFff/21LXSzzTYzu+yyS7AVUFraBPzjeNzg08bGjhCAQAwJVIthn2LdJc3ihS3Vqv3vsshHXWH3JUrlr7nmml5zZE2prOpRlddff938+uuvtnlKgrLttttGtaleu8RTbrpctx6SQBaqV6/ulaP4Xe7+4K1kIScCum7FNOrXbY8ePcyFF15o5syZY5TRd/bs2WbTTTfNqe9hHpx43frvv2HWWypl67oV47CvW+eFUCpc6ScE4kRg4MCBXneOPvpob5mF/BPQOH7LLbc033zzjZkyZYr5+OOPzY477pj/hlAjBCAAgQITQAFa4BOQafXrrrtupodkvL+L9ZaPujJuXEwO0Iuj/wU9at168sknvSadeOKJphiuBa5b75QFuuC4qlAp7gmFECheq7R3StBgSw6+tOOOO85cf/31tmBZiF977bXBVxJQif7rVop7JFgC4iulctgTIitXrgy24TEtTecj7HuzO9cau1StWjWmJAvbrXycx3z1UHEmX3nlFVud4k8eddRRoV+jyfrmJr/0+5B3UymLlNAXXXSRRaAwV7vuumsgOOJ03QYCJIBC3P1W1y0TgQEA/f8idK060dg77Oemq6tUPv3XbZT7XOXvH9XqKDeQtpUlMGPGjLIrQvhWp04dW+q8efNCKL10i5QS0QV/V1bMv/76K5IwZNm13XbbGb141qxZ04wbN86ss846kWyrv1H16tWzbZ4/f75/Ncs5EpCFl64Die4JLplBjsVy+P8T2GCDDWxMLt0Toi4//vij58JYv35989lnn4WuAMuWia5ZZ52ouKVLly7NtiiOS0JA51/3goULFybZGtwqvaw0bNgwuAJjWpLGE8XwnI4pfrqVhIAmyy644AK75fjjjzcPPfRQkr1YlU8CGsM1btzY3rt1v5CnV61atfLZBOqCAAQgUHACWIAW/BTQAAhEi4BmhZ3VjdxeeamK1vmhNRAoFIFmzZqZDh06WBd4ucK/8cYbZr/99itUc6gXAhD4fwLLli0LXRktS7q6deua3377zRsjcAKCIbDhhhtab4AVK1bEIkO3LC3vueceD07v3r3NrFmzvO/5XJCFV+3atW34llK3ABV3PbOHDh1qjTDuvPNO069fv6xPR4MGDeyxSqykiUYkOALyXJFyWkYp2KoFx1VWn5rAlei5ibFXcGxVkqz9ZeyVj/u9u/9k0wMUoNlQ4xgIxJSAHrJPP/201zt/0HRvJQsQgEDJEtA9QTFAJQqVgQK0ZC8FOh4xAmErd9xLuD7DritiaPPanDiwHTVqlJk2bZrl1q5dO9OqVauCXTOOpz7dcl5PaMQqUygCKUAljzzyiFFoG79bcLrNTTwGtumSS28/d78VV7ec3pHslS4BnmXpkkp/P3etRv1+EN0sLOmzZk8IQCAgAmPGjPEGrW3btrWD1oCKphgIQCAGBKTwlBWYZPTo0Wb69Okx6BVdgAAEIACBoAg89thjXlF9+vTxllkoPAElNpVCWvLDDz+Yt99+u/CNogUQgAAE8kgABWgeYVMVBKJO4KmnnvKaiPWnh4IFCEDg/wkoAUqvXr3sN830KhkSAgEIQAACEBCBn3/+2bz11lsWhlzPDzzwQMBEjICsPp0Qm9WR4BMCECgVAihAS+VM008IVEJAGTtfe+01u5fifnbv3r2SI9gMAQiUIgH/5Ig/ZnApsqDPEIAABCDwD4EnnnjCc9lV7E/FMkSiRaBbt26eJ8c777xjvv/++2g1kNZAAAIQCJEACtAQ4VI0BIqJwLPPPmuzUavNUn4qaz0CAQhAIJFAixYtzI477mhXz5gxw7P2SdyP7xCAAAQgUDoElFTEH0f+6KOPLp3OF1FPpZQ+8sgjvRY/+uij3jILEIAABOJOAAVo3M8w/YNAGgTkyor7exqg2AUCELAE/C9PsvhBIAABCECgtAm88sorXjbw3XbbzTRv3ry0gUS491JOV61a1bZw8ODBZtGiRRFuLU2DAAQgEBwBFKDBsaQkCBQtAcVrmjp1qm2/gqMraycCAQhAIBWBrl27GsV3kyjjr5IpIBCAAAQgULoE/MmPsP6M9nXQuHFjs++++9pG/vnnn0ZKUAQCEIBAKRBAAVoKZ5k+QqASAv4g6Mcff3wle7MZAhAodQI1atQwLhaoLMgfeeSRUkdC/yEAAQiULIHPPvvMfPrpp7b/G220kdlrr71KlkWxdNyfDElu8HqWIxCAAATiTgAFaNzPMP2DQCUEJk+ebEaPHm33qlevnlFwdAQCEIBAZQT69OnjudApGdLChQsrO4TtEIAABCAQQwL33HOP1ytNpDv3am8lC5EjsNNOO5mtt97atkteYEqIhEAAAhCIOwEUoHE/w/QPApUQ8Ft/ymVprbXWquQINkMAAhAwRlY+++23n0UhF7pBgwaBBQIQgAAESoyAQqC89tprttc1a9Ysk2CnxFAUXXf9Xl/+94Gi6wgNhgAEIJAmARSgaYJiNwjEkcC8efPM888/b7u25pprmmOOOSaO3aRPEIBASAT69evnlSw3+FWrVnnfWYAABCAAgfgTuO+++zz36aOOOsqst9568e90THoor6+6deva3rz99ttePoCYdI9uQAACEChHAAVoOSSsgEDpEFDm98WLF9sOH3jggWbDDTcsnc7TUwhAIGcC22+/vWnbtq0tZ9q0aeaNN97IuUwKgAAEIACB4iDw+++/m2effdY2VhPpffv2LY6G00pLYO211/bieWsFVqBcGBCAQNwJoACN+xmmfxBIQWDFihVGQc+d+C253Do+IQABCFRGwH/vePDBByvbne0QgAAEIBATArL8X7p0qe1N9+7dTcOGDWPSs9Lphry/qlWrZjusUDZz5swpnc7TUwhAoOQI/O9uF6Nu6yE8ZMgQm4lQ7r0tWrQw7dq1M126dMkqIPc333xjnnvuOfPTTz+Zdddd17Ru3drsscceZtNNN01JTS4EY8aMMdOnT7fugBtvvLHZeeedyYiYkhgbCkHg1VdfNTNmzLBV77jjjqZNmzaFaAZ1QgACRU7ggAMOMP379zezZs0yH374oZk4caKXWKHIu0bzY0Qgm/Fcqu5nOtb866+/TGWTA127djWbb755qipZD4HIEdB1/dhjj3nt+s9//uMts1A8BBo3bmx69epllMxQ97b777/fXHLJJcXTAVoKAQhAIAMCsVKAzp8/35x88snm559/tggU00RBufX3wQcfmMsvv9xUr149bTxSpN5+++12f8WzWbZsmfn888+tq8eAAQPMtttuW6YsPTTOO+88M27cOLt+/fXXt5/ffvutGTlypHn55ZfNDTfcYGrUqFHmOL5AoBAE/G4ufguuQrSFOiEAgeIlILdHZYS//vrrbSd0b7n11luLt0O0PHYEMh3PVQQgm7HmlClT7OR8ReVqsh4FaEWE2BY1AoMHDzYyNpHIOGSLLbaIWhNpT5oETj31VKPzuXr1ajNw4ECj77Vr107zaHaDAAQg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b5tWRCAMBFq0aGFGjhxpdtttN1sdQn8R9ot7dvHixWGoouogAiIQYwJSgMb44qpp4SfAi/60006zis5ly5bZCm+44YZmwIABpnPnzuFvgGooAiIgAgUmcNFFF5n77rvPkCQJ+eabb8zRRx9tsJj/7bffClwbnU4EREAEikNgyZIl5vTTTy/ThyRu8r333msVSvIeKs510VkrJ1C3bl1DrFosQp0MHz7ctG7d2jz11FPmzz//dJu1FAEREIFACUgBGihOFSYC6RN4+eWXrdXn66+/7h3Upk0bM2bMGNOqVStvm1ZEQAREQATKEjjmmGPMiBEjTKNGjbwfcJHHGpTsxxIREAERiCuBP/74w/Tr18/2IXkOOqEPOW7cOOtS7LZpKQJhJVClShUbE/Suu+7yLJV//vlnc+2115pOnTqZd999N6xVV71EQAQiTEAK0AhfPFU9mgTGjx9vDjnkEHPOOeeYpUuX2kZUq1bNdgL+85//mHr16kWzYaq1CIiACBSQQOPGja0S9OKLL/aSKsybN8906dLFnHTSSeaDDz4oYG10KhEQARHILwEUn/QTmSQnFAjxExFiJN9+++32ty222CK/lVDpIhAwgeOPP95MmDDBJkRyRX/88cfmsMMOM7zfv/rqK7dZSxEQARHImcB//cdyLiY8BaxatcoMGTLEzhqhXNp+++3NrrvuameSXNa5TGr72Wef2WDNX3/9tUFJtfPOO1sLk2222SZlMdkck7Iw/RAbAig+meWcOHFimTbh7nHPPfdI8VmGir6IgAiIQOUEiJd82WWX2Xc8rvGffvqpPQgL+1deecUcccQR5oILLjA77rhj5YVpj1gTCLJvlk1fM5tjYn1B1Li0CeAOjLswfcVEZdDee+9tXd633HLLtMvTjiIQNgLcv3379rVecFiAMpmJDBw40AwaNMi+48866yzTrFmzsFVd9REBEYgYgTX+/kciVueU1SWGIlZ1xANDNt54Y292FLeQ66+/3mBun66gSL3//vvt7sTU+f333+1n/fXXN7fddpvZfffdyxWVzTHlCqlgw4IFCyr4NZifNtpoI1uQs04MptTSLIUBz9ixY82jjz5azpVj0003NT169LBZjddYY43SBBRgq8lyyiDBxVINsOiSLopnX/Xq1S0DngkrV64saR5BN55MqKtXrzbLly8PuuiSK493NMnjeN7+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hw4dXDF2mc0xZQrQFxEQAREQAREQAREQgcAIZNM3mzlzprn55pttpnBnwUmFsulrZnNMYI1XQSIgAiIgAiIgAiIgAh6BvChA77vvPnPJJZfYk5BNbeedd7ZWlLNnz/ZOTMY4lJLE2BwwYIAh29mTTz7p/Z7NSps2bcy9995rFaC4qfNBsAwla+Uuu+ySdrFrrbWW6d27ty1v1KhRBitShO1HHXWU+de//mVjgPoLzOYY//FaFwEREAEREAEREAERCI5A0H2zbPqa2RwTHAGVJAIiIAIiIAIiIAIiAIE1/rHW/DtIFFhcNmvWzKxatcocfPDB5uGHHzb169c3F110kbUKRTF6991321OSZOiEE04wEydOtIrFjz/+2Oy4446BVAcrTcon+HydOnXKKSszOQnK2jlz5hhQbbnllqZatWqVHp7NMZUWqh1EQAREQAREQAREQASyIhB03yybvmY2x2TVWB0kAiIgAiIgAiIgAiJQhkDgFqBYYKL83G233czgwYOtZWeZM/q+oEwcOXKkqVevns2q3qdPH3PHHXf49sh+tVatWoZPEIIVa6aK2WyOCaKuKkMEREAEREAEREAERKA8gaD7Ztn0NbM5pnxLtEUEREAEREAEREAERCBTAoEnQXr//fdtHa666qoKlZ+uori+YymKzJo1y23WUgREQAREQAREQAREQAREQAREQAREQAREQAREQARyJhCoAvTPP/80uLEje+yxR9qV69Spk9133rx5aR+jHUVABERABERABERABERABERABERABERABERABESgMgKBKkAJNL/BBhvYcy5fvryyc3u/L1682K5vvvnm3jatiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiECuBAJVgFKZpk2b2jqNHTs27boRBxRp0qRJ2sdoRxEQAREQAREQAREQAREQAREQAREQAREQAREQARGojEDgCtDmzZvbc954441m9uzZlZ3f9O3b14wYMcLul4nbfKUFawcREAEREAEREAEREAEREAEREAEREAEREAEREIGSJxC4AvSKK64wZHf/+eefzZ577mkeffRRs2jRonKgv/76a9O9e3dz+umn299at25tOnfuXG4/bRABERABERABERABERABERABERABERABERABERCBbAms8fc/ku3BqY4bN26c2W+//cxff/3l7bLuuuuaVatWmbp165rVq1ebJUuWeL9VrVrVzJw502y33XbeNq2IgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQK4EArcApULt27c3b7/9tmnRooVXP5SfyIIFC8ooP/fdd1/z7rvvSvnpkdKKCIiACIiACIiACIiACIiACIiACIiACIiACIhAUATyYgHqKodx6ZAhQ8xbb71lZs2aZT9s22GHHcz2229vFaWHHXaY211LERABERABERABERABERABERABERABERABERABEQiUQF4VoIHWVIWJgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQIYE8uICn2EdtLsIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI5IXA2kGXiqv7smXLsip2iy22MJtvvnlWx+ogERABERABERABERABERABERABERABERABERABEUgkELgL/MEHH2xee+21xPOk9b1Xr17m+uuvT2tf7SQCIiACIiACIiACIiACIiACIiACIiACIiACIiAClREI3AK0shPq99wIzJw5M7cCdLQIiIAIiIAIiIAIRIDAWmutZZo0aRKBmha3ivPmzTNLly4tbiV0dhEQAREQAREQAREoAIGmTZtmfZbAFaCXXHKJ6dq1a8oK/fnnn+ann34yX375pRk6dKhdHnTQQeaJJ54wG264Ycrj9IMIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIZEogcBf4TCqAIrRz585m7Nix5qKLLjL33ntvJoeX5L6yAC3Jy65Gi4AIiIAIiEDJEZAFaHqXXBag6XHSXiIgAiIgAiIgAtEnkIsFaFGzwGPxSbxQEh/dd9995o033oj+1VALREAEREAEREAEREAEREAEREAEREAEREAEREAEQkOgqApQKFSpUsV07NjRApkwYUJowKgiIiACIiACIiACIiACIiACIiACIiACIiACIiAC0SdQdAUoCF2A+4kTJ0afqFogAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQGgKhUICOHz/eAllnnXVCA0YVEQEREAEREAEREAEREAEREAEREAEREAEREAERiD6BoitAiQE6ZswYS3LPPfeMPlG1QAREQAREQAREQAREQAREQAREQAREQAREQAREIDQE1g66Ji+++KKZO3duhcX+8ccf5rfffjMzZswww4YNs/uuscYa5sADD6zwOP0oAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgApkQCFwB2qdPH5vZPZNKsO/ll19uWrdunelh2l8EREAEREAEREAEREAEREAEREAEREAEREAEREAEUhIIXAGa8kwpfthtt93MOeecY7p165ZiD20WAREQAREQAREQAREQAREQAREQAREQAREQAREQgewIBK4A7du3r1mxYkWltSHhUc2aNU3VqlUr3Vc7iIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEA2BAJXgG666abZ1EPHiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEDgBIqeBT7wFqlAERABERCBnAikY8Wf0wl0sAiIgAiIgAiIgAiIQGQIkMR49erVkamvKioCIiACyQhkbQE6ZcoUM3ny5GRlZr1t7733NnwkIiACIiAChSXw559/moceeshMmzbNLFy40BCm5M477zRNmjSxFRk3bpx58803zbfffmvq1KljGjdubNq2bWvXC1tTnU0EREAEREAEREAERKAQBN5//33z7LPPms8++8z8/vvvpkWLFuamm25Kemr2feyxx0yzZs3MaaedlnQfbRQBERCBYhLIWgE6atQo06tXr0DrTnlSgAaKVIWJgAiIQFoE+vTpY4YOHWr33Xjjja0CdPPNNzcoRq+99lrzzjvv2N822GAD8+WXX5q33nrLDBw40Nxyyy2mYcOGaZ1DO4mACIiACIiACIiACESDwOLFi+14/5dffjFrrrmm2XLLLU39+vWTVp59br/9dsMx7CcRAREQgTASyFoBGsbGqE4iIAIiIALZEXj77bftgd27dzddu3Y1a6yxhv3OTD7Kz7p165qzzjrLNG/e3Cxbtsy88sor5vnnnzc9evSwlgEoTSUiIAIiIAIiIAIiIALxIPDxxx8bFJsbbbSReeqpp0z16tVTNuy+++6zys+UO+gHERABEQgBgawVoBdddJHp1q1boE0gK7xEBERABESg8ASWLFliT9qqVStP+Ymr07Bhw+z2k046yfAbsskmm5jTTz/dTJw40cyfP98qSA844AD7m/6IgAiIgAiIgAiIgAhEn4DrGzZt2rRC5eeYMWPM+PHjTY0aNczy5cuj33C1QAREILYEslaA8oDjIxEBERABEYgugQULFphVq1Z5ge2XLl1q3d6Z7V+5cqVp3bq1oQPcoUOHco1EIYobPHGhpAAth0cbREAEREAEREAERCByBEiGuWjRItv/c5X/6quv7AT5Vltt5TbZJfv17t3bEDbp4IMPNk888USZ3/VFBERABMJEIGsFaJgaobqIgAiIgAhkR+Dmm2+2Ckx39CWXXGJXzzjjDOsKf8UVV7ifyi3nzp1rtzVq1Kjcb9ogAiIgAiIgAiIgAiIQPQIffvihufrqq72KY93Jp0qVKua1117ztv/111/mtttuMyhMb731VjNr1izvN62IgAiIQBgJhEoB+vfff3uul2GEpTqJgAiIQNwIdOnSxWD1SaxPEh4R2qRq1ape9vdk7SUT/PDhw63r+2abbWbjgibbT9tEQAREQAREQAREQASiRQArz3POOcfMmDHDTJkyxTRu3Ni0bdvWrLXWWmUaghcQytITTzzRMBkuBWgZPPoiAiIQQgJ5VYBiKr9w4UJDHDlmiJyg6Pzjjz/sYPvXX3+1JvYMpskAf80117jdtBQBERABEcgzgfbt29szkAUeBSjuS7i/J5MvvvjCYDGKAhShQ3zjjTeaDTfcMNnu2iYCIiACIiACIiACIhAxAkxud+7c2YZHQgG69dZb2+/+ZqDsfPrpp832229vFaD+37QuAiIgAmElkBcFKNmEr7zySjNhwoSM2t2sWbOM9tfOIiACIiAChSPw5ZdfWjcnFKRYjX7zzTfmrbfeMp06dZL1fuEug84kAiIgAiIgAiIgAkUjQOz4W265xVqEXnXVVWbttfOiUiha+3RiERCB+BII/GnFoPjII4+0lp+ZYCNwcsOGDTM5RPuKgAiIgAgUkEDHjh29ZEfM/BPv6e6777buUViCSkRABERABERABERABOJNgLBJTIKfe+65pn79+vFurFonAiIQKwKBK0CZDcLtHdl3333NYYcdZtZff31z5plnmnXXXdc8+eSTBrf3r7/+2gwaNMjMmTPHbLPNNjYJxzrrrBMruGqMCIiACMSJwBprrOE1B5enXr16GZIlYQX66aefmp122sn7XSsiIAIiIAIiIAIiIALxIjB16lQzdOhQs/vuu5sjjjgiXo1Ta0RABGJPIHAF6PTp0y00LIVGjhzpAbz99tutsnOHHXYwe+21l91++eWXW9dJHqRYEeE2LxEBERABEYgGAWb9iQs1e/ZsG/heCtBoXDfVUgREQAREQAREQASyIfDqq6/awz777DNz9NFHlykC13hk4sSJ5qijjrIx4p966qky++iLCIiACBSTwJpBn9xlf7vwwgvLFN2yZUv7fdy4cd72mjVrmjFjxphtt93WJtIgvpxEBERABEQgHASw6nzooYfM4MGDU1bIWe4r/lNKRPpBBERABERABERABGJBYM0117SxP1F2/vzzz2U+TgFKsmN+w+tTIgIiIAJhIhCoBejq1au97MC4R/plxx13tF8/+OAD/2azwQYbmAMPPNA8+OCD5qWXXjKXXHJJmd/1RQREQAREoDgEVq5caZ/LZHkntnOiknP58uVm7ty5tnKJz/zi1FhnFQEREAEREAEREAERyBeBimK+v/LKK6Z3796mffv25uqrr85XFVSuCIiACGRNIFALUCyBatWqZSuTOFBOpQBl57Zt29pjPvzwQ7vUHxEQAREQgeITaNy4sdlkk03MTz/9ZOM3//XXX16lmOUndAlL9sOSXyICIiACIiACIiACIiACIiACIiACYSQQqAUoDSST+6RJkwzu7MSGc+JiwxEv5PfffzdVqlRxP5mqVava9Y8//tjbphUREAEREIHiEuA53bNnT3PxxRebIUOGGEKYkNyOZEg857/99lsb3+mqq64yuERJREAEREAEREAEREAEREAEREAERCCMBAIfsaIARR599NEy7cUCFKtQYoK8+eabZX4bNmyY/V69evUy2/VFBERABESguASw7iQOKJNYP/zwgxk0aJAZOHCgWbBggVWGEty+Tp06xa2kzi4CIiACIiACIiACIiACIiACIiACFRBY4+9/pILfM/4J5Wa7du0MxXbp0sVmdt9zzz1tOWyfMGGCIVbc+PHjTd26dQ3Kz9NPP90sXrzYnHnmmeaxxx7L+JyldMDMmTNLqblqqwiIQIgILFu2zHzzzTemWrVqpl69emUs+UNUTVVFBEQgJgTWWmst06RJk5i0Jn/NmDdvnlm6dGn+TqCSRUAEREAEREAERCAkBJo2bZp1TQJXgFITMsA/8MADtlIoOb/77ju7PnToUHP44Yfbddwla9eubRYtWmS/82fixImmdevW3netlCcgBWh5JtoiAiIgAiIgAiIQPwJSgKZ3TaUATY+T9hIBERABERABEYg+gVwUoIG7wIPz1ltvNeedd57N8O5PjHHooYeac8891xInmYZf+XnGGWdI+Rn9e1EtEAEREAEREAEREAEREAEREAEREAEREAEREIFQEciLBahrIZmD33//fdOmTRu3yS779u1rXn75ZTNjxgyz3XbbmeOPP9507969zD76kpyALECTc9FWERABERABERCBeBGQBWh611MWoOlx0l4iIAIiIAIiIALRJ5CLBWjgCtC5c+fa7O9kCZYET0AK0OCZqkQREAEREAEREIHwEZACNL1rIgVoepy0lwiIgAiIgAiIQPQJ5KIADdwF/vzzz7dJjm666SabLCP6eNUCERABERABERABERABERABERABERABERABERCBqBIIXAEKiDlz5piePXuaBg0amI4dO5rnn3/erFy5MqqMVG8REAEREAEREAEREAEREAEREAEREAEREAEREIGIEghcAXr66aebVq1aWRwkOho9erSN8Uk2+LPPPttMmzYtoqhUbREQAREQAREQAREQAREQAREQAREQAREQAREQgagRCFwB2rlzZzNp0iRrBXrDDTfYJEdAWbZsmXn00UdN8+bNTePGjc2dd95pFi5cGDVeqq8IiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiECECASeBClZ26dMmWKee+45M3DgQPPjjz96u6y99tqmU6dO5tRTTzWHHHKIqVKlivebVpITUBKk5Fy0VQREQAREQAREIF4ElAQpveupJEjpcdJeIiACIiACIiAC0ScQqiRIyXC2bNnSPPzww2bBggXmxRdfNFiJrrfeeuaPP/4ww4YNM126dDFbbLGFGTJkSLLDtU0EREAEREAEREAEREAEREAEREAEREAEREAEREAEsiIQuAt8RbXAwvPII480L7zwglm8eLF57LHHzEYbbWQPWbJkifnoo48qOly/iYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEBGBNbOaO8AdiYWKApQLEHHjh1rVq1a5ZW6/vrre+taEQEREAEREAEREAEREAEREAEREAEREAEREAEREIFcCRREAYqSc/jw4aZ///526Vd6brjhhqZr167mtNNOMy1atMi1PbE/foMNNoh9G9VAERABERABERABEVhzzYI6KkUWOGGl1D+M7OVTxUVABERABERABApEIG8K0L///ttMnDjR9OvXzwwePNhmgXdtWmONNUy7du2s0pN4oFWrVnU/aVkJgUKwcmEJli5dWklt9HMmBKpVq2ZQ+CPLly83v/32WyaHa99KCNSqVcv8+eefZZ41lRyin9MgwKC6evXqdk+eCStXrkzjKO2SLoFNNtnErF692j4T0j1G+1VOgHvWKYRIvuifeK38aO1RGYHatWvbZ8HPP/9c2a45/U5/UVI5AUJM5bt/yDl4zxLCihj+kuAI1KlTx3CvwxW+kuAIrLvuumbjjTc2ixYtMn/99VdwBZd4Sdyv3LcIfRhC2UmCI4BXbM2aNc3ChQsNOhVJMASYVN1ss81sYfQL/cm5gzlDaZdCP6RGjRo270+YSQSuAP3ss8/MM888YwYMGGDISumXrbbaypxyyimmW7duZuutt/b/pHUREAEREAEREAEREAEREAEREAEREAEREAEREAERCJxA4ArQSy+91Lz22mteRZnBIPERLu4dOnSwM5zej1oRAREQAREQAREQAREQAREQAREQAREQAREQAREQgTwSCFwB6uq61157WaXnsccea01h3XYtRUAEREAEREAEREAEREAEREAEREAEREAEREAERKBQBAJXgJ544onmzjvvNI0aNSpUG3QeERABERABERABERABERABERABERABERABERABEUhKIHAF6HHHHZf0RNooAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAoUmsGahT6jziYAIiEChCPzwww9m9uzZNjt8oc6p84iACIiACIiACIhAoQmQLXrOnDnKbFxo8DqfCIiACIhAZAgEbgEamZZHtKI1atTIe83XWWcde45CnCvvjQnRCdZe+3//biQHc5xDVMVIV2WttdYy33//vRk3bpyZOHGi/Xz22We2TdWqVTPNmjUzLVq0MMQn5rPRRhtFur1BVH7lypVm0KBBpm/fvubrr78uVyTPgFNPPdVccMEFpmrVqvaz7rrrlttPG7InwH27xhprKFZ29giTHul/vnLvrrfeekn308bsCKy55pqGZwHLfAoKHYkIiEByAj///LN57733zPTp0827775r13/66Sf7v3nyySeb888/32yyySbJD9ZWEciCwJQpU8xdd91lfvnlF28cw3P6jz/+MPXr1zfXX3+9qVevXhYl6xARyB+BCRMmmAceeMD89ttv3n37119/2ft2u+22M9ddd53ZdNNN81cBlRwqAmv889BS7zJUl6Tiyvz+++8V7xDAr05Rx8tMEhwBBop+tjx4JcEQmDFjhjnnnHNs5z+dElE4HXXUUea2224ryY4ays7HH3/cPPXUU2lZimy22WbmyiuvNN27dzdVqlRJB7H2SZMAzwRew3/++WeaR2i3dAigWOaDrF692jJO5zjtkx4BFMy8w/J933IOKa8rvybLli0zK1asqHzHHPbg2V+rVi2zePFiO2jMoSgdmkCgTp06diKMfjd80xHyLTCgr+h/kMl23ttnn322qVmzZjrFxm4fJmo23nhjs2jRIvvMil0DC9Qg7rN7773XfipSHTBxfvfdd5uDDjqoQDWL52n43+V/duHCheq/5HCJeabecccd5sEHH6ywFN5tvXv3Nu3atatwP/1YMQEMDngGLFiwoOIdA/i1bt26WZciBWjW6IpzYCFuKGcZt3Tp0uI0MqZnxQpxww03tK1bvny5nYWKaVML2qznn3/eXH311WbVqlXlzrvNNtsYHpAzZ860s9WJO9DBwLrxrLPOshYTib/H7TuucTfffLMZNWpUuYEALJzCyLWbGX6/MEjDouSEE06QItQPJod1rHNQ0PFMkARHoHr16maDDTawBf74449Jnw/Bna30Sqpdu7bBghwLtHwKk1U8dyQVE5ACtGI+Yf81EwUoyqeePXvaCczEdvEe33HHHc2HH35YRjHK8xAl6HnnnedNxCceG9fvUoDmfmW/++47c+6555qpU6emXVi3bt2sNai8htJGVmZHKUDL4MjqyzfffGOfe1jJpyvc51dccUXJPSfT5VPZflFRgObXd6kySvpdBERABLIkgMLz8ssvN5deeqmn3MDt5qSTTjIPP/ywwSp00qRJZvDgwQZX+DFjxpjbb7/dWn7ygEawmGEbM36jR4/OsibROOw///mP6dixo3n99dfLKD87dOhg+vfvb2OlfvHFF8b/GTp0qGnbtq3XQGair7nmGnPkkUcmVSh7O2pFBERABERABEQgUAJYRF9yySVllJ8HHnigndjk3f7555+b1157zeDuyXuaCQSEiQqsoC666KJA66PC4k+ACfP999+/jPLzjDPOsH3FX3/91fBhAmbatGmmdevWHpCnn37aHHzwwbZv6W3UiggUiMDw4cPtfetXfjIBNGvWLPs85Jm4ZMkSO07cY489vFo99NBD5ogjjjAoTyXxJSAL0IhdW1mARuyC+aorC1AfjBxXv/32W+vWhWWnky5duphHHnkkLdc8FHk33XSTefHFF93h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V+F/VrbYYgsv1uz333/vJQ/z76P1+BGI+n3LZINL4jl37lzbV4zfVYp+i6QAjf41VAtEIBIExo8f72V53muvvcx2220XiXqrkvkhsO+++9oOLqUTNPyTTz7Jz4lUamgJEOPpmWee8ep32mmneethXCGe96mnnupVTVagHgqtiIAIVECAQb2LaYc7OUrQqEmHDh28CaqJEyd6/bmotaMU6ou1JFaTToijGEVhUtSJXzHmtmkZLwJ//PGH5xFELpUjjjgikg3UfRv+yyYFaPivkWooArEgEGX3r1hcgJA1AmUSsUCd+BVhbpuW8SYwfPhws2jRIttIsgo3atQo9A3GdZVsugihG7BMkYiACIhARQT82d+j5v7u2kUMUDew//vvv40UUo5M+JYoqIlVjfBuxZoyikJSGRJnIoRdWLFiRRSboTqnSeDNN980WMsjxFyvU6dOmkeGazcUtyhwEYVvCNe1cbWRAtSR0FIERCBvBHihjRo1ypZfrVo1c+ihh+btXCo4OgQYCLo4sMTKUWKF6Fy7IGrqt6D0x9cMoux8lVGjRg1z1FFH2eKxVlD4hnyRVrkiEA8Cn332meGD4Pmy5557RrZh7tlHA/whjSLboJhW3K+cjqL7u7ssvG/9sWddGAn3u5bxIhCX+xbFrUuayfgXxa4kXATWDld1VBsREIE4EuClFnX3rzhel2K3adNNNzUHHHCAwRKQxAosXQbFYtdN588vARI0TJ8+3Z4E6xTug6gIylpilyIoQC+88EIvQ3JU2qB6xo8AVvX5FGfRwjLf58pnOwpdtt8VGQvKythV9nuh6+8/36677moaNmxoFbqzZ882M2fODH1yHcfTLf3tieM6E8kuSdW6665r480Wou35OgdK99dee81eKibKnRVyHK+dv03ueQtXLK7jLowBnIKbhJhY/+bjnvKXmc93GfftpEmT7GVjDEzYr1IQ/30b5vZKARrmq6O6iUBMCAwYMMBrSVTdv7wGaCVQAl27drWKTwrFokQK0EDxhrYwf0gMEmKttdZaoa1rYsV22GEH07p1a9u5XbJkiRkzZow58MADE3fTdxEoGAHcRGvWrFmQ822yySYFOU9cTkKoDCdnnHGG2WyzzdzXcks8Iir6vdwBRdjABNBll11mz8ykZadOnYpQi8xPWbt27cwPiuAR/fv397xpSLa1/fbb570VhEfI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yxx//PHWoweL0GwePXgO+eeJ48aNM0OHDjUsbE+ZMqUGuKlTp1pvI8qlLJJh+r2NrrjiiloL7qWcU6NS/Ug0gQ4dOth3jGbNmpkxY8Ykuq/qXDIIfPPNN2abbbaxncGCfvTo0cnomHqRaAIkleK5jWy77bbm1ltvTXR/1bnsBBLjAp/ZPTJV8i8IWWWVVUzr1q2LKqqUc4qqQAfHjgAvSz/88INtN65yEhGIAwGN2zhcJbUxk4B/3CZ0nTezy/qdg4DzzsFDaMKECQaPHoTtePQce+yxNZSfOYrxNjtvI5SmeBvxD8Hb6NRTT62l/GRfKedwniQdBJgbcp9yc8R09Fq9jDMB/3jF6EciAnEgoHEbh6sUfhsTqwANH51qEAEREAEREAEREAERiDqB1Vdf3Zx55plm0KBBBXn09O3b1/Avl3Tu3Nncd999NiZ8od5GpZyTq35tFwEREAEREAEREAERKJ6AFKDFM9MZIiACIiACIiACIiACMSMQtHdOKd5GpZwTM8xqrgiIgAiIgAiIgAhEkkDpgTEj2R01SgREQAREQAREQAREQAREQAREQAREQAREQAREQAR+JSAF6K8s9E0EREAEREAEREAEREAEREAEREAEREAEREAERCBhBKQATdgFVXdEQAREQAREQAREQAREQAREQAREQAREQAREQAR+JaAYoL+y0DcRCJVAr169TJMmTWwd7du3D7UuFS4CQRHo16+fadWqlS2uU6dOQRWrckQgVAL77LOPIekM0q5du1DrUuEiIAIiUA6BK6+80maBX2uttcopRueKQMUIkFiOcYuss846FatXFYlAOQTWXXddb9wSj1uSTgIr/fdnSWfX1WsREAEREAEREAEREAEREAEREAEREAEREAEREIGkE5ALfNKvsPonAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAikmIAVoii++ui4CIiACIiACIiACIiACIiACIiACIiACIiACSScgBWjSr7D6JwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIpJiAFaIovvrouAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAkknoCzwSb/C6l/VCXz33Xfm/vvvNy+99JJZtmyZzahNNu2+ffualVdeuertUwNEwBEYM2aMGTlypDn33HNN27Zt3eZan2+//ba57777zPvvv2/IWtuhQwfTq1cvs9lmm9U6VhtEIAwCkydPNs8884xZuHCh+emnn0zTpk3N9ttvb3bbbbec1Wnc5kSjHSIgAlUgoHtSFaCryqIJfP3112bQoEFmo402MoMHD855vt53cqLRjgoR+Oyzz8zo0aPNvHnzzJIlS8yGG25oWrRoYQ444ADTsGHDrK3QuM2KJdEblQU+0ZdXnas2gc8//9yccMIJ5oMPPrBNqV+/vlm6dKn9vssuu5ghQ4aY1VZbrdrNVP0iYGbNmmVOPvlk8+OPP5qrr77aoKTPJijzr7zySrtr7bXXNt9//739t8Yaa5jhw4ebLl26ZDtN20QgEAJMVE8//XQzc+ZMW94666xjP5cvX24/GbcXXXSRYTz6RePWT0PfRUAEqk1A96RqXwHVXwiB//73v+Zvf/ubmTZtmuncubO56qqrsp6m952sWLSxggSmTJlihg0bZr755htrYLTBBhsYFKL/+c9/7Jzwr3/9q+ndu3eNFmnc1sCRmh9ygU/NpVZHq0Hg/PPPt8rPbt26mccff9w88sgj5t577zUtW7Y0U6dOzTmRqEZbVWd6CaBMOvvss63yMx8FlKRMflHaDx061DzxxBNm3LhxVnHKhAMLgY8++ihfEdonAmURuPbaa63ys3nz5uaWW24xWC3z7+abbzabbrqpefXVV60C31+Jxq2fhr6LgAhUm4DuSdW+Aqq/EALM6y688EKr/KzreL3v1EVI+8Mk8OGHH3rKzyOOOMKMHz/ePPDAA/bz0EMPtUpRjDScQZJri8atI5GuTylA03W91dsKEnjrrbfMCy+8YFedLrjgArPuuuva2jfeeGNz2WWX2dWpsWPHmi+//LKCrVJVIvArAdyaLrnkEqvAJDzDb36T/5Fw++23G6wBBgwYYLBgXmmllcyqq65q+vfvb/bbbz/zww8/mIcffvjXCvRNBAIkwHh99NFH7Tg977zzTOvWrb3S27RpY5XybGCxiWOdaNw6EvoUARGIAgHdk6JwFdSGfAQI24XiiAXGuuaGet/JR1L7KkHgscces0rOXXfd1Rx55JFm9dVXt9XyefTRR5sePXqYb7/91nCcE41bRyJ9n/nfdtPHQz0WgcAIYIqPdO/e3dSrV89+d//hCr/tttta12GUoBIRqAaBgQMHWqvkNddc08Z1Ik5OLkGhhEIf6dOnT63D3DaUT7jRS0QgaAJYTeHKhKVntrHKNmI8oaR/7733bPUat0FfBZUnAiJQDgHdk8qhp3MrQWDixInm1FNPtR49eLCddtppeavV+05ePNpZAQIuLNLOO++ctTbGMTJ37lxvv8athyJ1X6QATd0lV4crReDNN9+0Vbmbbma9KECR119/PXOXfotARQgQ+wbF5W233ZY3eQyNmT17tlUsoXxq0qRJrfZhgffb3/7WfPHFF2bBggW19muDCJRLgHsmFqAXX3xx1qJQvDP+kPXWW89+atxaDPpPBEQgIgR0T4rIhVAzchIgVwHzvDPPPNM+b9dff/2cx7JD7zt58WhnBQgQnmvUqFFmu+22y1qby7/h5oYcpHGbFVUqNioLfCouszpZDQLEI0H8N1t/O9z2zHgk/mP0XQTCJDBixAjTqFGjgqqoazxTCGOakA6MaWWELwirDiqCACEX8r2ITZgwwVrVE26EUCOIxm0RgHWoCIhA6AR0TwodsSookwCJYvbdd1+zyiqFqQnqGtN63ynzguj0Ogng6p7NOIMTWRx33pbt27f3ytK49VCk7kthd7bUYVGHRaB8Al999ZUtxD34M0t02YvdcZn79VsEwiZQqPKTdrhxmms8c4zGNBQk1SCwaNEic/3119uqjznmGBuflh8at9W4GqpTBEQgFwHdk3KR0faoEGjQoEFRTalrTGtuWBROHRwwgRtvvNEsXLjQLozvscceXukatx6K1H2RC3zqLrk6XAkCP/30kw22TF24BWeTtdde227+7rvvsu3WNhGIFAGXVCbXeKaxbkwTaFwiApUi8Nlnn9kYZYR0wE1+77339qrWuPVQ6IsIiEAECOieFIGLoCYERkDvO4GhVEEhELj33nsN/0jkddZZZ3k5OTRuQ4AdoyKlAI3RxVJT40OAG+0aa6xhG5xLwem2r7baavHpmFqaWgJrrbWW7fv333+fk4Eb0y77Ys4DtUMEAiJAvNnjjz/eurq3a9fOkB3eLxq3fhr6LgIiUG0CuidV+wqo/iAJ6H0nSJoqK0gCN910k7n22mut8vPvf/+76dixo1e8xq2HIpVfpABN5WVXpytBwLmQEBMxm7jtbjKc7RhtE4GoEHDjefny5TmbpDGdE412hECABHLHHXecWbx4senatau57LLLTOb9VOM2BPAqUgREoGQCuieVjE4nRpSAG9NuDpjZTLc98/mceZx+i0AQBH744Qdz/vnnmzvuuMNgZMTC+G677VaraI3bWkhSs0EK0NRcanW00gTqurE6RVK+pB6VbrPqE4FcBOoaz5ynMZ2LnrYHTWDSpEnmz3/+s0261adPH5upNtvLlcZt0ORVngiIQDkEdE8qh57OjSKBusa05oZRvGrJbBPK9r/85S+GpJjEnr3iiitM9+7ds3ZW4zYrllRslAI0FZdZnawGgQ033NBW+95772Wt3m1v27Zt1v3aKAJRIuDGMxneWV3NlC+++MIsXbrUupq0atUqc7d+i0BgBB577DEzZMgQOw6POOIIg2tTrmy1GreBYVdBIiACARDQPSkAiCoiUgTcmHbvNZmNc9v1vpNJRr+DJICi/aSTTjIzZ840m2yyibnhhhtMhw4dclahcZsTTeJ3SAGa+EusDlaLQO/evW3VTz75ZK0mEHwZCyakU6dOtfZrgwhEjUCTJk1MmzZtzIoVK8yMGTNqNW/y5MnmP//5jz1mzTXXrLVfG0QgCALPP/+8tfZcaaWVzJlnnmmOPPLIvMVq3ObFo50iIAIVJqB7UoWBq7rQCeh9J3TEqqAOAv/973/tnHDevHmmdevWVvm56aab5j1L4zYvnkTvlAI00ZdXnasmge222840b97czJkzx4wdO7ZGU+666y5D5uJmzZqZbt261dinHyIQVQIHHXSQbdqIESOs67Fr58cff2zuuece+7N///5usz5FIFACJNm6/PLLDRPdgQMHmj322KOg8jVuC8Kkg0RABCpEQPekCoFWNRUhoPedimBWJXkI4Bk0a9Ysg1v7xRdfbNZdd908R/+yS+O2TkSJPWCVxPZMHROBKhPAQunoo482gwcPNsOGDTPTp083uAZzg+b7qquuas444wzDcRIRiAMB4ujgwjR79myrgOrZs6f58ccfDVbOKPR33HFH06tXrzh0RW2MIYH777/fLFq0yLb81ltvNf/f3r27RtGFcQB+vWHURgtxO8ULgqKYIIggwcLORkELxYABYS1EDAgW2ql/gIliYQqtFCUIFhY2QgoLCyMIYioLiazgLVgI3qIzH1kI3y6sgckZJ8+AOjs7O+c9zzkE89szu9mfdtulS5diz549+dPmbTslxwkQSCHgZ1IKdW0WJeD3naJkXbcTgezN8ex292x7//59HDx4sO3LNm7cGMPDw/nz5m1bpso/seDPSoqpyvdSBwkkFMg+iyQLQBuNRrOKbGXowMBA9PT0NI/ZIZBa4Pjx45HdPjI0NNT2oxmmV+FlHzA+/VmgixYtyv/DUa/Xo6urK3U3tF9RgewNo+zNo062y5cvR29vb/NU87ZJYYcAgRII+JlUgkFQQkcCo6Ojcf78+eju7o7BwcG2r/H7TlsaTxQo8OrVq3zBUSdNbNiwIW7evDnjVPN2Bse8eCAAnRfDrJNlEMhWyGVfIJN96HKtVsu/LKYMdamBwGwEspWfWViavYeWfc5Oq2/gns11vYZAkQLmbZG6rk2AwN8K+Jn0t2LOL7uA33fKPkLqayVg3rZSqeYxAWg1x1WvCBAgQIAAAQIECBAgQIAAAQIECBD4I+BLkEwDAgQIECBAgAABAgQIECBAgAABAgQqKyAArezQ6hgBAgQIECBAgAABAgQIECBAgAABAgJQc4AAAQIECBAgQIAAAQIECBAgQIAAgcoKCEArO7Q6RoAAAQIECBAgQIAAAQIECBAgQICAANQcIECAAAECBAgQIECAAAECBAgQIECgsgIC0MoOrY4RIECAAAECBAgQIECAAAECBAgQICAANQcIECBAgAABAgQIECBAgAABAgQIEKisgAC0skOrYwQIECBAgAABAgQIECBAgAABAgQICEDNAQIECBAgQIAAAQIECBAgQIAAAQIEKisgAK3s0OoYAQIECBAgQIAAAQIECBAgQIAAAQICUHOAAAECBAgQIECAAAECBAgQIECAAIHKCghAKzu0OkaAAAECBAgQIECAAAECBAgQIECAgADUHCBAgAABAgQIECBAgAABAgQIECBAoLICAtDKDq2OESBAgAABAgQIECBAgAABAgQIECAgADUHCBAgQIAAAQIECBAgQIAAAQIECBCorIAAtLJDq2MECBAgQIAAAQIECBAgQIAAAQIECCxGQIAAAQIECBAgQIDAfwKTk5MxPj6eP1iyZEl0d3e3pPn+/XuMjY3lzy1cuDB27tzZ8jwHCRAgQIAAAQIE0gtYAZp+DFRAgAABAgQIECBQEoGlS5dGf39/7Nq1K3p6euL+/fstK7tw4UJ+TnbeyMhIy3McJECAAAECBAgQKIfAgqk/WzlKUQUBAgQIECBAgACB9ALPnz/Pw81v375FrVaLly9fxqpVq5qFPX78OPbt2xe/fv2K3bt3x+joaCxe7MaqJpAdAgQIECBAgEDJBKwALdmAKIcAAQIECBAgQCCtwI4dO+LixYt5EY1GIwYGBpoFffz4Mfr6+vLwc+XKlXH79m3hZ1PHDgECBAgQIECgnAIC0HKOi6oIECBAgAABAgQSCpw9ezb27t2bV3Dr1q149OhRvl+v12NiYiLfHx4ejrVr1+b7/iJAgAABAgQIECivgFvgyzs2KiNAgAABAgQIEEgo8ObNm9i+fXt8/vw51q9fH+fOnYssAM22kydPxvXr1xNWp2kCBAgQIECAAIFOBQSgnUo5jwABAgQIECBAYN4JZLe4Hz16dEa/t23bFk+fPo2urq4Zxz0gQIAAAQIECBAop4Bb4Ms5LqoiQIAAAQIECBAogcCRI0dmBKDLli2LO3fuCD9LMDZKIECAAAECBAh0KiAA7VTKeQQIECBAgAABAvNSYN26dc1+//jxI75+/dp8bIcAAQIECBAgQKD8Am6BL/8YqZAAAQIECBAgQCCRwJMnT6K3tzd+/vzZrGDz5s3x7NmzWL58efOYHQIECBAgQIAAgfIKWAFa3rFRGQECBAgQIECAQEKBL1++xLFjx/Lwc/Xq1TE0NJRXMz4+Htm3xNsIECBAgAABAgT+DQEB6L8xTqokQIAAAQIECBCYY4HTp0/H69ev81avXbsWp06digMHDuSPs2+Af/jw4RxXpDkCBAgQIECAAIHZCLgFfjZqXkOAAAECBAgQIFBpgZGRkTh06FDex8OHD8fdu3fz/UajEVu2bIlPnz7FmjVr4sWLF5GtDrURIECAAAECBAiUV8AK0PKOjcoIECBAgAABAgQSCLx9+zbq9XrechZuZqs/p7darRZXrlzJH7579y5OnDgx/ZR/CRAgQIAAAQIESiogAC3pwCiLAAECBAgQIEBg7gWmpqaiv78/Pnz4kDd+9erV/63w7Ovri/379+fPP3jwIG7cuDH3hWqRAAECBAgQIECgYwG3wHdM5UQCBAgQIECAAIGqC2SrO8+cOZN3M7sF/t69ey27PDExEVu3bo3JyclYsWJFjI2NxaZNm1qe6yABAgQIECBAgEBaAQFoWn+tEyBAgAABAgQIECBAgAABAgQIECBQoIBb4AvEdWkCBAgQIECAAAECBAgQIECAAAECBNIKCEDT+mudAAECBAgQIECAAAECBAgQIECAAIECBQSgBeK6NAECBAgQIECAAAECBAgQIECAAAECaQUEoGn9tU6AAAECBAgQIECAAAECBAgQIECAQIECAtACcV2aAAECBAgQIECAAAECBAgQIECAAIG0AgLQtP5aJ0CAAAECBAgQIECAAAECBAgQIECgQAEBaIG4Lk2AAAECBAgQIECAAAECBAgQIECAQFoBAWhaf60TIECAAAECBAgQIECAAAECBAgQIFCggAC0QFyXJkCAAAECBAgQIECAAAECBAgQIEAgrYAANK2/1gkQIECAAAECBAgQIECAAAECBAgQKFBAAFogrksTIECAAAECBAgQIECAAAECBAgQIJBWQACa1l/rBAgQIECAAAECBAgQIECAAAECBAgUKCAALRDXpQkQIECAAAECBAgQIECAAAECBAgQSCsgAE3rr3UCBAgQIECAAAECBAgQIECAAAECBAoUEIAWiOvSBAgQIECAAAECBAgQIECAAAECBAikFRCApvXXOgECBAgQIECAAAECBAgQIECAAAECBQoIQAvEdWkCBAgQIECAAAECBAgQIECAAAECBNIKCEDT+mudAAECBAgQIECAAAECBAgQIECAAIECBQSgBeK6NAECBAgQIECAAAECBAgQIECAAAECaQV+A5ttMxX7lrB/AAAAAElFTkSuQmCC" width="672" /></p>
<div id="mixtures-vs.sums" class="section level2">
<h2><span class="header-section-number">4.1</span> Mixtures vs.Sums</h2>
<p>Note that mixture distributions are <em>not</em> the same as the distribution of a sum of r.v.s.</p>

<div class="example">
<span id="exm:unnamed-chunk-27" class="example"><strong>Example 4.2  </strong></span>Let <span class="math inline">\(X_1 \sim N(0, 1)\)</span> and <span class="math inline">\(X_2 \sim N(4, 1)\)</span>, independent.
</div>

<p><span class="math inline">\(S = \frac{1}{2}(X_1 + X_2)\)</span></p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p><span class="math inline">\(Z\)</span> such that <span class="math inline">\(f_Z(z) = 0.5f_{X_1}(z) + 0.5f_{X_2}(z)\)</span>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">n &lt;-<span class="st"> </span><span class="dv">1000</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">u &lt;-<span class="st"> </span><span class="kw">rbinom</span>(n, <span class="dv">1</span>, <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">z &lt;-<span class="st"> </span>u<span class="op">*</span><span class="kw">rnorm</span>(n) <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>u)<span class="op">*</span><span class="kw">rnorm</span>(n, <span class="dv">4</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="kw">ggplot</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(z), <span class="dt">bins =</span> <span class="dv">50</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAJACAYAAABMocy1AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N0LnB1VfTjwk93N+52QB6AEhBgoyicpfEha/zzjI4rQgm1FreBqo36wqFg/EYsSC5haUUKpFkXaaBEKhaoImKCRp0KlYBQafAQCGrBCSTZkSTbv/XsGZ9nd3H3P3b0z853P5+6998zMmXO+v3tn7/3dMzPDWn83BRMBAgQIECBAgAABAgQIECBAgAABAgQKKFBXwD7pEgECBAgQIECAAAECBAgQIECAAAECBBIBCVAvBAIECBAgQIAAAQIECBAgQIAAAQIECisgAVrY0OoYAQIECBAgQIAAAQIECBAgQIAAAQISoF4DBAgQIECAAAECBAgQIECAAAECBAgUVkACtLCh1TECBAgQIECAAAECBAgQIECAAAECBCRAvQYIECBAgAABAgQIECBAgAABAgQIECisgARoYUOrYwQIECBAgAABAgQIECBAgAABAgQISIB6DRAgQIAAAQIECBAgQIAAAQIECBAgUFgBCdDChlbHCBAgQIAAAQIECBAgQIAAAQIECBCQAPUaIECAAAECBAgQIECAAAECBAgQIECgsAISoIUNrY4RIECAAAECBAgQIECAAAECBAgQICAB6jVAgAABAgQIECBAgAABAgQIECBAgEBhBSRACxtaHSNAgAABAgQIECBAgAABAgQIECBAQALUa4AAAQIECBAgQIAAAQIECBAgQIAAgcIKNBS2ZzXSsaamprB9+/YaaU05mjFz5szQ3Nwctm7dWo4O62UiMG3atNDQ0BBaW1vDb3/7WyolEhg1alSYPHlyeOaZZ8LevXtL1PNyd3X48OFhv/32SxC2bdsWnn/++XKDlKz38T0/bNiwsGnTppL1vNzdnTBhQhg7dmyCsHHjxrBz585yg5So9/H9Hj/jb968ObS0tJSo57o6Y8aMUFdXF/bs2ROeffZZICUSGDNmTJg4cWL43//93xL1WldHjhwZpkyZkkC88MILSW6nvcr+++/f/mmfHhsB2icuCxMgQIAAAQIECBAgQIAAAQIECBAgkCcBCdA8RUtbCRAgQIAAAQIECBAgQIAAAQIECBDok4AEaJ+4LEyAAAECBAgQIECAAAECBAgQIECAQJ4EJEDzFC1tJUCAAAECBAgQIECAAAECBAgQIECgTwISoH3isjABAgQIECBAgAABAgQIECBAgAABAnkSkADNU7S0lQABAgQIECBAgAABAgQIECBAgACBPglIgPaJy8IECBAgQIAAAQIECBAgQIAAAQIECORJQAI0T9HSVgIECBAgQIAAAQIECBAgQIAAAQIE+iQgAdonLgsTIECAAAECBAgQIECAAAECBAgQIJAnAQnQPEVLWwkQIECAAAECBAgQIECAAAECBAgQ6JOABGifuCxMgAABAgQIECBAgAABAgQIECBAgECeBCRA8xQtbSVAgAABAgQIECBAgAABAgQIECBAoE8CEqB94rIwAQIECBAgQIAAAQIECBAgQIAAAQJ5EpAAzVO0tJUAAQIECBAgQIAAAQIECBAgQIAAgT4JSID2icvCBAgQIECAAAECBAgQIECAAAECBAjkSUACNE/R0lYCBAgQIECAAAECBAgQIECAAAECBPokIAHaJy4LEyBAgAABAgQIECBAgAABAgQIECCQJwEJ0DxFS1sJECBAgAABAgQIECBAgAABAgQIEOiTgARon7gsTIAAAQIECBAgQIAAAQIECBAgQIBAngQkQPMULW0lQIAAAQIECBAgQIAAAQIECBAgQKBPAg19WtrCBAgQIECAAIHfCTQ2NlbNYcWKFVWrW8UECBAgQIAAAQIECJRPwAjQ8sVcjwkQIECAAAECBAgQIECAAAECBAiURkACtDSh1lECBAgQIECAAAECBAgQIECAAAEC5ROQAC1fzPWYAAECBAgQIECAAAECBAgQIECAQGkEJEBLE2odJUCAAAECBAgQIECAAAECBAgQIFA+AQnQ8sVcjwkQIECAAAECBAgQIECAAAECBAiURkACtDSh1lECBAgQIECAAAECBAgQIECAAAEC5ROQAC1fzPWYAAECBAgQIECAAAECBAgQIECAQGkEJEBLE2odJUCAAAECBAgQIECAAAECBAgQIFA+gYYidXnbtm3hK1/5SrddOuWUU8Jhhx3WYZkdO3aEm266KTz44IOhqakpzJ49O8ydOzcsWrQo1NfXd1jWEwIECBAgQIAAAQIECBAgQIAAAQIE8iNQqAToY489liQyu+OPic32CdDNmzeHc845J2zYsCFZbcqUKWHVqlXJ7b777gtLly4NI0aM6K5K8wgQIECAAAECBAgQIECAAAECBAgQqFGBQiVA161blzAfffTR4eSTT65IHkd3tp8uvvjiJPk5f/788MlPfjJMnDgxPP300+GCCy4I99xzT7jiiivCRz/60fareEyAAAECBAgQIECAAAECBAgQIECAQE4ECpkAjcnP0047rccQPProo+GBBx4Io0ePDpdcckkYNWpUss6BBx4YLrvssnDGGWeElStXhve9731h/PjxPdZnAQIECBAgQIAAAQIECBAgQIAAAQIEakugUBdBiofAx2nOnDm9Ur7rrruS5U444YS25Ge6YjwU/thjjw07d+5MkqBpuXsCBAgQIECAAAECBAgQIECAAAECBPIjUJgE6O7du8P69etDQ0NDeMUrXpFEYMuWLSFe4Kirae3atcmsePh7pSkmQOP08MMPV5qtjAABAgQIECBAgAABAgQIECBAgACBGhcozCHwv/rVr8KuXbvCQQcdFK677rrwzW9+M2zcuDHU1dUlZe985zvD61//+g7hiOf6jNOkSZM6lKdP0vL0Aklpeef7G264IcQEbKUpXnTpZS97WaVZyqooMHz48DBmzJgqbkHVtSYQ3+vpJPapRDnu4/s9TvF0Jq2treXodMF72Zv3cH19fZtC/PGzN+u0reBB7gXS+It77kPZpw7E93o6jRw5Mhn4kD53Xw6BeHHaYcOGlaOzepkIpPGO9/b55XpRpBejFvdyxb39//qsP+O/9Cki56bpBZB+/etfh6uvvjrst99+IV4M6cknn0xu8WJHP/7xj8P555/f1tOtW7cmj9NEZ9uM3z+YMGFC8ihdrvP89PmnP/3pLkeafuYznwlHHnlkuqj7QRKIiZB4M5VPIH44ihczM5VPIN1nl6/nxetxX9/D8QNy+iG5eBp61J1AX18r3dVlXr4Exo0bl68Ga20mAhIhmTDmspI42ME+P5ehG3CjxX3AhLmtIF6nJ71WTxadKEwCND3/Z7xY0bJly0IceRmnOBoojga9/PLLw2233RYWLFgQTjzxxLB3796wffv2ZJmuLnCUfrDq7jD6pAJ/CBAgQIAAgVILLFq0qGr9X7VqVdXqVjEBAgQIECBAgACBMggUJgF69tlnh4ULFya/Ch1wwAFtsYujweLV3ONI0JgI/frXv54kQOMvSHGEYEtLS5ejN9PEZ0+jSuKo0j179rRts/2D2bNnh+eff759kcdVFoijwGJyO17AylQegfhDRnxfxx894vl/TeURSE95EePuEPhixL03/zfjIdDpD5Vxfx//nxd16o1HUfveVb/SUWDbtm3rahHlBRSIo0Dioe9xeuGFF7r8/F3Arpe+S/E7XfyMH9/z8bRnpvIIxLjH+McBTM3NzeXpuJ4mR/fEnI3PQeV6McTD3seOHZt0OuZ10rxcqjCQEcGFSYDG5McRRxyRmuxz/9rXvjZJgD7xxBPJzjMmSuJh8vH8nl3tSNPyFH+fSn9f8Pa3v72rWaGpqSn5R93lAmZkLhD/ScYPRr4UZU5b0xXG92l8X8dJ7Gs6VJk3Ln4hjsmQmACLH45N+RfozXs4Jr7TBGg8D3dv1smrTJH71t+YxCRY/ELMpr+C+VwvfilKE6DxC5Efu/MZx/60Ok2AFv0Hr/7YFH2d+D0/xj/+yG2fX/Ro79u/mAAV931dilwS/8+nObhKn/EHkgB96aohRRb8Xd9mzJiR9DD+00zP6RkToHFKE53Jk3Z/0lFkkydPblfqIQECBAgQIECAAAECBAgQIECAAAECeREoTAL0xhtvDF/60pfCk7871L3S9MwzzyTFcXRges7P6dOnJ2Xr16+vtEpIy7sbWVpxRYUECBAgQIAAAQIECBAgQIAAAQIECNSEQGESoKtXrw7XXntt+NrXvlYR9gc/+EFS3v6K7PGcoXGK63ae4mGUd9xxR1KcXlCp8zKeEyBAgAABAgQIECBAgAABAgQIECBQ2wKFSYCedNJJiXRMWj7++OMd1B966KEQR4jG6T3veU/bvHhF+IMPPjisW7curFy5sq08PojJ1I0bN4ZZs2aF+fPnd5jnCQECBAgQIECAAAECBAgQIECAAAEC+RAozEWQ/vzP/zzcd999Yc2aNeFd73pXOProo5PbY489Fu68884kGuecc06YM2dOW2TiyZQXL14cLrzwwrBs2bJw//33h3jV9kceeSR5HC+wsGTJkuSky20reUCAAAECBAgQIECAAAECBAgQIECAQG4ECpMAra+vD5/97GeTkZvXXXddiKM+4y1OL3/5y8MHP/jBEEd8dp6OP/74sHz58iQBGhOlabI0jgw977zzwlFHHdV5Fc8JECBAgAABAgQIECBAgAABAgQIEMiJQGESoNF71KhRySHuZ599dvjNb34TNm/eHF7xileEcePGdRuOefPmJYfIx0PeN2zYEOLFkWbOnBnq6gpzhoBu+28mAQIECBAgQIAAAQIECBAgQIAAgaIKFCoBmgapoaEhHHTQQcktLevN/dSpU0O8mQgQIECAAAECBAgQIECAAAECBAgQKIaAIY7FiKNeECBAgAABAgQIECBAgAABAgQIECBQQUACtAKKIgIECBAgQIAAAQIECBAgQIAAAQIEiiEgAVqMOOoFAQIECBAgQIAAAQIECBAgQIAAAQIVBCRAK6AoIkCAAAECBAgQIECAAAECBAgQIECgGAISoMWIo14QIECAAAECBAgQIECAAAECBAgQIFBBQAK0AooiAgQIECBAgAABAgQIECBAgAABAgSKIdBQjG7oBQECBAgQIECAAAECBAgQGFyBxsbGqmxwxYoVValXpQQIECirgBGgZY28fhMgQIAAAQIECBAgQIAAAQIECBAogYAEaAmCrIsECBAgQIAAAQIECBAgQIAAAQIEyiogAVrWyOs3AQIECBAgQIAAAQIECBAgQIAAgRIISICWIMi6SIAAAQIECBAgQIAAAQIECBAgQKCsAhKgZY28fhMgQIAAAQIECBAgQIAAAQIECBAogYAEaAmCrIsECBAgQIAAAQIECBAgQIAAAQIEyiogAVrWyOs3AQIECBAgQIAAAQIECBAgQIAAgRIISICWIMi6SIAAAQIECBAgQIAAAQIECBAgQKCsAhKgZY28fhMgQIAAAQIECBAgQIAAAQIECBAogYAEaAmCrIsECBAgQIAAAQIECBAgQIAAAQIEyiogAVrWyOs3AQIECBAgQIAAAQIECBAgQIAAgRIISICWIMi6SIAAAQIECBAgQIAAAQIECBAgQKCsAhKgZY28fhMgQIAAAQIECBAgQIAAAQIECBAogYAEaAmCrIsECBAgQIAAAQIECBAgQIAAAQIEyiogAVrWyOs3AQIECBAgQIAAAQIECBAgQIAAgRIINJSgj7pIgAABAgRqWqCxsbFq7VuxYkXV6lYxAQIECBAgQIAAAQIE8iBgBGgeoqSNBAgQIECAAAECBAgQIECAAAECBAj0S0ACtF9sViJAgAABAgQIECBAgAABAgQIECBAIA8CEqB5iJI2EiBAgAABAgQIECBAgAABAgQIECDQLwEJ0H6xWYkAAQIECBAgQIAAAQIECBAgQIAAgTwISIDmIUraSIAAAQIECBAgQIAAAQIECBAgQIBAvwQkQPvFZiUCBAgQIECAAAECBAgQIECAAAECBPIgIAGahyhpIwECBAgQIECAAAECBAgQIECAAAEC/RJo6NdaVuq1wMiRI8OkSZN6vbwFsxEYP358iDdTOQVmzpxZzo6XvNfTp08vuUDl7ufx/dDXNo8ePTrEW1GnvnoU1aFSv9hUUilH2ZQpU8rRUb3sIDBx4sQQb2WY7N86Rrmuri4w6WhSlmfiXpZI79vPsWPHhnjLapIAzUqyi3p2794dmpubu5iruBoCMfG5Y8eOsHPnzmpUr84aFRg3blwYNmxY0jrvuRoNUpWa1dDQEMaMGRNeeOGF0NraWqWt5LfaPL4fetPm+vr6tg9Eu3btCtu3b89vkHpoeW88eqiicLNjwjvu87dt21a4vulQ1wKjRo0KI0aMSBaIsd+zZ0/XC5tTOIEJEyYk+/q4zy/DZN//YpTTQS3xM178rGcqj8Dw4cOTH7i9F8oT89jT9LtdfBxzOjG3036K/wv6O0mA9leul+vFD2ZF/lLWS4ZBXSz+k4xvlK1btw7qdm1saAViAiz+MhwnsR/aWAz21uMX4hj/+GV47969g735mt9eHt8PvWlz/FCc/iIcf2zszTo1H6wuGljkvnXR5R6LYxIsJkDZ9EhVqAXiDx9pAjR+vvZjd6HC221n4vs9fumNX4RbWlq6XbYoM+3fXoxkOsghJkCZFOXV3bt+xM/38QdPce+dV1GWikdRx9jHKf7g1Tn+A0mAOgdoUV4l+kGAAAECBAgQIECAAAECBAgQIECAwD4CEqD7kCggQIAAAQIECBAgQIAAAQIECBAgQKAoAhKgRYmkfhAgQIAAAQIECBAgQIAAAQIECBAgsI+ABOg+JAoIECBAgAABAgQIECBAgAABAgQIECiKgARoUSKpHwQIECBAgAABAgQIECBAgAABAgQI7CMgAboPiQICBAgQIECAAAECBAgQIECAAAECBIoiIAFalEjqBwECBAgQIECAAAECBAgQIECAAAEC+whIgO5DooAAAQIECBAgQIAAAQIECBAgQIAAgaIISIAWJZL6QYAAAQIECBAgQIAAAQIECBAgQIDAPgISoPuQKCBAgAABAgQIECBAgAABAgQIECBAoCgCEqBFiaR+ECBAgAABAgQIECBAgAABAgQIECCwj4AE6D4kCggQIECAAAECBAgQIECAAAECBAgQKIqABGhRIqkfBAgQIECAAAECBAgQIECAAAECBAjsIyABug+JAgIECBAgQIAAAQIECBAgQIAAAQIEiiLQUJSO6AcBAgQIECBAgAABAgQIEOgs0NjY2LnIcwIECBAomYARoCULuO4SIECAAAECBAgQIECAAAECBAgQKJOABGiZoq2vBAgQIECAAAECBAgQIECAAAECBEomIAFasoDrLgECBAgQIECAAAECBAgQIECAAIEyCUiAlina+kqAAAECBAgQIECAAAECBAgQIECgZAISoCULuO4SIECAAAECBAgQIECAAAECBAgQKJOABGiZoq2vBAgQIECAAAECBAgQIECAAAECBEomIAFasoDrLgECBAgQIECAAAECBAgQIECAAIEyCUiAlina+kqAAAECBAgQIECAAAECBAgQIECgZAISoCULuO4SIECAAAECBAgQIECAAAECBAgQKJOABGiZoq2vBAgQIECAAAECBAgQIECAAAECBEomIAFasoDrLgECBAgQIECAAAECBAgQIECAAIEyCUiAlina+kqAAAECBAgQIECAAAECBAgQIECgZAISoCULuO4SIECAAAECBAgQIECAAAECBAgQKJOABGiZoq2vBAgQIECAAAECBAgQIECAAAECBEomIAFasoDrLgECBAgQIECAAAECBAgQIECAAIEyCUiAlina+kqAAAECBAgQIECAAAECBAgQIECgZAINRe/vmjVrwhe/+MUwf/78sHjx4ord3bFjR7jpppvCgw8+GJqamsLs2bPD3Llzw6JFi0J9fX3FdRQSIECAAAEC1RFobGysSsUrVqyoSr0qJUCAAAECBAgQIECgtgUKnQBtbm4Ol1xySXj22WfDy1/+8oqR2Lx5czjnnHPChg0bkvlTpkwJq1atSm733XdfWLp0aRgxYkTFdRUSIECAAAECBAgQIECAAAECBAgQIFDbAoU+BP7zn/98kvzsLgQXX3xxkvyMI0RvvfXWcPPNN4frr78+HHrooeGee+4JV1xxRXerm0eAAAECBAgQIECAAAECBAgQIECAQA0LFDYB+t3vfjd8//vfD5MmTeqS/9FHHw0PPPBAGD16dDJSdOLEicmyBx54YLjsssuSw99XrlwZ4khSEwECBAgQIECAAAECBAgQIECAAAEC+RMoZAL0t7/9bZLAjInMt73tbV1G5a677krmnXDCCWHUqFEdlouHwh977LFh586dISZBTQQIECBAgAABAgQIECBAgAABAgQI5E+gcAnQvXv3JqM5W1pawic/+cl9EpvtQ7R27drkaTz8vdIUE6BxevjhhyvNVkaAAAECBAgQIECAAAECBAgQIECAQI0LFC4Bet1114Wf/vSn4Z3vfGc48sgju+V/+umnk/ldHSaflqcXSOq2MjMJECBAgAABAgQIECBAgAABAgQIEKg5gUJdBf4Xv/hFuPrqq8OcOXPCu971rh6xt27dmiyTJjo7rzBhwoSkKF2u8/z0+YIFC8L27dvTpx3uL7roovDmN7+5Q5kn1RcYP358GDduXPU3ZAs1IzBs2LC2tsyYMaPtsQfFF0hjP3369NDa2lr8Dvexh94PL4Hl1SKv7X5JPvtH6fueTfa2tVxjGvfYxsmTJ9dyU7WtSgLxmg3pd7QqbaJmqrV/ezEU6fu+rq4uMKmZl+egNCSNvbgPCndNbmTs2LFhzJgxmbWtMAnQHTt2hJhsrK+vTw59b2jovmvxUPk0aRmTZZWmNIEW6+5u2rZtW+hqmT179oS4szYNvkC6wxz8LdviUArEuIv9UEZg6LYt9pXt/Q96ySWvFtVq96JFi17CyfjRqlWrMq6xcnX295VdylBarfdFGezy3Mcy/a/3Gu/4Si1T7Dv23DPvhfK+BrJ+33efJcyR8xe/+MXw61//OnzoQx8Ks2bN6rHl8U0Ur/4ezxXaVfIyLR8xYkS39cVfJNJkaucFR44cGWIS1DR4AjG2cRSYkWCDZ14LW4pxjzvIGPf4A4epPAIx7jH+9rWVY87lJZe8WuSx3dVuc3zPx8n+/qXXdxkepfv72Ndqv8bK4Jm3PsaBLvE9X5bP+F7jL75CfcbP2zs1u/am+3zvhexM81JT3N/HqdI+P53Xn74UIgF6//33h29+85vhmGOOCW95y1t67bDffvuFeH7P5ubmiuuk5XHYbXfT9773vS5nNzU1hWeffbbL+WZkLzBz5szwwgsvhJ5OXZD9ltU4lALTpk0L6chv77mhjMTgb3vUqFHJoZDPPfecZEgFfu+Hl1DyapHHdle7zfHw5/jFaNOmTS8F2KPCC8RDn9PP5Zs3bw47d+4sfJ918EWB+H6Pn/G3bNmSDGApg0u196N5MYyDjWL8YyKESV6ilk0746HP8bQX4p6NZ15qiYMIp0yZkjQ3Hm2d5uXS9u+///7pwz7fFyIB+q1vfSvp+KOPPhpOO+20DgjpKM677747nHrqqckb6Otf/3qyTE8J0PgPNk7OMZQw+EOAAAECBAgQIECAAAECBAgQIEAgdwKFSIDGIbDxFpOdacIzjUR6iMTu3buTzHH74bLxghlxWr9+fYgXMuo8xfI4HXHEEZ1neU6AAAECBAgQIECAAAECBAgQIECAQA4ECpEAXbZsWZfU3/jGN8Ly5cvDwoULw9KlSzssF8tuv/32sHr16vD2t7+9w7w4xP6OO+5IyubOndthnicECBAgQIAAAQIECBAgQIAAAQIECORDoNSXJ4+jPg8++OCwbt26sHLlyg4Ru/baa8PGjRuTCyrNnz+/wzxPCBAgQIAAAQIECBAgQIAAAQIECBDIh0AhRoD2lzqeTHnx4sXhwgsvDHEUabyY0uzZs8MjjzySPB4+fHhYsmRJctLl/m7DegQIECBAgAABAgQIECBAgAABAgQIDJ1AqUeARvbjjz8+OUQ+XlXwzjvvDFdddVWS/IwjQz/3uc+Fo446auiiY8sECBAgQIAAAQIECBAgQIAAAQIECAxIoPAjQM8444wQb91N8+bNCzfeeGNyyPuGDRtCvDhSTIjW1ZU+P9wdm3kECBAgkAOBxsbGHLRSEwkQIECAAAECBAgQIFA9gcInQPtCN3Xq1BBvJgIECBAgQIAAAQIECBAgQIAAAQIEiiFgiGMx4qgXBAgQIECAAAECBAgQIECAAAECBAhUEJAArYCiiAABAgQIECBAgAABAgQIECBAgACBYghIgBYjjnpBgAABAgQIECBAgAABAgQIECBAgEAFAQnQCiiKCBAgQIAAAQIECBAgQIAAAQIECBAohoAEaDHiqBcECBAgQIAAAQIECBAgQIAAAQIECFQQkACtgKKIAAECBAgQIECAAAECBAgQIECAAIFiCDQUoxt6QYAAAQIECBDoXqCxsbH7BcwlQIBAQQSqub9bsWJF1ZSq2e6qNVrFBAgQIJALASNAcxEmjSRAgAABAgQIECBAgAABAgQIECBAoD8CEqD9UbMOAQIECBAgQIAAAQIECBAgQIAAAQK5EJAAzUWYNJIAAQIECBAgQIAAAQIECBAgQIAAgf4ISID2R806BAgQIECAAAECBAgQIECAAAECBAjkQkACNBdh0kgCBAgQIECAAAECBAgQIECAAAECBPojIAHaHzXrECBAgAABAgQIECBAgAABAgQIECCQCwEJ0FyESSMJECBAgAABAgQIECBAgAABAgQIEOiPgARof9SsQ4AAAQIECBAgQIAAAQIECBAgQIBALgQkQHMRJo0kQIAAAQIECBAgQIAAAQIECBAgQKA/AhKg/VGzDgECBAgQIECAAAECBAgQIECAAAECuRCQAM1FmDSSAAECBAgQIECAAAECBAgQIECAAIH+CEiA9kfNOgQIECBAgAABAgQIECBAgAABAgQI5EJAAjQXYdJIAgQIECBAgAABAgQIECBAgAABAgT6IyAB2h816xAgQIAAAQIECBAgQIAAAQIECBAgkAsBCdBchEkjCRAgQIAAAQIECBAgQIAAAQIECBDoj4AEaH/UrEOAAAECBAgQIECAAAECBAgQIECAQC4EGnLRSo0kQIAAAQIECBAgQIAAgSEXaGxsHPI2aAABAgQIEOirgBGgfRWzPAECBAgQIECAAAECBAgQIECAAAECuRGQAM1NqDSUAAECBAgQIECAAAECBAgQIECAAIG+CkiA9lXM8gQIECBAgAABAgQIECBAgAABAgQI5EZAAjQ3odJQAgQIECBAgAABAgQIECBAgAABAgT6KiAB2lcxyxMgQIAAAQIECBAgQIAAAQIECBAgkBsBCdDchEpDCRAgQIAAAQIECBAgQIAAAQIECBDoq0BDX1ewfN8E6uvrw7hx4/q2kqUHLDBixIgwbNiwAdejgvwI1NW99HuO91x+4pZFSxsaXvxXNnbs2NDa2ppFleogUFMCedynVbvN6fu+2tupqReCxoThw4e3KYwePTrEz3smAkUVsH97MbLpd7p4z6Sor/bK/Ur3+eJe2aeopelnvNi/+BrIMv4SoFV+1cQE6KhRo6q8FdV3FogfiNMdZud5nhdTIP1wFHs3ZsyYYnZSryoKpLGPX4ZNBIookMd9WrXbnP7oVe3tFPH1lOc+pfv72IeRI0fmuSvaTqBHAfu3jkTx/c+ko0nRn6X7fHEveqS77l/M6bRPiHa9ZO/mSID2zqnfS+3cuTNs2bKl3+tbse8CM2fODC+88ELYunVr31e2Rm4Fpk2b1rZzfPbZZ3PbDw3vu0D8kWny5MnhueeeC3v37u17BdYgUOMCedynVbvN8T0fvxht2rSpxqOneVkKTJgwIcTR/nHavHlziJ+zTQSKKlDt/Whe3GbMmJHs7+NnPCZ5iVo27YyJz4kTJ4p7Npy5qSX+wDllypSkvdu2bQvNzc0d2r7//vt3eN6XJy8dM9qXtSxLgAABAgQIECBAgAABAgQIECBAgACBHAhIgOYgSJpIgAABAgQIECBAgAABAgQIECBAgED/BCRA++dmLQIECBAgQIAAAQIECBAgQIAAAQIEciAgAZqDIGkiAQIECBAgQIAAAQIECBAgQIAAAQL9E5AA7Z+btQgQIECAAAECBAgQIECAAAECBAgQyIGABGgOgqSJBAgQIECAAAECBAgQIECAAAECBAj0T0ACtH9u1iJAgAABAgQIECBAgAABAgQIECBAIAcCDTlooyYSIECAAAECBAgQIECAAAECGQg0NjZmUMu+VaxYsWLfQiUECBCoEQEjQGskEJpBgAABAgQIECBAgAABAgQIECBAgED2AhKg2ZuqkQABAgQIECBAgAABAgQIECBAgACBGhGQAK2RQGgGAQIECBAgQIAAAQIECBAgQIAAAQLZC0iAZm+qRgIECBAgQIAAAQIECBAgQIAAAQIEakRAArRGAqEZBAgQIECAAAECBAgQIECAAAECBAhkLyABmr2pGgkQIECAAAECBAgQIECAAAECBAgQqBEBCdAaCYRmECBAgAABAgQIECBAgAABAgQIECCQvUBD9lWqkQABAgQIECBAgAABAgQIEOivQGNjY39XtR4BAgQIVBAwArQCiiICBAgQIECAAAECBAgQIECAAAECBIohIAFajDjqBQECBAgQIECAAAECBAgQIECAAAECFQQkQCugKCJAgAABAgQIECBAgAABAgQIECBAoBgCEqDFiKNeECBAgAABAgQIECBAgAABAgQIECBQQUACtAKKIgIECBAgQIAAAQIECBAgQIAAAQIEiiEgAVqMOOoFAQIECBAgQIAAAQIECBAgQIAAAQIVBCRAK6AoIkCAAAECBAgQIECAAAECBAgQIECgGAISoMWIo14QIECAAAECBAgQIECAAAECBAgQIFBBQAK0AooiAgQIECBAgAABAgQIECBAgAABAgSKISABWow46gUBAgQIECBAgAABAgQIECBAgAABAhUEJEAroCgiQIAAAQIECBAgQIAAAQIECBAgQKAYAhKgxYijXhAgQIAAAQIECBAgQIAAAQIECBAgUEFAArQCiiICBAgQIECAAAECBAgQIECAAAECBIohIAFajDjqBQECBAgQIECAAAECBAgQIECAAAECFQQkQCugKCJAgAABAgQIECBAgAABAgQIECBAoBgCEqDFiKNeECBAgAABAgQIECBAgAABAgQIECBQQaChQlmui5577rlw3XXXhXXr1oWWlpZw5JFHhnnz5oUTTzyxy37t2LEj3HTTTeHBBx8MTU1NYfbs2WHu3Llh0aJFob6+vsv1zCBAgAABAgQIECBAgAABAgQIECBAoLYFCpUA/dGPfhQ+8YlPhO3btyfq48ePD7/4xS/CN77xjfCmN70pLFmyZJ+E5ubNm8M555wTNmzYkKwzZcqUsGrVquR23333haVLl4YRI0bUdhS1jgABAgQIECBAgAABAgQIECBAgACBigKFOQT+2WefDX/3d3+XJD//7M/+LNxwww3hlltuCZdeemk4+OCDw3e+851w5ZVX7oNw8cUXJ8nP+fPnh1tvvTXcfPPN4frrrw+HHnpouOeee8IVV1yxzzoKCBAgQIAAAQIECBAgQIAAAQIECBDIh0BhEqBx1GZzc3M48MADw7nnnhsOOOCAZLTnggULwllnnZVE46677uoQlUcffTQ88MADYfTo0eGSSy4JEydOTObHOi677LJk/ZUrVyb1dljREwIECBAgQIAAAQIECBAgQIAAAQIEciFQmARoPNz92GOPTZKddXUdu3XcccclwXjmmWeSc3ymkUkToieccEIYNWpUWpzcx0PhY307d+4MMQlqIkCAAAECBAgQIECAAAECBAgQIEAgfwIdM4X5a39bi08//fTw+c9/PjnXZ1vh7x+sX78+eRRHhU6ePLlt9tq1a5PH8fD3SlNMgMbp4YcfrjRbGQECBAgQIECAAAECBAgQIECAAAECNS6Q+UWQrrrqqhAPLX/ve98b/uAP/qBX3Y/n4YyjLE899dTw8Y9/vFfr9GaheHX3NWvWhMsvvzxZPCZJ209PP/108nTSpEnti9sep+XpBZLaZnR68OUvfzns3r27U+mLT1/zmtck5xOtOFNh1QTihauGDRtWtfpVXHsC7Ud+jxs3rvYaqEVVE2hoePFf2dixY0Nra2vVtqNiAkMlkMd9WrXbXF9fn/yfr/Z2hirmtltZYPjw4W0z4imsXKi0jcMDAjUhUI19cvqdLt5Xo/6agNOIigLpPl/cK/IUtjD9bhc7GF8DWcY/8wRovIhQvODQ6173ul4nQOOh6Pfff3+micLPfe5zSVI1HsIePyRfcMEFYdGiRR1eJFu3bk2ep4nODjN/92TChAlJUbpc5/np8y9+8YshJlsrTXHU6dy5cyvNUlZFgXhKg86nNaji5lRdQwLxw1E8JYapfAJZ/nMsn54e17JAHvdpg9XmwdpOLb8+ytq2MWPGlLXr+k2gZgWquU+Ogx2qWX/NomqYuJf4NTBy5MgQb1lNmSdA+9KwPXv2hHXr1oWf/vSnyWpZfpD58Y9/HPbbb78Qrw4fR2fGJGtMRM6cOTPZ1t69e5MrxscnXe1I0y/TXSU3k4r8IUCAAIHSCHT+Ia00HddRAgQIECBAgAABAgQI5FhgQAnQU045JXz/+9/v0P1du3Ylz+Ph5u0PSe2w0O+fxGVjIjKdjjnmmPThgO+vvfba5NCouI1/+7d/C1/96lfDgw8+GJYvXx5e/epXJ22Lh860tLR0OXozTXz2dHjNZz7zmRCTuZWmV77ylR0uvFRpGWXZCsQRvd3FNdutqa1WBOKI7TjaOx4CvXnz5lpplnYMgkDcR8fD359//vkO/1MGYdM2QWBQBJqamgZlO1lupNptju/5OOL/hRdeyLLZ6qpxgThYIh0J0tzc3OUpqGq8G5pHoLAC1dj3x+92cX8f8wbxs56pPAJxfx/3+9V4XZVHMX89bX/Y+/bt25PcTvtetL+uT/vy3jweUAI0XnToqKOOCmnSs/0GK5W1n9/58ate9arwp3/6p52L+/087iTjFPHe8573hN/85jfhu9/9bvja174W4uHxcYojROP5PeMHqEpTWh4/ZHc3velNb+pydnyzxqCZBlcgjvrlPrjmQ7219iO5xX6oozH424/76Rj39j+qDX4rbJFAdQTyuE+rdpvjj9jxs161t1OdiKq1vwLxB680ARpPcxVvJgIEakegGvvkOLgh7u/jfTXqrx09LekskA6oE/fOMsV+3v6aDlnndQaUAD388MPDlVdeGf77v/+7LQLxYka//vWvwxvf+MZw0EEHtZVXehCTk/FL6yGHHBL+4i/+osMV2istP5Cyk046KUmA/uIXv2irpqcE6JYtW5JlB5JhbtuYBwQIECBAgAABAgQIECBAgAABAgQIDLrAgBKgsbVxdGW8pVM8LD4mQD/wgQ+E+HiwpjiyM47mXLx4cZgxY8Y+m43J1ji1v6LU9OnTk7L169eHBQsWJI/b/4nlcTriiCPaF3tMgAABAgQIECBAgAABAgQIECBAgEBOBOqybuc73/nOcMkll4Q5c+ZkXXW39T3wwAPh9ttvD3fffXfF5dasWZOUx3NyptPChQuTh6tXr06L2u7jYZR33HFH8txV3NtYPCBAgAABAgQIECBAgAABAgQIECCQK4HME6BnnnlmuOCCC8Jhhx02qBBpMjOOBH366ac7bDsmP2+44YakLF6cKZ3iqM+DDz44uRJ9PHS//RQvorRx48Ywa9asMH/+/PazPCZAgAABAgQIECBAgAABAgQIECBAICcCAz4Evrt+PvvssyGec3Pbtm29ukpjHJ05e/bs7qrscl5MbP7Xf/1XuP/++8Pb3/72EK8oP2/evPDYY48lIznjiVTf+ta3djjUPZ5MOR4yf+GFF4Zly5Yl68btP/LII8njeNj8kiVLkpMud7lhMwgQIECAAAECBAgQIECAAAECBAgQqFmBqiRAY9LzE5/4RPjWt77Vq8RnqrN06dLwqU99Kn3ap/uYzIyH3v/7v/97uOaaa0I8JD7e4hTP9XnuueeGE088MXne/s/xxx8fli9fniRA77zzzhBvcYojQ88777zkKvftl/eYAAECBAgQIEBgaAQaGxurtuEVK1ZUrW4VEyBAgAABAgQIDK1A5gnQ5ubmcNppp4Vf/vKXg96zESNGhLPPPju84x3vCE899VRoampKrkQ/derUbtsSR4reeOONySHv8UJKMWE6c+bMUFeX+RkCum2HmQQIECBAgAABAgQIECBAgAABAgQIZCuQeQL0oosuakt+xsPJ3/a2tyWjKWNCMY7S7G7K6ryh8UrvcQRnvPVlionSnpKlfanPsgQIECBAgAABAgQIECBAgAABAgQIDK1A5gnQH/zgB0mP4qjKeHX1KVOmDG0PbZ0AAQIECBAgQIAAAQIECBAgQIAAgdIKZHqM9549e8JPf/rTBPPd73635GdpX1Y6ToAAAQIECBAgQIAAAQIECBAgQKA2BDJNgNbX14exY8cmPYsjQE0ECBAgQIAAAQIECBAgQIAAAQIECBAYSoFME6CxI3/0R3+U9OfJJ59M7v0hQIAAAQIECBAgQIAAAQIECBAgQIDAUAlkngA9+eSTk75cffXVQ9Un2yVAgAABAgQIECBAgAABAgQIECBAgEAikHkC9Nxzzw1nnHFGuOuuu8IHP/jB0NzcjJoAAQIECBAgQIAAAQIECBAgQIAAAQJDIpD5VeDXrl0bFi9eHB544IHwT//0T+H6668PRx99dJg1a1aYNm1at52Mo0dPOumkbpcxkwABAgQIECBAoLYFGhsba7uBWkeAAAECmQtUc99/2223Zd5eFRIgUC6BzBOgH//4x8N3vvOdNsX/+7//C6tWrWp73t2DhoYGCdDugMwjQIAAAQIECBAgQIAAAQIECBAgQKBPApkfAt+nrVuYAAECBAgQIECAAAECBAgQIECAAAECVRTIfAToDTfcEHbv3t2vJo8aNapf61mJAAECBAgQIECAAAECBAgQIECAAAEClQQyT4COGzeu0naUESBAgAABAgQIECBAgAABAgQIECBAYNAFHAI/6OQ2SIAAAQIECBAgQIAAAQIECBAgQIDAYAlIgA6WtO0QIECAAAECBAgQIECAAAECBAgQIDDoApkfAr9u3bqwefPmfnXkwAMPDAcccEC/1rUSAQIECBAgQIAAAQIECBAgQIAAAQIEOgtkngD98Ic/HL7zne903k6vnn/qU58KS5cu7dWyFiJAgAABAgQIECBAgAABAgQIECBAgEBPAg6B70nIfAIECBAgQIAAAQIECBAgQIAAAQIEciuQ+QjQj3zkI+Gtb31rlyB79uwJW7ZsCU888UT49re/ndy/6U1vCl/5ylfChAkTulzPDAIECBAgQIAAAQIECBAgQIAAAQIECPRVIPME6MKFC3vdhosuuiicccYZySHzl156aVi+fHmv17UgAQIECBAgQIAAAQIECBAgQIAAAQIEehIY0kPg44jPeL7QeOGjyy+/PNxxxx09tdd8AgQIECBAgAABAgQIECBAgAABAgQI9FpgSBOgsZUjRowIr3/965MG33333b1uuAUJECBAgAABAgQIECBAgAABAgQIECDQk8CQJ0BjA1/1qlcl7bz33nt7aq/5BAgQIECAAAECBAgQIECAAAECBAgQ6LVATSRA77rrrqTBw4cP73XDLUiAAAECBAgQIECAAAECBAgQIECAAIGeBIY8ARrPAbp69eqkncccc0xP7TWfAAECBAgQIECAAAECBAgQIECAAAECvRbI/Crw3/jGN8L69eu7bcDu3bvDtm3bwpo1a8Ktt96aLDts2LDwxje+sdv1zCRAgAABAgQIECBAgAABAgQIECBAgEBfBDJPgP7Lv/xLcmX3vjQiLrtkyZLw//7f/+vrapYnQIAAAQIECBAgQIAAAQIECBAgQIBAlwKZJ0C73FIXM+bNmxfOOeec8K53vauLJRQTIECAAAECBAgQIECAAAECBAgQIECgfwKZJ0BXrFgRWlpaemxNvODRpEmTwpgxY3pc1gIECBAgQIAAAQIECBAgQIAAAQIECBDoj0DmCdDp06f3px3WIUCAAAECBAgQIECAAAECBAgQIECAQOYCmSdAu2rhCy+8EB5//PEwcuTIEJOkkydPDvHCRyYCBAgQIECAAAECBAgQIECAAAECBAhUS6CqCdC1a9eGCy64IDz00EPhqaee6tCHqVOnhtNPPz28//3vD0cffXSHeUV7ItE7NBHlPjTutbBVsa+FKAxeG9J4x/v08eBt3ZYIVF/A67r6xnELnAfHeSBbaR+j+Lj984HUa10CBPIh4D2fjzhl1co03ul9VvWqp7YFOse78/OBtL4qCdDdu3cnic/ly5eHXbt2VWzfxo0bw9VXXx2++tWvhk9/+tPJVeArLpjzwjjiNY52NQ2uwIQJE0K8mconEHeQM2fOLF/H9Tg5ugADgSIK2KcNTlQ5D45zVluZMmVKVlWphwCBHAjU19f7jJ+DOFWjif4/V0M1H3WOGzcuxFtWU1USoDGh+dnPfjZpY0xGnHjiiWHOnDlh1qxZYdu2beFXv/pV+MlPfhIefvjhEJOlH/vYx5Kd2VlnnZVVv2qmnpgA3rx5c820pwwNmThxYti+fXvYsWNHGbqrj78XGD9+fIgfjFpbW8Pzzz/PpUQC8aJ6Y8eOTeIe43/mmWeWqPe6WgaBRYsWlaGbQ95Hn9eGPAQ9NmD06NHJ6bTigvH0WvF7hIkAgXII7N27N2zZsqUcndXLRGDEiBHJRbP9fy7XCyL9bhd7HfM68dZ+ihdT7++UeQJ0zZo1yYjO2KA//uM/Dl/4whfCvHnzKrbvlltuCR/60IfCE088ET7wgQ+E0047LbkyfMWFc1oYd9SdA5bTruSm2TEBGhPPLS0tuWmzhg5coP0vQ2I/cM881RCTnjEBGve1cZ9rIkCAQH8E/O/oj9rgrhO/FMWjq+IUf+jeuXPn4DbA1ggQGDKB+HnPfnrI+Idkw+mhz+I+JPxDttH4fS5+t4tT/KGzc/wHkgCty7pXV1xxRZJ8OuSQQ8Jtt93WZfIzbvfUU08NMQk6ZsyY5Ffca6+9NuvmqI8AAQIECBAgQIAAAQIECBAgQIAAgRILZJ4AjYe1x2np0qW9Gs155JFHhve85z3JOnfeeWdy7w8BAgQIECBAgAABAgQIECBAgAABAgSyEMg0Abpnz57w6KOPJu069thje92+dNl4blATAQIECBAgQIAAAQIECBAgQIAAAQIEshLINAFaV1cXGhpePK3o1q1be93GeGGkOMVzN5oIECBAgAABAgQIECBAgAABAgQIECCQlUCmCdB4ktrDDz88adsPfvCDXrfx3nvvTZZ99atf3et1LEiAAAECBAgQIECAAAECBAgQIECAAIGeBDJNgMaNzZ8/P9nmpz71qbB+/fqeth9uv/32kF78qKurxfdYiQUIECBAgAABAgQIECBAgAABAgQIECBQQeDF49UrzOhv0QUXXBC+9rWvheeffz6ccMIJ4e/+7u/C2WefHerr6ztU2dzcHJYvXx4uvfTS0NraGuLozzPPPLPDMp4QIECAAAECBAgQIECgqAKNjY1F7Zp+ESBAgACBmhLIPAG6//77h7//+78P5557bnjqqaeSK7x/9KMfDa94xSvCwQcfHHbu3BmefPLJ8Pjjj4f03J/Dhw9PkqYjRoyoKRyNIUCAAAECBAgQIECAAAECBAgQIEAg3wKZJ0Ajx1//9V+HOXPmhHe/+91JErSpqSk89NBDya0z19y5c8MXvvCF4PD3zjKeEyBAgAABAgQIECBAgAABAgQIECAwUIGqJEBjo173uteF//mf/wlXXnllcv+zn/0s/PznPw9xtOfs2bOT28knnxziYR+dD48faKesT4AAAQIECBAgQIAAAQIECBAgQIAAgShQtQRorHzixInh/PPPjw+TKZ7rM14p3kSAAAECBAgQIECAAAECBAgQIECAAIHBEMj8KvCdG719+/a2ovbJzx/96Edt5wBtW8ADAgQIECBAgAABAgQIECBAgAABAgQIZChQtQTovffeG0499dTwh3/4hxWb+5d/+Zdhv/32C+94xzvCpk2bKi6jkAABAgQIECBAgAABAgQIECBAgAABAgMRqEoC9F//9V/DwoULw6233hp++ctfJld+b9/IvXv3hl/96lehpaUlXHfddeHoo48Oa9eubb+IxwQIECBAgAABAgQIECBAgAABAgQIEBiwQOYJ0HXr1oX3ve99YdeuXUnj3vCGN+yTAI0zvvnNb4b3vve9oa6uLjz55JPh7LPPDjExaiJAgAABAgQIECBAgAABAgQIECBAgEBWApknQC+55JKwe/fuMGPGjPD9738/3HbbbWHcuHEd2huTnqecckr48pe/HFavXh0aGhrCQw89FK699toOy3lCgAABAgQIECBAgAABAgQIECBAgACBgQhkngC97777kvY0NjaGk08+uce2nXTSSeGv/uqvkuXuvvvuHpe3AAECBAgQIECAAAECBAgQIECAAAECBHorkGkCdM+ePcnh7HHjZ555Zm/bEI477rhk2Z/97Ge9XseCBAgQIECAAAECBAgQIECAAAECBAgQ6Ekg0wTosGHDknN6xo3Gw+B7O23fvj1ZdNSoUb1dxXIECBAgQIAAAQIECBAgQIAAAQIECBDoUSDTBGg8t+dBBx2UbPSee+7pcePpAj/84Q+Th0cddVRa5J4AAQIECBAgQIAAAQIECBAgQIAAAQIDFsg0ARpb8yd/8idJo5YuXRp++ctf9tjAeBGkr371q8lyRx99dI/LW4AAAQIECBAgQIAAAQIECBAgQIAAAQK9Fcg8Afr+978/xEPZm5ubw4IFC0K8Kvyzzz7boT2tra3JuUI//OEPh9NOOy3s3bs3HHPMMX06b2iHCj0hQIAAAQIECBAgQIAAAQIECBAgQIBABYHME6CHHXZY+Od//udkU01NTeGTn/xkmDFjRhg3blw44ogjwqGHHhpGjx4dDjnkkPCP//iPoaWlJXl+zTXXhIaGhgpNVESAAAECBAgQIECAAAECBAgQIECAAIH+CWSeAI3NaGxsDN/61rfCgQce2NaqrVu3hp///Odh/fr1YceOHW3lb37zm8NPfvKTcPjhh7eVeUCAAAECBAgQIECAAAECBAgQIECAAIEsBKo25DKeC/QNb3hDiOf4vO2225LE5zPPPBPGjBkT4ijReDvuuOPCSSedlEU/1EGAAAECBAgQIECAAAECBAgQIECAAIF9BKqWAI1biucCjSM8481EgAABAgQIECBAgAABAgQIECBAgACBwRaoyiHwg90J2yNAgAABAgQIECBAgAABAgQIECBAgEAlAQnQSirKCBAgQIAAAQIECBAgQIAAAQIECBAohIAEaCHCqBMECBAgQIAAAQIECBAgQIAAAQIECFQSkACtpKKMAAECBAgQIECAAAECBAgQIECAAIFCCEiAFiKMOkGAAAECBAgQIECAAAECBAgQIECAQCWBql4FvtIGq122cePG8B//8R/h8ccfD88880yYPn16OOSQQ8Jb3/rWMG3atIqb37FjR7jpppvCgw8+GJqamsLs2bPD3Llzw6JFi0J9fX3FdRQSIECAAAECBAgQIFB8gcbGxuJ3Ug8JECBAgEDBBQqVAL3rrrvCsmXLQktLS5K4nDp1anjooYfCAw88EL797W+Hj33sY2HhwoUdQrp58+ZwzjnnhA0bNiTlU6ZMCatWrUpu9913X1i6dGkYMWJEh3U8IUCAAAECBAgQIECAAAECBAgQIEAgHwKFOQT+6aefbkt+xl9jl9YqAAA9CklEQVRpb7/99vCf//mfyf1ZZ52VJEU/85nPtCU60/BcfPHFSdn8+fPDrbfeGm6++eZw/fXXh0MPPTTcc8894YorrkgXdU+AAAECBAgQIECAAAECBAgQIECAQM4ECpMAveWWW5Ik52tf+9rw7ne/O4wcOTIJRbxfvHhxOPHEE8P27dtDXC6dHn300WR06OjRo8Mll1wSJk6cmMw68MADw2WXXZaMIl25cmVobm5OV3FPgAABAgQIECBAgAABAgQIECBAgECOBAqTAF2zZk3Cftxxx1XkjyM84/TYY4+1zY+HzMfphBNOCKNGjUoep3/iofDHHnts2LlzZ4hJUBMBAgQIECBAgAABAgQIECBAgAABAvkTKEwCNB6qfsMNN4QFCxZUjMKmTZuS8kmTJrXNX7t2bfI4TY62zfj9g5gAjdPDDz/8+xJ3BAgQIECAAAECBAgQIECAAAECBAjkSaAwF0GKh7ofcMABFe13797dNorzyCOPbFsmnjc0Tu2Tom0z25WnF0hqP6/94127doXW1tb2RW2P9+7d2/bYAwIECBAgQIAAAQIECBAgQIAAAQIEBlegMAnQ7ti+/OUvh6eeeirEc3uecsopbYtu3bo1edxVAnTChAnJ/HS5thU7PTj66KPDjh07OpW++DReeOn000+vOE9h9QRi7NL4VW8raq5FgWHDhoX999+/FpumTVUWmDFjRpW3oHoCBIos4H9HvqI7derUfDVYawkQGJBAfX29z/gDEszvyv4/5zd2A235uHHjQrxlNRU+ARqv6B5vdXV14W//9m/bzvUZR2bGiyLFafz48RU9U+iukpsVV1JIgAABAgQIECBAgAABAgQI1LzAokWLqtbGVatWVa1uFRMg0HeBQidAr7rqqnDNNdckyc9PfOIT4aijjmoTignRePX3lpaWLkdvponPESNGtK1X6cErX/nK5GJJlebFJGo8RN40eAINDQ0hJridfmDwzGthSzHucfRnPB1FPO2FqTwCMe4x/va15Ym5nhKohoB9SDVUs60zfn6Po8DiFP/Xd3UKqmy3qjYCBGpBII+f8f1fGdgrJ93ncxyYY97WTr/bxXbv2bNnn7zO8OHD+92lQiZA4xskHnr+3e9+N8Tk5YUXXphc6b2z0n777Rfi+T2bm5s7z0qep+Vjx46tOD8tvOmmm9KH+9w3NTWF5557bp9yBdUTmDlzZoinLejp1AXVa4Gah0Jg2rRpSRIsbtt7bigiMHTbHDVqVJg8eXKIF7vzw8fQxcGWCeRdwP+O2o9gPL1R+rn8+eef73IAQu33RAsJEOirQPyMl7f9dN7a29eYVHv5MWPGhIkTJ+Yu7tV2KXr98fo+U6ZMSboZByymebm03wM5JUJhrgKfYkScv/mbv0mSn/FD0uWXX14x+RmXjwnQOHUGTQp/92fLli3Jw/jF2kSAAAECBAgQIECAAAECBAgQIECAQP4ECpUAjQnLc889N6xZsya87GUvC1/60pfCq1/96i6jMn369GTe+vXrKy6Tlh9xxBEV5yskQIAAAQIECBAgQIAAAQIECBAgQKC2BQqTAI3nBDn//PPD448/HubMmZMkP1/+8pd3q79w4cJk/urVq/dZLg6xv+OOO5LyuXPn7jNfAQECBAgQIECAAAECBAgQIECAAAECtS9QmAToLbfcEh555JHksPZLL700OVdET/wLFiwIBx98cFi3bl1YuXJlh8WvvfbasHHjxjBr1qwwf/78DvM8IUCAAAECBAgQIECAAAECBAgQIEAgHwKFuAhSvFp7PNw9TvFEw6effnqX+ocddli4+uqrk/nx6lKLFy9OLpK0bNmycP/994fZs2cnidT4OF5dasmSJcmVpbus0AwCBAgQIECAAAECBAgQIECAAAECBGpWoBAJ0CeeeKLDhYz27NnTJfju3bs7zDv++OPD8uXLQ0yA3nnnncktLhBHhp533nnhqKOO6rC8JwQIECBAgAABAgQIECBAgAABAgQI5EegEAnQww8/PNx77739Vp83b1648cYbk0PeN2zYEOLFkWbOnBnq6gpzhoB+21iRAAECBAgQIECAAAECBAgQIECAQJ4FCpEAzSoAU6dODfFmIkCAAAECBAgQIECAAAECBAgQIECgGAKGOBYjjnpBgAABAgQIECBAgAABAgQIECBAgEAFAQnQCiiKCBAgQIAAAQIECBAgQIAAAQIECBAohoAEaDHiqBcECBAgQIAAAQIECBAgQIAAAQIECFQQkACtgKKIAAECBAgQIECAAAECBAgQIECAAIFiCEiAFiOOekGAAAECBAgQIECAAAECBAgQIECAQAUBCdAKKIoIECBAgAABAgQIECBAgAABAgQIECiGQEMxuqEXBAgQIECAAAECBAiUWaCxsbHM3dd3AgQIECBAoBsBI0C7wTGLAAECBAgQIECAAAECBAgQIECAAIF8C0iA5jt+Wk+AAAECBAgQIECAAAECBAgQIECAQDcCEqDd4JhFgAABAgQIECBAgAABAgQIECBAgEC+BSRA8x0/rSdAgAABAgQIECBAgAABAgQIECBAoBsBCdBucMwiQIAAAQIECBAgQIAAAQIECBAgQCDfAhKg+Y6f1hMgQIAAAQIECBAgQIAAAQIECBAg0I2ABGg3OGYRIECAAAECBAgQIECAAAECBAgQIJBvgYZ8N1/rCRAgQKCaAo2NjVWrfsWKFVWrW8UECBAog4B9dBmirI8ECBAgQIBAFgJGgGahqA4CBAgQIECAAAECBAgQIECAAAECBGpSQAK0JsOiUQQIECBAgAABAgQIECBAgAABAgQIZCEgAZqFojoIECBAgAABAgQIECBAgAABAgQIEKhJAQnQmgyLRhEgQIAAAQIECBAgQIAAAQIECBAgkIWABGgWiuogQIAAAQIECBAgQIAAAQIECBAgQKAmBSRAazIsGkWAAAECBAgQIECAAAECBAgQIECAQBYCEqBZKKqDAAECBAgQIECAAAECBAgQIECAAIGaFJAArcmwaBQBAgQIECBAgAABAgQIECBAgAABAlkINGRRiToIECBAgAABAgQIECBAgAABAtUQOOWUU6pRrToJECiRgBGgJQq2rhIgQIAAAQIECBAgQIAAAQIECBAom4AEaNkirr8ECBAgQIAAAQIECBAgQIAAAQIESiQgAVqiYOsqAQIECBAgQIAAAQIECBAgQIAAgbIJSICWLeL6S4AAAQIECBAgQIAAAQIECBAgQKBEAhKgJQq2rhIgQIAAAQIECBAgQIAAAQIECBAom4AEaNkirr8ECBAgQIAAAQIECBAgQIAAAQIESiTQUKK+DklXGxoawoQJE4Zk22Xe6MiRI0N9fX2ZCUrX97q6l37P8Z7LR/izilP6Xh83blw+Oq6VBAjUpEBW+6Sa7Fw/GlWLHiNGjGjryZgxY8KoUaPanntAgACBWhOoxf1orRl1156YS4kTx+6Uijcv/W4Xexb/72cZfwnQKr9eYlKm/Ye1Km9O9b8XiDvL9gkxMMUXGDZsWFsnvefaKGr6QVZxSmOfVX01jaZxBAhUTeAtb3lLVeq+5ZZbqlJvtSutxX1q+892w4cPD62trdVmUD8BAgT6LVCt/yuxQXn939IXzHSfX4v/j/rSD8v2TSD9bhfXisnQ9s/7VtO+S0uA7muSacnOnTvDli1bMq1TZd0LzJw5M2zdujW5db+kuUUSmDZtWkh/JXzuueeK1LXC9iWrOMURQJMnTw6bNm0Ke/fuLayXjhEgkE+BrPZ1g937Wmx3HAUyduzYhOL5558P8XO2iQABAmUUqMV9dNZxiCP9J06cGMrQ16zt8lxfPJp3ypQpSRdaWlpCc3Nzh+7sv//+HZ735clLx4z2ZS3LEiBAgAABAgQIECBAgAABAgQIECBAIAcCEqA5CJImEiBAgAABAgQIECBAgAABAgQIECDQPwEJ0P65WYsAAQIECBAgQIAAAQIECBAgQIAAgRwISIDmIEiaSIAAAQIECBAgQIAAAQIECBAgQIBA/wQkQPvnZi0CBAgQIECAAAECBAgQIECAAAECBHIgIAGagyBpIgECBAgQIECAAAECBAgQIECAAAEC/RNo6N9q1iJAgAABAgQIECBAgEDfBBobG/u2gqUJECBAgAABAhkIGAGaAaIqCBAgQIAAAQIECBAgQIAAAQIECBCoTQEJ0NqMi1YRIECAAAECBAgQIECAAAECBAgQIJCBgARoBoiqIECAAAECBAgQIECAAAECBAgQIECgNgUkQGszLlpFgAABAgQIECBAgAABAgQIECBAgEAGAhKgGSCqggABAgQIECBAgAABAgQIECBAgACB2hSQAK3NuGgVAQIECBAgQIAAAQIECBAgQIAAAQIZCEiAZoCoCgIECBAgQIAAAQIECBAgQIAAAQIEalNAArQ246JVBAgQIECAAAECBAgQIECAAAECBAhkICABmgGiKggQIECAAAECBAgQIECAAAECBAgQqE0BCdDajItWESBAgAABAgQIECBAgAABAgQIECCQgYAEaAaIqiBAgAABAgQIECBAgAABAgQIECBAoDYFJEBrMy5aRYAAAQIECBAgQIAAAQIECBAgQIBABgISoBkgqoIAAQIECBAgQIAAAQIECBAgQIAAgdoUkACtzbhoFQECBAgQIECAAAECBAgQIECAAAECGQhIgGaAqAoCBAgQIECAAAECBAgQIECAAAECBGpTQAK0NuOiVQQIECBAgAABAgQIECBAgAABAgQIZCDQkEEdqiBAgACBIRRobGwcwq3bNAECBAgQIECAAAECBAgQqG0BI0BrOz5aR4AAAQIECBAgQIAAAQIECBAgQIDAAAQkQAeAZ1UCBAgQIECAAAECBAgQIECAAAECBGpbQAK0tuOjdQQIECBAgAABAgQIECBAgAABAgQIDEBAAnQAeFYlQIAAAQIECBAgQIAAAQIECBAgQKC2BSRAazs+WkeAAAECBAgQIECAAAECBAgQIECAwAAEJEAHgGdVAgQIECBAgAABAgQIECBAgAABAgRqW0ACtLbjo3UECBAgQIAAAQIECBAgQIAAAQIECAxAQAJ0AHhWJUCAAAECBAgQIECAAAECBAgQIECgtgUaart5A2vdtm3bwkc/+tEwc+bMcOGFF3ZZ2Y4dO8JNN90UHnzwwdDU1BRmz54d5s6dGxYtWhTq6+u7XM8MAgQIECBAgAABAt0JNDY2dje7Zufltd01C6phBAgQIECAwJAKFDYB2traGi666KLwyCOPhIaGrru5efPmcM4554QNGzYkgZgyZUpYtWpVcrvvvvvC0qVLw4gRI4Y0SDZOgAABAgQIECBAgAABAgQIECBAgED/BAp5CHxLS0v4h3/4h/DDH/6wR5WLL744SX7Onz8/3HrrreHmm28O119/fTj00EPDPffcE6644ooe67AAAQIECBAgQIAAAQIECBAgQIAAAQK1KVC4BGg8jP2ss84Kt912W6ir6757jz76aHjggQfC6NGjwyWXXBImTpyYROnAAw8Ml112WXL4+8qVK0Nzc3NtRk+rCBAgQIAAAQIECBAgQIAAAQIECBDoVqD7DGG3q9bezO9973vhvPPOC7/97W9DHNH5kY98pNtG3nXXXcn8E044IYwaNarDsvFQ+GOPPTbs3LkzxCSoiQABAgQIECBAgAABAgQIECBAgACB/AkUKgG6adOmcMABB4Tzzz8/XHrppWHy5MndRmTt2rXJ/JgsrTTFBGicHn744UqzlREgQIAAAQIECBAgQIAAAQIECBAgUOMCXV8dqMYbXql5CxcuDG95y1u6vehR+/Wefvrp5OmkSZPaF7c9TsvTCyS1zej0ICZbd+3a1an0xaevf/3rwxFHHFFxnsLqCYwcOTI5hUH1tqDmWhNof8qLCRMm1FrztKeCQFZxqq+vT2ofN25cha0oIkCAAAECBAgQIFAsgaw+R9eySnox6zL0tZbjMNhtS7/bxe3GC5JnGf9CJUD322+/PsVm69atyfJporPzyil0ulzn+enza665JuzYsSN92uE+Jj+POeaYDmWeVF8gJkDjzVQ+gWHDhoWxY8eWr+M57HHWccq6vhySajIBAgQIECBAgEAJBMr0ubdMfS3BS7dPXYwJ0HjLaipUArQvKHv37g3bt29PVhk/fnzFVdPRRF0lNyuupJAAAQIEeiWwaNGiXi1nIQIECBAgQIAAAQIECBAgMBCB0iZA4+Gy8ervLS0tXY7eTBOfPWWcr7zyyrBnz56KcYhXlI/nJjUNnkA89+u2bdu6jOvgtcSWBlNg4sSJyWkPWltbQ1NT02Bu2rYIECBAgAABAgQIECAwaAJlyDHEIzrj6M8y9HXQXjg52NDw4cNDOkgx5uvirf0UL1je36m0CdAIFg+Zj+f3bG5uruiXlvc05Po1r3lNxfVjYUzEpCNNu1zIjMwFYkI6TWBnXrkKa1IgJj7TSexTCfcECBAgQIAAAQIECBRNoAzfd9JzQZahr0V7fWbVn6zzOoW6CnxfkdNzhqaJzs7rb9myJSnq6WryndfznAABAgQIECBAgAABAgQIECBAgACB2hAodQJ0+vTpSRTWr19fMRppuau4V+RRSIAAAQIECBAgQIAAAQIECBAgQKDmBUqdAF24cGESoNWrV+8TqHiRpDvuuCMpnzt37j7zFRAgQIAAAQIECBAgQIAAAQIECBAgUPsCpU6ALliwIBx88MFh3bp1YeXKlR2ide2114aNGzeGWbNmhfnz53eY5wkBAgQIECBAgAABAgQIECBAgAABAvkQKPVFkIYNGxYWL14cLrzwwrBs2bJw//33h9mzZ4dHHnkkeRyvPrVkyZIQlzMRIECAAAECBAgQIECAAAECBAgQIJA/gVKPAI3hOv7448Py5cvDzJkzw5133hmuuuqqJPkZR4Z+7nOfC0cddVT+oqrFBAgQIECAAAECBAgQIECAAAECBAgkAoUeARqTm/fee2+PoZ43b1648cYbk0PeN2zYEOLFkWJCtK6u9PnhHu0sQIAAAQIECBAgQIAAAQIECBAgQKCWBQqdAO0r/NSpU0O8mQgQIECAAAECBAgQIECAAAECBAgQKIaAIY7FiKNeECBAgAABAgQIECBAgAABAgQIECBQQUACtAKKIgIECBAgQIAAAQIECBAgQIAAAQIEiiEgAVqMOOoFAQIECBAgQIAAAQIECBAgQIAAAQIVBCRAK6AoIkCAAAECBAgQIECAAAECBAgQIECgGAISoMWIo14QIECAAAECBAgQIECAAAECBAgQIFBBQAK0AooiAgQIECBAgAABAgQIECBAgAABAgSKIdBQjG7oBQECBAgQIECAAAECBAgQIECAQC0KNDY2VqVZK1asqEq9Ki2egBGgxYupHhEgQIAAAQIECBAgQIAAAQIECBAg8HsBCVAvBQIECBAgQIAAAQIECBAgQIAAAQIECisgAVrY0OoYAQIECBAgQIAAAQIECBAgQIAAAQISoF4DBAgQIECAAAECBAgQIECAAAECBAgUVkACtLCh1TECBAgQIECAAAECBAgQIECAAAECBCRAvQYIECBAgAABAgQIECBAgAABAgQIECisgARoYUOrYwQIECBAgAABAgQIECBAgAABAgQINCAgQIAAAQIECBAgQIAAAQIECBDIh0BjY2NVGrpixYqq1KtSArUgYARoLURBGwgQIECAAAECBAgQIECAAAECBAgQqIqABGhVWFVKgAABAgQIECBAgAABAgQIECBAgEAtCEiA1kIUtIEAAQIECBAgQIAAAQIECBAgQIAAgaoISIBWhVWlBAgQIECAAAECBAgQIECAAAECBAjUgoAEaC1EQRsIECBAgAABAgQIECBAgAABAgQIEKiKgARoVVhVSoAAAQIECBAgQIAAAQIECBAgQIBALQhIgNZCFLSBAAECBAgQIECAAAECBAgQIECAAIGqCDRUpVaVEiBAgMA+Ao2NjfuUKSBAgAABAgQIECBAgAABAgSqK2AEaHV91U6AAAECBAgQIECAAAECBAgQIECAwBAKSIAOIb5NEyBAgAABAgQIECBAgAABAgQIECBQXQEJ0Or6qp0AAQIECBAgQIAAAQIECBAgQIAAgSEUkAAdQnybJkCAAAECBAgQIECAAAECBAgQIECgugISoNX1VTsBAgQIECBAgAABAgQIECBAgAABAkMoIAE6hPg2TYAAAQIECBAgQIAAAQIECBAgQIBAdQUaqlu92qNAXZ0882C/EoYNG8Z9sNFraHveczUUDE0hQIAAAQIECBAgQCAXAnn8HpXHNufixTBEjWwfz6zzOhKgVQ7qyJEjw+TJk6u8FdV3Fhg/fnyIN1P5BOJOcsaMGeXruB4TIECAAAECBAgQIEBgAAJ5/B6VxzYPIESlWnXs2LEh3rKaJECzkuyinl27doVNmzZ1MVdxNQRiwrmlpSVs3769GtWrs0YFJk6cGOrr60Nra2toamqq0VZqFgECBAgQIECAAAECBGpTYNGiRbXZsG5aJd/SDU4OZw0fPrxtMFvM68Rb+2nKlCntn/bpsQRon7j6vvDevXvDjh07+r6iNQYksHv3bu4DEszfyjHxmU7ec6mEewIECBAgQIAAAQIECBRXwHe/4sZ2z549meZ1nJyyuK8VPSNAgAABAgQIECBAgAABAgQIECBQegEJ0NK/BAAQIECAAAECBAgQIECAAAECBAgQKK6ABGhxY6tnBAgQIECAAAECBAgQIECAAAECBEovIAFa+pcAAAIECBAgQIAAAQIECBAgQIAAAQLFFZAALW5s9YwAAQIECBAgQIAAAQIECBAgQIBA6QUkQEv/EgBAgAABAgQIECBAgAABAgQIECBAoLgCDcXtmp4RIECAAAECBAgQIECAAAECBAgUVaCxsbFqXVuxYkXV6lbx4AsYATr45rZIgAABAgQIECBAgAABAgQIECBAgMAgCUiADhK0zRAgQIAAAQIECBAgQIAAAQIECBAgMPgCEqCDb26LBAgQIECAAAECBAgQIECAAAECBAgMkoAE6CBB2wwBAgQIECBAgAABAgQIECBAgAABAoMvIAE6+Oa2SIAAAQIECBAgQIAAAQIECBAgQIDAIAlIgA4StM0QIECAAAECBAgQIECAAAECBAgQIDD4AhKgg29uiwQIECBAgAABAgQIECBAgAABAgQIDJJAwyBtx2YIECCQqUBjY2Om9amMAAECBAgQIECAAAECBAgQKKaAEaDFjKteESBAgAABAgQIECBAgAABAgQIECDwOwEJUC8DAgQIECBAgAABAgQIECBAgAABAgQKKyABWtjQ6hgBAgQIECBAgAABAgQIECBAgAABAhKgXgMECBAgQIAAAQIECBAgQIAAAQL/v717AbaqqhsAvnjKQwXBB2oqmpjmSKQJaoomRhS9dLKXRqNJljWlZlZmOiqSWqOpU5ZmZuXbmTJtwEBgqDQZzDfq+Ba00RTwBaI8Pv/7m81cuOfcey7s87jn/NbMhXv23mettX/r7n32+e+11yJAoGkFBECbtmntGAECBAgQIECAAAECBAgQIECAAAECAqD+BggQIECAAAECBAgQIECAAAECBAgQaFoBAdCmbVo7RoAAAQIECBAgQIAAAQIECBAgQICAAKi/AQIECBAgQIAAAQIECBAgQIAAAQIEmlZAALRpm9aOESBAgAABAgQIECBAgAABAgQIECAgAOpvgAABAgQIECBAgAABAgQIECBAgACBphUQAG3aprVjBAgQIECAAAECBAgQIECAAAECBAgIgPobIECAAAECBAgQIECAAAECBAgQIECgaQUEQJu2ae0YAQIECBAgQIAAAQIECBAgQIAAAQICoP4GCBAgQIAAAQIECBAgQIAAAQIECBBoWgEB0KZtWjtGgAABAgQIECBAgAABAgQIECBAgIAAqL8BAgQIECBAgAABAgQIECBAgAABAgSaVqB30+5ZF3ZsxYoV6eabb07z589PS5YsSSNGjEijRo1KEyZMSL169epCTq256THHHFOVHb/qqquqkq9MCRAgQIAAAQIECBAgQIAAAQL1EKhWDCX2RRylfIu2fAB06dKl6YQTTkgLFy7MlIYMGZKmT5+e/dx5553pzDPPTH379i0vaA0BAgQIECBAgAABAgQIECBAgAABAg0r0PKPwJ9zzjlZ8HPMmDHptttuS7fccku6/vrr03vf+940d+7cdMkllzRs46kYAQIECBAgQIAAAQIECBAgQIAAAQIdC7R0AHTBggVp3rx5qX///mnKlClp0KBBmdb222+fLrzwwuzx92nTpqXXX3+9Y0VrCRAgQIAAAQIECBAgQIAAAQIECBBoSIGWDoDOmTMna5SDDz449evXb50GikfhR48end5+++0UQVCJAAECBAgQIECAAAECBAgQIECAAIHuJ9DSAdCHH344a7F4/L1UigBopAceeKDUassIECBAgAABAgQIECBAgAABAgQIEGhwgZaeBOn555/Pmmfw4MElmylfnk+QVHKjdxf+73//S2vWrCm5evXq1alnz5aOM5d0qWThxrj16NGDeyXItiFAgAABAgQIECBAgAABAgTaCWxMTKJdZjVa0B3r3Jambf2Ljuu0dAD0zTffzJzzQGdb9Ph98803zxbl262/Pn89bty4tGLFivzlOv+fd9556fDDD19nmReVCWyzzTaVbVhiq8022yzFj0SAAAECBAgQIECAAAECBAgQ6KrAxsQkulpWUdt3xzqX2/eBAwem+CkqtWwANHpmvvXWW5ljuUDZpptumq0vF9wsqhG6ez7Tp0/v7rug/t1QwN9dN2w0VSZAgAABAgQIECBAgECLC/guW58/gJYNgEa32pj9ffny5WV7b+aBz759+3bYOvvuu282WVKpjaJ3aZ5PqfWWFS8Q7bVq1arsp/jc5dioAtHu0UU+hqOIycuk1hGI83mfPn2ydi83HEnraLTOnsbxnn8+xzl/5cqVrbPz9jT17t07O+e/8847NFpIINq9V69e2R7HZ71zfgs1/ru7uskmm6Q45qMji9Q6Aq7xW6et19/TON/HeV88ZX2Z5n6df7eLvYzr+7jOb5vis2BDU8sGQANsyy23TDG+5+uvv17SL1/eWZfbK6+8suT7Y+GSJUvS4sWLy663oniBYcOGpWXLlqXOhi4ovmQ51lNgq622yj4gow6OuXq2RO3L7tevX9piiy2y860vRbX3r1eJEfSOz/FIcWH86quv1qsqyq2DQBzzEQR3vq8Dfh2LjOGp8uvyuE53w7OOjVHjouN4j2v8uL6PDixS6wjE47zR/nGN55zfOu0eezpgwIA0aNAg7d5azZ7d7BoyZEi21/HUdh6Xyxm23Xbb/Ncu/9/Ss/PkX5zWB80VX3vttezXuMiWCBAgQIAAAQIECBAgQIAAAQIECBDofgItHQDdeuutsxZ76qmnSrZcvnyPPfYoud5CAgQIECBAgAABAgQIECBAgAABAgQaW6ClA6Axe3ukmTNntmul6GI/a9asbPmoUaParbeAAAECBAgQIECAAAECBAgQIECAAIHGF2jpAOh+++2Xhg8fnh5//PE0bdq0dVrrmmuuSa+88kraaaed0pgxY9ZZ5wUBAgQIECBAgAABAgQIECBAgAABAt1DoKUnQYrBlCdPnpzOOOOMNHXq1HTXXXelESNGpAcffDD7PSZYOPXUU7NBl7tHc6olAQIECBAgQIAAAQIECBAgQIAAAQJtBVq6B2hAjB07Nl100UXZrIKzZ89Ol19+eRb8jJ6hP//5z9PIkSPbevmdAAECBAgQIECAAAECBAgQIECAAIFuJNDSPUDzdvrgBz+YbrrppuyR94ULF6aYHGnYsGGpZ8+Wjw/nRP4nQIAAAQIECBAgQIAAAQIECBAg0C0FBEDbNNvQoUNT/EgECBAgQIAAAQIECBAgQIAAAQIECDSHgC6OzdGO9oIAAQIECBAgQIAAAQIECBAgQIAAgRICAqAlUCwiQIAAAQIECBAgQIAAAQIECBAgQKA5BARAm6Md7QUBAgQIECBAgAABAgQIECBAgAABAiUEBEBLoFhEgAABAgQIECBAgAABAgQIECBAgEBzCAiANkc72gsCBAgQIECAAAECBAgQIECAAAECBEoICICWQLGIAAECBAgQIECAAAECBAgQIECAAIHmEBAAbY52tBcECBAgQIAAAQIECBAgQIAAAQIECJQQEAAtgWIRAQIECBAgQIAAAQIECBAgQIAAAQLNISAA2hztaC8IECBAgAABAgQIECBAgAABAgQIECghIABaAsUiAgQIECBAgAABAgQIECBAgAABAgSaQ0AAtDna0V4QIECAAAECBAgQIECAAAECBAgQIFBCoMead1OJ5RYRIECgWwl8/OMfTwsXLky9evVK999/f7equ8oSINB1gfvuuy8dffTR2Rs/+9nPpilTpnQ9E+8gQKBbCZx99tnpxhtvzOr8u9/9Lo0ePbpb1V9lCRDousC+++6bli9fnrbZZpt0xx13dD0D7yBAoFsJzJw5M5144olZnY877ri1vxexE72LyEQeBAgQqLfA22+/nd555520evXqeldF+QQI1EAgjvU45iOtWrWqBiUqggCBegvEsZ4f9z7v690ayidQG4E45uMnrvUlAgSaXyD6aOaf9UVf43sEvvn/fuwhAQIECBAgQIAAAQIECBAgQIAAgZYVEABt2aa34wQIECBAgAABAgQIECBAgAABAgSaX0AAtPnb2B4SIECAAAECBAgQIECAAAECBAgQaFkBAdCWbXo7ToAAAQIECBAgQIAAAQIECBAgQKD5BQRAm7+N7SEBAgQIECBAgAABAgQIECBAgACBlhXo8e4MS2tadu/tOAECTSMwd+7ctGzZstSzZ880fvz4ptkvO0KAQGmBJUuWpLvvvjtbuf3226e99tqr9IaWEiDQNAILFixIzz33XLY/o0ePTkOGDGmafbMjBAiUFpgxY0aKmaD79euXDjnkkNIbWUqAQNMIvPjii+nee+/N9meXXXZJu+22W2H7JgBaGKWMCBAgQIAAAQIECBAgQIAAAQIECBBoNAGPwDdai6gPAQIECBAgQIAAAQIECBAgQIAAAQKFCQiAFkYpIwIECBAgQIAAAQIECBAgQIAAAQIEGk1AALTRWkR9CBAgQIAAAQIECBAgQIAAAQIECBAoTEAAtDBKGREgQIAAAQIECBAgQIAAAQIECBAg0GgCvRutQupDgACBUgKvvPJKuvHGG9OTTz6ZYma4rbfeOu28887pC1/4Qtpqq61KvaXsstmzZ6cHHnig7Pott9wyHXXUUWXXW0GAQHUEHn300XTTTTelZ599Ng0cODCb2f3QQw9NMQNkV9OKFSvSzTffnObPn59ixvgRI0akUaNGpQkTJqRevXp1NTvbEyBQJYH4TP7HP/6RFi1alFavXp123HHHtP/++6ePfvSjXSpx2bJl6YorrujwPRMnTky77rprh9tYSYBA9QSqcZwWee1QvT2XM4HWE3jooYfS3//+94p2/IADDkj77bdfp9tu7DlEALRTYhsQIFBvgTlz5qSpU6em5cuXZ4GLoUOHpnvuuSfNmzcv/fWvf00/+MEP0rhx4yqu5i233JK9v9wbItgiAFpOx3IC1RGIYOXFF1+cZb7pppumt99+O/3nP//Jbnycd955ae+996644KVLl6YTTjghLVy4MHvPkCFD0vTp07OfO++8M5155pmpb9++FednQwIEiheImxTf//7307333ptlvvnmm2f/P/bYY2nGjBnZ5/sFF1yQ+vfvX1HhTzzxRHbTo6ON4yaIAGhHQtYRqK5A0cdpkdcO1d1zuRNoPYFnnnkm/fnPf65ox+P7fSUB0I09hwiAVtQcNiJAoF4Czz///Nrg5zHHHJMFJjfZZJMUX5z+8Ic/ZD8RHNltt93SDjvsUFE1H3/88Wy773znOynyWj9tttlm6y/ymgCBKgo8+OCD6ZJLLsmCkhGcPOigg9LKlSvTX/7yl2z5Kaeckq699to0bNiwimpxzjnnZMHPMWPGpJ/85Cdp0KBBKc4lP/7xj9PcuXPX5llRZjYiQKAqAr/85S+z4Ofw4cPT6aefnt73vvdl5URvrrPPPjvdd9996dJLL02nnnpqReXnn+377LNPip7jpVL0BJcIEKifQJHHadHXDvVTUTKB5hQYOXJkdqOz3N7FE5m33357GjBgQDrkkEPKbbbO8o09hwiArsPpBQECjSZw6623Zj0/DzvssHTssceurV4ELidPnpyee+65FD1EY7vo8dVZeumll9Jrr72W4i7TkUce2dnm1hMgUAOBq6++Oq1ZsyYdffTRaezYsVmJffr0yY7RF154IevVFcHQb3zjG53WZsGCBVnv8Og1NmXKlNSvX7/sPdtvv3268MIL0xFHHJGmTZuWjj/++ORmR6ecNiBQFYF4hC2e4OjZs2cW7IwhbfK0++67p3PPPTdNmjQp3Xbbbenb3/529uUoX1/u//xLUQQ/P/3pT5fbzHICBOooUORxWuS1Qx1JFE2gaQViSJv4KZVieLsrr7wyWxWdFXbaaadSm7VbtrHnkJ7tcrSAAAECDSSQPxoXPcJKpejhFSm6w1eS8pNm3tOkkvfYhgCB6glEICSGs4j0sY99rF1B+bIIhESv0M5S3BCJdPDBB68NfmYL3v0nHoUfPXp09nh9BEElAgTqIxA9t1atWpU9udE2+JnXJpbF+N5xY+Spp57KF3f4f34d4PO9QyYrCdRVoKjjtOhrh7qiKJxACwrE01qLFy9Ohx9+eDrwwAMrFtjYc4gAaMXUNiRAoB4C8VjsDTfcUHZMkDhxRho8eHBF1Vs/ABoBlTyPijKwEQEChQo88sgjWZAjhrDYbrvt2uUdvcGip+arr76a9fhut8F6Cx5++OFsSX5zZL3VWQA0lnU0Edr67/GaAIFiBeJGRPQA/dnPflYy4/hsjmM+UiWf77F9BEp79+69dtK0eNojhsuRCBBoDIEij9Oirx0aQ0gtCLSGQIzzHfN5RMeEr3/96xXvdBHnEI/AV8xtQwIE6iEQj7qXCopEXeIkmPfi2nPPPSuqXh4AjfeedNJJ2fhj0QslAiz77rtvinFB4/F4iQCB2gjE2JyROgpyxLrXX389G9ezsxnhO8svLyefIKk2e6kUAgTaCvTo0SNtscUWbRet83vMGhsTocX4vTF8RWfp2WefTe+88072qF2MFxyTLsTjdfGIfTx+95WvfCWNHz++s2ysJ0CgigJFHqedfdbHbnTl2qGKuy1rAgTaCMSkxjEGeKQYvi4mPq00FXEO0QO0Um3bESDQcAK/+c1v0qJFi7IvRxMnTqyofnm3+T/+8Y9Z8DN6l8Xjcm+99VaaNWtWNuZYvk1FGdqIAIGNEnjzzTez9+eByVKZ5bND59uW2iZflm9TLr+u5JXn6X8CBGonEOP+XnbZZVmB0TMkgqWdpfzmZowL/tvf/jZ7T0yGFEHWZ96dhTYetYsJEyUCBOonUORx2tlnfeylz/v6tbWSCZQTiN6fcYMyOhyNGzeu3GYllxdxDtEDtCSthQQINLrA9ddfn+Inenecdtpp7cb6K1X/uFiKL1aRYlzB733veykmSokUy88666wUE6hMnTo1XX755dmjdNlK/xAgUDWBGMcrUkcTEuV3h+NGRUdp9erV2c2MjvLL8/JobEeS1hGoj0B8KTr55JPT0qVLs+EqKp3MKL9xGeeR+AwfNWpUtgMxhmj0Bv3FL36R/va3v2XD6VQ602x9BJRKoHkFijxOi7x2aF5xe0ag8QRi+JtIn/nMZ7r8XbuIc4gAaOP9TagRgZYRiMfblixZUnJ/Y/KDCG6WShGcjB6csf70009PI0eOLLVZu2UR7IxH415++eXsy1HbXiXxmP3ZZ5+djjrqqBR3l2JSlgMOOKBdHhYQIFCswMCBA7MM43xQLuXByhgSo6MU54Q4zuPxmvw962+fL+/bt+/6q7wmQKCOAtF785RTTkn//e9/0/vf//7sM7nS6nz1q1/NepLEI/Nth82Jz/kjjjgi6wUagdA//elP6ZBDDqk0W9sRIFCgQJHHaZHXDgXuoqwIEOhAIL5jP/bYY6lXr16p0hucbbMr4hwiANpW1O8ECNRU4KGHHkrf/e53S5Z56623thsTMMb3ikfYYmywCF6cccYZ2UzPJTMosTCCIzHRSvyUSttss03aa6+90vz587PJFARASylZRqBYgS233DLLMCYsKZdi/M9I+ReectvF8sgvxvfM37P+tvnySvJa/71eEyBQHYGYlOyHP/xhdtx+6EMfSlOmTKnoeM9rEz0/99hjj/xlu/8PO+ywrCfo008/naKneLkbrO3eaAEBAoUJFHmcFn3tUNhOyogAgbIC8f0+0sEHH7xBc24UcQ4p3b2qbJWtIECAQHEC8QUkenSV+mnbOzNKjKBFPLIewc8Y0yceZ4uTZ9Fp6623zrKMx/AkAgSqL5B/ickDk6VKzIOjHU2akr+vs/y6kleep/8JEKieQIy/feKJJ2af8zE8TcwMX/QNirjBGSl6mudjB1Zvj+RMgMCGCHTlOO3ssz7K93m/Ia3gPQSqIxDDWMX3+EjxZEY1UiXnED1AqyEvTwIEKhKIMbpmzpzZ6bZxAROzsz/55JPpPe95T7rgggvK9uLsKLPocv/vf/87DRgwIB155JElN33ppZey5VGORIBA9QXymw7RazN6effp02edQl999dW0ePHirMfWiBEj1llX6kWe31NPPZWN97f+NrE8Uke9xdZ/j9cECFRHIHqDxGd6pGOOOSYde+yxG1TQTTfdlE2qMGHChDR8+PB2ebz44ovZsriBGj1IJAIEai9Q5HGaf9YXde1Qew0lEmgtgRheLm5AbrvttukDH/jABu18EecQPUA3iN6bCBColUBMYBCPxUXwM2Zr//Wvf71Bwc+ob4w3GrPDXnrppenZZ59ttwsRZHn44Yez5XvuuWe79RYQIFC8QIzXt/vuu6c33ngj3X333e0KmD17dlq1alW2Tdy86CzlM0qWurkSj75Gb7NI+SQpneVnPQEC1RGIG5LR2zOe+IjP+Q0Nfkbt4ni/5ppr0tVXX12ysv/85z+z5T7bS/JYSKAmAkUep0VfO9QEQCEEWlgghr6LVElnhnJMRZxDBEDL6VpOgEBDCETvkAcffDAb1y++KMUEB5Wkf/3rX2nGjBkpxvvKUwQ8Bg8enCKo+vvf/z6tXLkyX5XNHH3++ednk6d8+MMfzoIta1f6hQCBqgp86UtfyvK/6qqr1hm7M3pkX3fdddm69Xttx0QpcYzfcccd69Rtv/32y3qAxUDr06ZNW2ddBEhieIuddtopjRkzZp11XhAgUDuBmIzsoosuyj6PjzvuuDRx4sSKCi933H/kIx/J3h83OOKGadt0zz33pOg1EulrX/ta21V+J0CghgIbepyWuqaPam/ItUMNd1dRBAi0EViwYEH2auedd26ztPSv1fys7/FuIGBN6WItJUCAQH0F4gvS4YcfvjYgEjPGlUu77rpr1rszX//5z38+m0l28uTJadKkSfnibIKjk08+OfvSFeMJjh8/PpuJbu7cuWnRokUpTsoRaM3HEFn7Rr8QIFA1gejh+c1vfjM98sgj2QzO8SUpblDEnd4IWMZNialTp64zccn06dPTueeemx2/c+bMWaducTzHJGmRb+QVd5vjRspdd92VPWIfYwiPHDlynfd4QYBA7QTiZkQ80RGpo8/2WB8TIh144IHxayp33MexftJJJ6V77703226fffZJ8fPEE0+k6EUeKc4xecAkW+AfAgRqKrChx2m5a/oNuXao6Q4rjACBtQLxnf7ll19OZ511Vjr00EPXLi/1SzU/640BWkrcMgIEGkIgem+2nRglLnTKpba9OcttE8tjdtnLLrssXXzxxVmw5YYbbsg279+/f4rJFyI4Wsljth2VYR0BAl0TiABIDE0RPcJigPQIjkSK5Z/73OfS8ccfv07ws7Pcx44dm+UVQdMIfuQBkBgbMIIkgp+dCVpPoLoC999//9oCOvpsj41i6IrOUpwrYizROHdce+21KXp9xk+kHXbYIRtHPHqHSwQI1E+g6OO06GuH+skomUBzC8TneAxFF6mSHqDlNIo4h+gBWk7XcgIEml4gJleJwdNjQoT4ghSz0ksECNRXIG5mxCOs8YBKHJcbOxt09CCN4zwmTBg2bJjjvL7Nq3QCVReIc8gLL7yQli5dmnbZZZe06aabVr1MBRAg0DWBoo/Toq8durY3tiZAoNYCG3oOEQCtdUspjwABAgQIECBAgAABAgQIECBAgACBmgno7lQzagURIECAAAECBAgQIECAAAECBAgQIFBrAQHQWosrjwABAgQIECBAgAABAgQIECBAgACBmgkIgNaMWkEECBAgQIAAAQIECBAgQIAAAQIECNRaQAC01uLKI0CAAAECBAgQIECAAAECBAgQIECgZgICoDWjVhABAgQIECBAgAABAgQIECBAgAABArUWEACttbjyCBAgQIAAAQIECBAgQIAAAQIECBComYAAaM2oFUSAAAECBAgQIECAAAECBAgQIECAQK0FBEBrLa48AgQIECBAgAABAgQIECBAgAABAgRqJiAAWjNqBREgQIAAAQIECBAgQIAAAQIECBAgUGsBAdBaiyuPAAECBAgQIECAAAECBAgQIECAAIGaCQiA1oxaQQQIECBAgAABAgQIECBAgAABAgQI1FpAALTW4sojQIAAAQIECBAgQIAAAQIECBAgQKBmAgKgNaNWEAECBAgQIECAAAECBAgQIECAAAECtRYQAK21uPIIECBAgAABAgQIECBAgAABAgQIEKiZgABozagVRIAAAQIECBAgQIAAAQIECBAgQIBArQUEQGstrjwCBAgQIECAAAECBAgQIECAAAECBGom0LtmJSmIAAECBAgQIECAQB0FXnnllfTkk092qQZ777136t3bJXOX0GxMgAABAgQIEGgwAVdzDdYgqkOAAAECBAgQIFAdgdtvvz0dddRRXcr85ZdfTkOHDu3Se2xMgAABAgQIECDQWAICoI3VHmpDgAABAgQIECBQJYGBAwemHXfcsWTuffr0Sf369UtvvvlmeuaZZ7JthgwZkvr3719yewsJECBAgAABAgS6j0CPNe+m7lNdNSVAgAABAgQIECBQHYE33ngjHXTQQem+++5Lffv2TTNmzEhjx46tTmFyJUCAAAECBAgQqJmASZBqRq0gAgQIECBAgACBRhVYuXJlOvLII7PgZ9TxiiuuEPxs1MZSLwIECBAgQIBAFwUEQLsIZnMCBAgQIECAAIHmE/jWt76Vpk+fnu3Y6aefniZNmtR8O2mPCBAgQIAAAQItKuAR+BZteLtNgAABAgQIECDw/wI//elP02mnnZa9+OIXv5iuvfba1KNHDzwECBAgQIAAAQJNIiAA2iQNaTcIECBAgAABAgS6LnDddddlM8PHsPj7779/mjVrVjYZUtdz8g4CBAgQIECAAIFGFRAAbdSWUS8CBAgQIECAAIGqCsydOzeNHz8+rVixIu28887p7rvvTltttVVVy5Q5AQIECBAgQIBA7QUEQGtvrkQCBAgQIECAAIE6Czz66KPpgAMOSEuWLEmDBg1Kd911V9pjjz3qXCvFEyBAgAABAgQIVEPAJEjVUJUnAQIECBAgQIBAwwq89NJL6ROf+EQW/Ozdu3e6+eabBT8btrVUjAABAgQIECCw8QICoBtvKAcCBAgQIECAAIFuIrBs2bL0qU99Kj399NNZjX/1q1+lww47rJvUXjUJECBAgAABAgQ2REAAdEPUvIcAAQIECBAgQKDbCaxevTp9+ctfTvPmzcvq/qMf/ShNnjy52+2HChMgQIAAAQIECHRNoHfXNrc1AQIECBAgQIAAge4pcNJJJ6Vbbrklq/wnP/nJdOyxx6YHHnggLV++PMUs8KXSdtttl3bcccdSqywjQIAAAQIECBDoJgImQeomDaWaBAgQIECAAAECGycwdOjQtHjx4i5lcuqpp6bzzz+/S++xMQECBAgQIECAQGMJeAS+sdpDbQgQIECAAAECBAgQIECAAAECBAgQKFBAD9ACMWVFgAABAgQIECBAgAABAgQIECBAgEBjCegB2ljtoTYECBAgQIAAAQIECBAgQIAAAQIECBQoIABaIKasCBAgQIAAAQIECBAgQIAAAQIECBBoLAEB0MZqD7UhQIAAAQIECBAgQIAAAQIECBAgQKBAAQHQAjFlRYAAAQIECBAgQIAAAQIECBAgQIBAYwkIgDZWe6gNAQIECBAgQIAAAQIECBAgQIAAAQIFCgiAFogpKwIECBAgQIAAAQIECBAgQIAAAQIEGktAALSx2kNtCBAgQIAAAQIECBAgQIAAAQIECBAoUEAAtEBMWREgQIAAAQIECBAgQIAAAQIECBAg0FgCAqCN1R5qQ4AAAQIECBAgQIAAAQIECBAgQIBAgQICoAViyooAAQIECBAgQIAAAQIECBAgQIAAgcYSEABtrPZQGwIECBAgQIAAAQIECBAgQIAAAQIEChQQAC0QU1YECBAgQIAAAQIECBAgQIAAAQIECDSWgABoY7WH2hAgQIAAAQIECBAgQIAAAQIECBAgUKCAAGiBmLIiQIAAAQIECBAgQIAAAQIECBAgQKCxBARAG6s91IYAAQIECBAgQIAAAQIECBAgQIAAgQIFBEALxJQVAQIECBAgQIAAAQIECBAgQIAAAQKNJSAA2ljtoTYECBAgQIAAAQIECBAgQIAAAQIECBQoIABaIKasCBAgQIAAAQIECBAgQIAAAQIECBBoLAEB0MZqD7UhQIAAAQIECBAgQIAAAQIECBAgQKBAgf8D+sSI7LCVixMAAAAASUVORK5CYII=" width="672" /></p>
<p>What about <span class="math inline">\(f_Z(z) = 0.7f_{X_1}(z) + 0.3f_{X_2}(z)\)</span>?</p>
<p><span class="pagebreak"></span></p>
</div>
<div id="models-for-count-data-refresher" class="section level2" data-short-title="Count Data">
<h2><span class="header-section-number">4.2</span> Models for Count Data (refresher)</h2>
<p>Recall that the Poisson<span class="math inline">\((\lambda)\)</span> distribution is useful for modeling count data.</p>
<p><span class="math display">\[
f(x) = \frac{\lambda^x \exp\{-\lambda\}}{x!}, \quad x = 0, 1, 2, \dots
\]</span>
Where <span class="math inline">\(X =\)</span> number of events occuring in a fixed period of time or space.</p>
<p>When the mean <span class="math inline">\(\lambda\)</span> is low, then the data consists of mostly low values (i.e. <span class="math inline">\(0, 1, 2\)</span>, etc.) and less frequently higher values.</p>
<p>As the mean count increases, the skewness goes away and the distribution becomes approximately normal.</p>
<p>With the Poisson distribution, <span class="math display">\[E[X] = Var X = \lambda.\]</span></p>

<div class="example">
<span id="exm:unnamed-chunk-29" class="example"><strong>Example 4.3  </strong></span>
</div>

<p><br /><br /><br /><br /></p>

<div class="example">
<p><span id="exm:unnamed-chunk-30" class="example"><strong>Example 4.4  </strong></span>The Colorado division of Parks and Wildlife has hired you to analyze their data on the number of fish caught in Horsetooth resevoir by visitors. Each visitor was asked
- How long did you stay?
- How many fish did you catch?
- Other questions: How many people in your group, were children in your group, etc.</p>
<p>Some visiters do not fish, but there is not data on if a visitor fished or not. Some visitors who did fish did not catch any fish.</p>
Note, this is modified from <a href="https://stats.idre.ucla.edu/r/dae/zip/" class="uri">https://stats.idre.ucla.edu/r/dae/zip/</a>.
</div>

<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1">fish &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;https://stats.idre.ucla.edu/stat/data/fish.csv&quot;</span>)</a></code></pre></div>
<p><span class="pagebreak"></span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co"># with zeroes</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">ggplot</span>(fish) <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(count), <span class="dt">binwidth =</span> <span class="dv">1</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAJACAYAAABMocy1AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N0NsB1leQfwJ7k3N59wQwIhgeFTIjAqDYQSyhQQUgSKUkvV6ghoRKqDRZEylA6FUKBYPwqCVCxQI7UwdmCKVGLoFCGAwhShKDRoCQQw4ggSEhLy/VXepeea3Jx777mbc2727P525nrP2d13931/z7Ke+8/u2WGb35zCRIAAAQIECBAgQIAAAQIECBAgQIAAgRIKDC/hmAyJAAECBAgQIECAAAECBAgQIECAAAECmYAA1IFAgAABAgQIECBAgAABAgQIECBAgEBpBQSgpS2tgREgQIAAAQIECBAgQIAAAQIECBAgIAB1DBAgQIAAAQIECBAgQIAAAQIECBAgUFoBAWhpS2tgBAgQIECAAAECBAgQIECAAAECBAgIQB0DBAgQIECAAAECBAgQIECAAAECBAiUVkAAWtrSGhgBAgQIECBAgAABAgQIECBAgAABAgJQxwABAgQIECBAgAABAgQIECBAgAABAqUVEICWtrQGRoAAAQIECBAgQIAAAQIECBAgQICAANQxQIAAAQIECBAgQIAAAQIECBAgQIBAaQUEoKUtrYERIECAAAECBAgQIECAAAECBAgQICAAdQwQIECAAAECBAgQIECAAAECBAgQIFBaAQFoaUtrYAQIECBAgAABAgQIECBAgAABAgQICEAdAwQIECBAgAABAgQIECBAgAABAgQIlFags7Qja+OBLVu2LFavXt3GI2is6+PGjYuddtopW3np0qWxZs2axhpai0CbCUyYMCE2b94c6Tg3ESijwOjRo2P8+PHZ0JYvXx4rV64s4zCNiUB0d3fHiBEj4tVXX6VBoJQCXV1dMXHixGxs6VyezukmAmUUGDt2bKS/R19++eUyDs+YCERHR0dMmjQpk0hZS1n+Fp0yZUru6roCNDedhgQIECBAgAABAgQIECBAgAABAgQIFF1AAFr0CukfAQIECBAgQIAAAQIECBAgQIAAAQK5BQSguek0JECAAAECBAgQIECAAAECBAgQIECg6AIC0KJXSP8IECBAgAABAgQIECBAgAABAgQIEMgtIADNTachAQIECBAgQIAAAQIECBAgQIAAAQJFFxCAFr1C+keAAAECBAgQIECAAAECBAgQIECAQG4BAWhuOg0JECBAgAABAgQIECBAgAABAgQIECi6gAC06BXSPwIECBAgQIAAAQIECBAgQIAAAQIEcgsIQHPTaUiAAAECBAgQIECAAAECBAgQIECAQNEFBKBFr5D+ESBAgAABAgQIECBAgAABAgQIECCQW0AAmptOQwIECBAgQIAAAQIECBAgQIAAAQIEii4gAC16hfSPAAECBAgQIECAAAECBAgQIECAAIHcAgLQ3HQaEiBAgAABAgQIECBAgAABAgQIECBQdAEBaNErpH8ECBAgQIAAAQIECBAgQIAAAQIECOQWEIDmptOQAAECBAgQIECAAAECBAgQIECAAIGiCwhAi14h/SNAgAABAgQIECBAgAABAgQIECBAILeAADQ3nYYECBAgQIAAAQIECBAgQIAAAQIECBRdQABa9ArpHwECBAgQIECAAAECBAgQIECAAAECuQUEoLnpNCRAgAABAgQIECBAgAABAgQIECBAoOgCAtCiV0j/CBAgQIAAAQIECBAgQIAAAQIECBDILdCZu6WGBHIKzJo1q9+Wc+bM6Xe5hQQIECBAgAABAgQIECBAgAABAgQaFXAFaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUQEBaKNS1iNAgAABAgQIECBAgAABAgQIECBAoO0EBKBtVzIdJkCAAAECBAgQIECAAAECBAgQIECgUYHORle03tAJDB8+PMaMGTN0OyzYnqo89oKVQneaJJD+m06TY7tJoDZTOIERI0b09Kmrqys2b97c894LAmUS6OzsjKp/TitTPY1lW4GOjo6emel499mlh8OLkgmkzyvDhg1zjJesrobzW4F0fNemdG53Po8QgNaOiAL9rvrBufPOOxeoGrpCoHkCju3mWdpScQVGjhwZ6cdEoMwCzudlrq6x1QRSQJR+TATKLOB8XubqGltNIP2DlmNdAFo7Hgr1e/369fHrX/+6UH0ays5UeexD6WxfQycwYcKE7Iq4pUuXDt1O7YnAEAqMHj06xo8fn+1xxYoVsXLlyiHcu10RGDqB7u7uSFc8v/rqq0O3U3siMIQCKfCcOHFitsdVq1bF8uXLh3DvdkVg6ATGjh0b48aNi5dffnnodmpPBIZQIF1YN2nSpGyPa9eujbL8LTplypTcir4DNDedhgQIECBAgAABAgQIECBAgAABAgQIFF1AAFr0CukfAQIECBAgQIAAAQIECBAgQIAAAQK5BQSguek0JECAAAECBAgQIECAAAECBAgQIECg6AIC0KJXSP8IECBAgAABAgQIECBAgAABAgQIEMgtIADNTachAQIECBAgQIAAAQIECBAgQIAAAQJFFxCAFr1C+keAAAECBAgQIECAAAECBAgQIECAQG4BAWhuOg0JECBAgAABAgQIECBAgAABAgQIECi6gAC06BXSPwIECBAgQIAAAQIECBAgQIAAAQIEcgsIQHPTaUiAAAECBAgQIECAAAECBAgQIECAQNEFBKBFr5D+ESBAgAABAgQIECBAgAABAgQIECCQW0AAmptOQwIECBAgQIAAAQIECBAgQIAAAQIEii4gAC16hfSPAAECBAgQIECAAAECBAgQIECAAIHcAgLQ3HQaEiBAgAABAgQIECBAgAABAgQIECBQdAEBaNErpH8ECBAgQIAAAQIECBAgQIAAAQIECOQWEIDmptOQAAECBAgQIECAAAECBAgQIECAAIGiCwhAi14h/SNAgAABAgQIECBAgAABAgQIECBAILeAADQ3nYYECBAgQIAAAQIECBAgQIAAAQIECBRdQABa9ArpHwECBAgQIECAAAECBAgQIECAAAECuQUEoLnpNCRAgAABAgQIECBAgAABAgQIECBAoOgCAtCiV0j/CBAgQIAAAQIECBAgQIAAAQIECBDILSAAzU2nIQECBAgQIECAAAECBAgQIECAAAECRRcQgBa9QvpHgAABAgQIECBAgAABAgQIECBAgEBuAQFobjoNCRAgQIAAAQIECBAgQIAAAQIECBAouoAAtOgV0j8CBAgQIECAAAECBAgQIECAAAECBHILCEBz02lIgAABAgQIECBAgAABAgQIECBAgEDRBQSgRa+Q/hEgQIAAAQIECBAgQIAAAQIECBAgkFtAAJqbTkMCBAgQIECAAAECBAgQIECAAAECBIouIAAteoX0jwABAgQIECBAgAABAgQIECBAgACB3AIC0Nx0GhIgQIAAAQIECBAgQIAAAQIECBAgUHQBAWjRK6R/BAgQIECAAAECBAgQIECAAAECBAjkFhCA5qbTkAABAgQIECBAgAABAgQIECBAgACBogsIQIteIf0jQIAAAQIECBAgQIAAAQIECBAgQCC3gAA0N52GBAgQIECAAAECBAgQIECAAAECBAgUXUAAWvQK6R8BAgQIECBAgAABAgQIECBAgAABArkFBKC56TQkQIAAAQIECBAgQIAAAQIECBAgQKDoAgLQoldI/wgQIECAAAECBAgQIECAAAECBAgQyC0gAM1NpyEBAgQIECBAgAABAgQIECBAgAABAkUXEIAWvUL6R4AAAQIECBAgQIAAAQIECBAgQIBAbgEBaG46DQkQIECAAAECBAgQIECAAAECBAgQKLqAALToFdI/AgQIECBAgAABAgQIECBAgAABAgRyCwhAc9NpSIAAAQIECBAgQIAAAQIECBAgQIBA0QUEoEWvkP4RIECAAAECBAgQIECAAAECBAgQIJBbQACam05DAgQIECBAgAABAgQIECBAgAABAgSKLiAALXqF9I8AAQIECBAgQIAAAQIECBAgQIAAgdwCAtDcdBoSIECAAAECBAgQIECAAAECBAgQIFB0AQFo0SukfwQIECBAgAABAgQIECBAgAABAgQI5BYQgOam05AAAQIECBAgQIAAAQIECBAgQIAAgaILCECLXiH9I0CAAAECBAgQIECAAAECBAgQIEAgt4AANDedhgQIECBAgAABAgQIECBAgAABAgQIFF1AAFr0CukfAQIECBAgQIAAAQIECBAgQIAAAQK5BQSguek0JECAAAECBAgQIECAAAECBAgQIECg6AIC0KJXSP8IECBAgAABAgQIECBAgAABAgQIEMgtIADNTachAQIECBAgQIAAAQIECBAgQIAAAQJFFxCAFr1C+keAAAECBAgQIECAAAECBAgQIECAQG4BAWhuOg0JECBAgAABAgQIECBAgAABAgQIECi6gAC06BXSPwIECBAgQIAAAQIECBAgQIAAAQIEcgsIQHPTaUiAAAECBAgQIECAAAECBAgQIECAQNEFBKBFr5D+ESBAgAABAgQIECBAgAABAgQIECCQW0AAmptOQwIECBAgQIAAAQIECBAgQIAAAQIEii4gAC16hfSPAAECBAgQIECAAAECBAgQIECAAIHcAgLQ3HQaEiBAgAABAgQIECBAgAABAgQIECBQdAEBaNErpH8ECBAgQIAAAQIECBAgQIAAAQIECOQWEIDmptOQAAECBAgQIECAAAECBAgQIECAAIGiCwhAi14h/SNAgAABAgQIECBAgAABAgQIECBAILeAADQ3nYYECBAgQIAAAQIECBAgQIAAAQIECBRdQABa9ArpHwECBAgQIECAAAECBAgQIECAAAECuQUEoLnpNCRAgAABAgQIECBAgAABAgQIECBAoOgCnUXv4Pb0b9WqVXHBBRfE5MmT49JLL+1zU2vXro077rgjHnvssVi6dGlMnTo1pk2bFieddFJ0dHTUbZenTd0NmUmAAAECBAgQIECAAAECBAgQIECAQMsEShuAbt68OS6//PJ46qmnorOz72EuW7YszjnnnFi8eHGGPGHChLjnnnuyn4cffjhmz54dXV1dWxUgT5utNuANAQIECBAgQIAAAQIECBAgQIAAAQJDIlDKW+BXr14dX/ziF+NHP/rRgIhXXHFFFn7OmDEj7r777rjrrrviO9/5TrztbW+LBx98MK677rpttpGnzTYbMYMAAQIECBAgQIAAAQIECBAgQIAAgZYLlC4ATbexn3nmmTF37twYPrz/4T399NPx6KOPxujRo+PKK6+M7u7uDHzPPfeMq6++Orv9fd68ebFixYqeQuRp09PYCwIECBAgQIAAAQIECBAgQIAAAQIEhlSg/4RwSLuy/Tv7z//8z/j85z8fv/71ryNd0Xn++ef3u9H58+dny4899tgYNWrUVuumW+GPOOKIWLduXaQQtDblaVNr6zcBAgQIECBAgAABAgQIECBAgAABAkMrUKoA9LXXXos99tgjLrroovjyl78cu+yyS7+aCxYsyJansLTelALQND355JM9i/O06WnsBQECBAgQIECAAAECBAgQIECAAAECQyrQ99OBhrQbzdnZzJkz40/+5E/6fejRlnt66aWXsrfjx4/fcnbP69r82gOS0oI8bXo2uMWLc889N5YvX77FnN++/MhHPhLHHXfcb2dU7FW6+tZEoEwCI0aMiPRgNsd2mapqLFsKbPmVM2PGjImRI0duudhrAqURSA/WHDZsmPN5aSpqIL0F0vFdm9Idcv09TLa2nt8E2lGgo6PD+bwdC6fPuQTS36P+Fo0oVQC66667DupgWLlyZbZ+Lejs3XjnnXfOZtXWS29qrwfTpvd20/v0XaXpitV60wknnFDpPx794VzvqDCvDALpg5aJQNkF0h/L/mAue5WNz2cVx0AVBNLnFp9dqlDpao/R+bza9a/K6J3P36p0qW6BH8zBu2nTplizZk3WZKeddqrbdNy4cdn8tWvXZr/ztKm7YTMJECBAgAABAgQIECBAgAABAgQIEBgSgVJdAToYsXS7Xnr6++rVq6MWcPZuX5vf1dWVLcrTpvc2a++/973vxcaNG2tvt/qdbpV9+eWXt5pXpTdVHnuV6lylsaYrxtN/16+//nqVhm2sFRJIt0l2d3dnI16xYkWsWrWqQqM31CoJpLuD0hXOfd3FUyULYy2nwJa3SaZzeTqnmwiUUSB9Zc/YsWPjN7/5TRmHZ0wEIuVXu+22WyaRsq1ly5aVQmX33XfPPY7KBqBJLN0yn77fs6//Y6/NTyfG2pSnTa3tlr/7u10/HZgpmK3qlK60NREoo4Bju4xVNaYkkAL+2pReO9ZrGn6XTaB2rDvGy1ZZ46kJ1I7x9N75vKbidxkFase683kZq2tMSWDL73R2Pn/rmKjsLfBp+LUQshZ0vkXy2/+tPaRoy6fJ52nz2y16RYAAAQIECBAgQIAAAQIECBAgQIDAUApUOgCdNGlSZr1o0aK65rX5Bx98cM/yPG16GntBgAABAgQIECBAgAABAgQIECBAgMCQClQ6AJ05c2aGfe+9926Dni6Fv++++7L506ZN61mep01PYy8IECBAgAABAgQIECBAgAABAgQIEBhSgUoHoEceeWTsu+++sXDhwpg3b95W8LfeemssWbIk9tlnn5gxY0bPsjxtehp7QYAAAQIECBAgQIAAAQIECBAgQIDAkApU+iFI6Uthzz777Lj00kvjqquuikceeSSmTp0aTz31VPY6PQXxwgsv3OrLY/O0GdKK2hkBAgQIECBAgAABAgQIECBAgAABAj0Clb4CNCkcc8wxcc0118TkyZPj/vvvjxtvvDELP9OVoV/5ylfikEMO6cGqvcjTptbWbwIECBAgQIAAAQIECBAgQIAAAQIEhk6g1FeApqDyoYceGlDz0EMPjdtvvz275X3x4sWRHnSUAtHhw/vOh/O0GbAjViBAgAABAgQIECBAgAABAgQIECBAoKkCpQ5ABys1ceLESD+DmfK0Gcz2rUuAAAECBAgQIECAAAECBAgQIECAQH6Bvi9xzL9NLQkQIECAAAECBAgQIECAAAECBAgQIFAIAQFoIcqgEwQIECBAgAABAgQIECBAgAABAgQItEJAANoKVdskQIAAAQIECBAgQIAAAQIECBAgQKAQAgLQQpRBJwgQIECAAAECBAgQIECAAAECBAgQaIWAALQVqrZJgAABAgQIECBAgAABAgQIECBAgEAhBASghSiDThAgQIAAAQIECBAgQIAAAQIECBAg0AoBAWgrVG2TAAECBAgQIECAAAECBAgQIECAAIFCCAhAC1EGnSBAgAABAgQIECBAgAABAgQIECBAoBUCAtBWqNomAQIECBAgQIAAAQIECBAgQIAAAQKFEBCAFqIMOkGAAAECBAgQIECAAAECBAgQIECAQCsEBKCtULVNAgQIECBAgAABAgQIECBAgAABAgQKISAALUQZdIIAAQIECBAgQIAAAQIECBAgQIAAgVYICEBboWqbBAgQIECAAAECBAgQIECAAAECBAgUQkAAWogy6AQBAgQIECBAgAABAgQIECBAgAABAq0QEIC2QtU2CRAgQIAAAQIECBAgQIAAAQIECBAohIAAtBBl0AkCBAgQIECAAAECBAgQIECAAAECBFohIABthaptEiBAgAABAgQIECBAgAABAgQIECBQCAEBaCHKoBMECBAgQIAAAQIECBAgQIAAAQIECLRCQADaClXbJECAAAECBAgQIECAAAECBAgQIECgEAIC0EKUQScIECBAgAABAgQIECBAgAABAgQIEGiFgAC0Faq2SYAAAQIECBAgQIAAAQIECBAgQIBAIQQEoIUog04QIECAAAECBAgQIECAAAECBAgQINAKAQFoK1RtkwABAgQIECBAgAABAgQIECBAgACBQggIQAtRBp0gQIAAAQIECBAgQIAAAQIECBAgQKAVAgLQVqjaJgECBAgQIECAAAECBAgQIECAAAEChRAQgBaiDDpBgAABAgQIECBAgAABAgQIECBAgEArBASgrVC1TQIECBAgQIAAAQIECBAgQIAAAQIECiEgAC1EGXSCAAECBAgQIECAAAECBAgQIECAAIFWCAhAW6FqmwQIECBAgAABAgQIECBAgAABAgQIFEJAAFqIMugEAQIECBAgQIAAAQIECBAgQIAAAQKtEBCAtkLVNgkQIECAAAECBAgQIECAAAECBAgQKISAALQQZdAJAgQIECBAgAABAgQIECBAgAABAgRaISAAbYWqbRIgQIAAAQIECBAgQIAAAQIECBAgUAgBAWghyqATBAgQIECAAAECBAgQIECAAAECBAi0QkAA2gpV2yRAgAABAgQIECBAgAABAgQIECBAoBACAtBClEEnCBAgQIAAAQIECBAgQIAAAQIECBBohYAAtBWqtkmAAAECBAgQIECAAAECBAgQIECAQCEEBKCFKINOECBAgAABAgQIECBAgAABAgQIECDQCgEBaCtUbZMAAQIECBAgQIAAAQIECBAgQIAAgUIICEALUQadIECAAAECBAgQIECAAAECBAgQIECgFQIC0Fao2iYBAgQIECBAgAABAgQIECBAgAABAoUQEIAWogw6QYAAAQIECBAgQIAAAQIECBAgQIBAKwSaHoDeeOONcd5558XTTz/dcH+vuOKKOOqoo+ILX/hCw22sSIAAAQIECBAgQIAAAQIECBAgQIAAgYEEmh6A3nXXXXHttdfG888/P9C+e5bPnz8/HnnkkUGFpj2NvSBAgAABAgQIECBAgAABAgQIECBAgEAfAp19zB+S2Rs3boyFCxfGT3/602x/Y8aMGZL92gkBAgQIECBAgAABAgQIECBAgAABAtUQ2K4A9JRTTokf/OAHW0mtX78+e//Hf/zHMXx4/xeYpnU3bdrU0/7www/vee0FAQIECBAgQIAAAQIECBAgQIAAAQIEtldguwLQv//7v49DDjkkaqHnlp2pN2/L5b1fv/Od74z3v//9vWd7T4AAAQIECBAgQIAAAQIECBAgQIAAgdwC2xWAHnTQQXHDDTfEj3/8454OzJs3L37xi1/EySefHHvvvXfP/HovRowYEWPHjo399tsvPvShD8Uuu+xSbzXzCBAgQIAAAQIECBAgQIAAAQIECBAgkEtguwLQtMezzjor+6ntPd0WnwLQz3zmM5FemwgQIECAAAECBAgQIECAAAECBAgQILCjBLY7AO3d8TPOOCOOOuqoOPDAA3sv8p4AAQIECBAgQIAAAQIECBAgQIAAAQJDKtD0APTDH/7wkA7AzggQIECAAAECBAgQIECAAAECBAgQINCXQNMD0C139Morr8T//u//xqpVq2LDhg1bLqr7+u1vf3tMnTq17jIzCRAgQIAAAQIECBAgQIAAAQIECBAgMFiBlgSgKfT867/+6/jud7/bUPBZ6/Ts2bPjsssuq731mwABAgQIECBAgAABAgQIECBAgAABAtsl0PQAdMWKFXHqqafGM888s10d05gAAQIECBAgQIAAAQIECBAgQIAAAQLbK9D0APTyyy/vCT/T7ewf+chHYt99943JkyfHsGHD+u3vAQcc0O9yCwkQIECAAAECBAgQIECAAAECBAgQIDAYgaYHoD/84Q+z/R966KFx7733xoQJEwbTH+sSIECAAAECBAgQIECAAAECBAgQIECgaQLDm7alNze0cePG+OlPf5pt8hOf+ITws5m4tkWAAAECBAgQIECAAAECBAgQIECAwKAFmhqAdnR0xNixY7NOpCtATQQIECBAgAABAgQIECBAgAABAgQIENiRAk0NQNNAfu/3fi8bzwsvvJD99j8ECBAgQIAAAQIECBAgQIAAAQIECBDYUQJND0CPP/74bCw333zzjhqT/RIgQIAAAQIECBAgQIAAAQIECBAgQCATaHoAeu6558Zpp50W8+fPj89+9rOxYsUK1AQIECBAgAABAgQIECBAgAABAgQIENghAk1/CvyCBQvi7LPPjkcffTS+9rWvxXe+852YPn167LPPPrHbbrv1O8h09ehxxx3X7zoWEiBAgAABAgQIECBAgAABAgQIECBAoFGBpgegf/VXfxXf//73e/b/m9/8Ju65556e9/296OzsFID2B2QZAQIECBAgQIAAAQIECBAgQIAAAQKDEmj6LfCD2ruVCRAgQIAAAQIECBAgQIAAAQIECBAg0EKBpl8B+q//+q+xYcOGXF0eNWpUrnZla9TR0RHd3d1lG1bD46ny2BtGsmJbCaSr29Pk2G6rsunsIATS/2/VpvT/5bVjvjbPbwJlEejq6orhw4c7n5eloMaxjUA6vmtTOt59dqlp+F02gfRZZdiwYY7xshXWeHoE0vFdm0aMGOFYfxOj6QHouHHjasZ+5xRIB2o6QKs6VXnsVa152cdd+z8fx3bZK13d8dWO8SSQwtAt31dXxcjLKJDCoap/TitjXY3ptwJbnr/T8e6zy29tvCqXQC3sd4yXq65GU1/AZ5e3XJoegNbnNncwAukK2hUrVgymSanWffXVV0s1HoMhMGHChNi8eXMsXboUBoFSCowePTrGjx+fjW3lypWRfkwEyiiQroZLfyz7rFLG6hpTEkhXfU6cODHDWLNmTSxfvhwMgVIKjB07NtLFW87npSyvQb0pkC5KmDRpUmaxbt260vwtOmXKlNz1/e09Drk3oSEBAgQIECBAgAABAgQIECBAgAABAgSKKdD0K0AXLlwYy5YtyzXaPffcM/bYY49cbTUiQIAAAQIECBAgQIAAAQIECBAgQIBAb4GmB6DnnXdefP/73++9n4beX3bZZTF79uyG1rUSAQIECBAgQIAAAQIECBAgQIAAAQIEBhJwC/xAQpYTIECAAAECBAgQIECAAAECBAgQINC2Ak2/AvT888+PP/3TP+0TZOPGjdmXaT///PPx7//+75F+/+Ef/mHcdNNNsfPOO/fZzgICBAgQIECAAAECBAgQIECAAAECBAgMVqDpAejMmTMb7sPll18ep512WnbL/Je//OW45pprGm5rRQIECBAgQIAAAQIECBAgQIAAAQIECAwksENvgU9XfKbvC00PPvrqV78a991330D9tZwAAQIECBAgQIAAAQIECBAgQIAAAQINC+zQADT1squrK97znvdkHX7ggQca7rgVCRAgQIAAAQIECBAgQIAAAQIECBAgMJDADg9AUwff+c53Zv186KGHBuqv5QQIECBAgAABAgQIECBAgAABAgQIEGhYoBAB6Pz587MOjxgxouGOW5EAAQIECBAgQIAAAQIECBAgQIAAAQIDCezwADR9B+i9996b9fPwww8fqL+WEyBAgAABAgQIECBAgAABAgQIECBAoGGBpj8F/t/+7d9i0aJF/XZgw4YNsWrVqnjiiSfi7rvvztYdNmxYnHzyyf22s5AAAQIECBAgQIAAAQIECBAgQIAAAQKDEWh6APpP//RP2ZPdB9OJtO6FF14Yv//7vz/YZtYnQIAAAQIECBAgQIAAAQIECBAgQIBAnwJND0D73FMfCw499NA455xz4uMf/3gfa5hNgAABAgQIECBAgAABAgQIECBAgACBfAJND0DnzJkTq1evHrA36YFH48ePjzFjxgy4rhUIECBAgAABAgQIECBAgAABAgQIECCQR6DpAeikSZPy9EMbAgQIECBAgAABAgQIECBAgAABAgQINF2g6QFoXz1844034rnnnouRI0dGCkl32WWXSA8+MhEgQIAAAQIECBAgQIAAAQIECBAgQKBVAsNbteG03QULFsT73//+2GuvvWKnnXaKadOmxcEHHxwTJ06M3XbbLc4+++x4/PHHW9kF2yZAgAABAgQIECBAgAABAgQIECBAoMICLQlAN2zYEH/5l38Z6QFHd911V/zyl7/chnjJkiVx8803x5FHHhlf+tKXtlluBgECBAgQIECAAAECBAgQIECAAAECBLZXoCW3wP/t3/5tT6iZbnN/97vfHQceeGDss88+sWrVqnjxxRfjJz/5STz55JNRC0snT54cZ5555vaOR3sCBAgQIECAAAECBAgQIECAAAECBAj0CDQ9AH3iiSciBaBpOuqoo+L666/PrgTt2eMWL773ve/F5z73uXj++efjM5/5TJx66qnZk+G3WMVLAgQIECBAgAABAgQIECBAgAABAgQI5BZo+i3w1113Xaxfvz7222+/mDt3bp/hZ+rx+973vkgh6JgxYyI9JOnWW2/NPRANCRAgQIAAAQIECBAgQIAAAQIECBAg0Fug6QFouq09TbNnz27oas53vOMdcdZZZ2Vt7r///uy3/yFAgAABAgQIECBAgAABAgQIECBAgEAzBJoagG7cuDGefvrprF9HHHFEw/2rrZu+G9REgAABAgQIECBAgAABAgQIECBAgACBZgk0NQAdPnx4dHa+9bWiK1eubLiP6cFIaeru7m64jRUJECBAgAABAgQIECBAgAABAgQIECAwkEBTA9D0xPeDDjoo2+cPf/jDgfbds/yhhx7KXr/rXe/qmecFAQIECBAgQIAAAQIECBAgQIAAAQIEtlegqQFo6syMGTOyPl122WWxaNGiAfv3H//xHz0PPzr00EMHXN8KBAgQIECAAAECBAgQIECAAAECBAgQaFSg6QHoxRdfHOPGjYvXX389jj322PjmN78Z6btBe08rVqyIyy+/PD7wgQ/E5s2bI139+eEPf7j3at4TIECAAAECBAgQIECAAAECBAgQIEAgt8BbX9iZu/m2DadMmRJf+MIX4txzz41f/vKX2RPeL7jggth///1j3333jXXr1sULL7wQzz33XNS++3PEiBFxyy23RFdX17YbNIcAAQIECBAgQIAAAQIECBAgQIAAAQI5BZoegKZ+/Pmf/3kceOCB8YlPfCILQZcuXRqPP/549tO7n9OmTYvrr78+3P7eW8Z7AgQIECBAgAABAgQIECBAgAABAgS2V6AlAWjq1AknnBD/8z//EzfccEP2+2c/+1n8/Oc/j3S159SpU7Of448/PmbNmhUdHR3bOw7tCRAgQIAAAQIECBAgQIAAAQIECBAgsI1AywLQtKfu7u646KKLenaavuszPSneRIAAAQIECBAgQIAAAQIECBAgQIAAgaEQaPpDkHp3es2aNT2ztgw//+u//qvnO0B7VvCCAAECBAgQIECAAAECBAgQIECAAAECTRRoWQD60EMPxfve97447LDD6nb39NNPj1133TU++tGPxmuvvVZ3HTMJECBAgAABAgQIECBAgAABAgQIECCwPQItCUC/+c1vxsyZM+Puu++OZ555Jnvy+5ad3LRpU7z44ouxevXquO2222L69OmxYMGCLVfxmgABAgQIECBAgAABAgQIECBAgAABAtst0PQAdOHChfGpT30q1q9fn3XuxBNP3CYATQvuvPPO+LM/+7MYPnx4vPDCC/Gxj30sUjBqIkCAAAECBAgQIECAAAECBAgQIECAQLMEmh6AXnnllbFhw4bYfffd4wc/+EHMnTs3xo0bt1V/U+h5yimnxD/+4z/GvffeG52dnfH444/HrbfeutV63hAgQIAAAQIECBAgQIAAAQIECBAgQGB7BJoegD788MNZf2bNmhXHH3/8gH077rjj4pOf/GS23gMPPDDg+lYgQIAAAQIECBAgQIAAAQIECBAgQIBAowJNDUA3btyY3c6edv7hD3+40T7E0Ucfna37s5/9rOE2ViRAgAABAgQIECBAgAABAgQIECBAgMBAAk0NQIcNG5Z9p2faaboNvtFpzZo12aqjRo1qtIn1CBAgQIAAAQIECBAgQIAAAQIECBAgMKBAUwPQ9N2ee++9d7bTBx98cMCd11b40Y9+lL085JBDarP8JkCAAAECBAgQIECAAAECBAgQIECAwHYLNDUATb35oz/6o6xTs2fPjmeeeWbADqaHIH3rW9/K1ps+ffqA61uBAAECBAgQIECAAAECBAgQIECAAAECjQo0PQD99Kc/HelW9hUrVsSRRx4Z6anwr7zyylb92bx5c/Zdoeedd16ceuqpsWnTpjj88MMH9b2hW23QGwIECBAgQIAAAQIECBAgQIAAAQIECNQRaHoAesABB8TXv/71bFdLly6NSy65JHbfffcYN25cHHzwwfG2t70tRo8eHfvtt19ce+21sXr16uz9t7/97ejs7KzTRbMIECBAgAABAgQIECBAgAABAgQIECCQT6DpAWjqxqxZs+K73/1u7Lnnnj29WrlyZfz85z+PRYsWxdq1a3vmv/e9742f/OQncdBBB/XM84IAAQIECBAgQIAAAQIECBAgQIAAAQLNEGjZJZfpu0BPPPHESN/xOXfu3Cz4fPnll2PMmDGRrhJNP0cffXQcd9xxzRiHbRAgQIAAAQIECBAgQIAAAQIECBAgQGAbgZYFoGlP6btA0xWe6cdEgAABAgQIECBAgAABAgQIECBAgACBoRZoyS3wQz0I+yNAgAABAgQIECBAgAABAgQIECBAgEA9AQFoPRXzCBAgQIAAAQIECBAgQIAAAQIECBAohYAAtBRlNAgCBAgQIECAAAECBAgQIECAAAECBOoJCEDrqZhHgAABAgQIECBAgAABAgQIECBAgEApBASgpSijQRAgQIAAAQIECBAgQIAAAQIECBAgUE9AAFpPxTwCBAgQIECAAAECBAgQIECAAAECBEohIAAtRRkNggABAgQIECBAgAABAgQIECBAgACBegIC0Hoq5hEgQIAAAQIECBAgQIAAAQIECBAgUAoBAWgpymgQBAgQIECAAAECBAgQIECAAAECBAjUExCA1lMxjwABAgQIECBAgAABAgQIECBAgACBUggIQEtRRoMgQIAAAQIECBAgQIAAAQIECBAgQKCegAC0nop5BAgQIECAAAECBAgQIECAAAECBAiUQkAAWooyGgQBAgQIECBAgAABAgQIECBAgAABAvUEBKD1VMwjQIAAAQIECBAgQIAAAQIECBAgQKAUAgLQUpTRIAgQIECAAAECBAgQIECAAAECBAgQqCcgAK2nYh4BAgQIECBAgAABAgQIECBAgAABAqUQEICWoowGQYAAAQIECBAgQIAAAQIECBAgQIBAPQEBaD0V8wgQIECAAAECBAgQIECAAAECBAgQKIWAALQUZTQIAgQIECBAgAABAgQIECBAgAABAgTqCXTWm1mleatWrYqbbrqp3yGfcsopccABB2y1ztq1a+OOO+6Ixx57LJYuXRpTp06NadOmxUknnRQdHR1bresNAQIECBAgQIAAAQIECBAgQIAAAQI7RqDyAeizzz6bBZn98adgc8sAdNmyZXHOOefE4sWLs2YTJkyIe+65J/t5+OGHY/bs2dHV1dXfJi0jQIAAAQIECBAgQIAAAQIECBAgQGAIBCofgC5cuDBjnj59ehx//PF1ydPVnVtOV1xxRRZ+zpgxIy655JLo7u6Ol156KS6++OJ48MEH47rrrosLLrhgyyZeEyBAgAABAgQIECBAgAABAgQIECCwAwQEoP8fgKbw89RTTx2wBE8//XQ8+uijMXr06Ljyyitj1KhRWZs999wzrr766jjttNNi3rx58alPfSp22mmnAbdnBQIECBAgQIAAAQIECBAgQIAAAQIEWidQ+YcgpVvg03TggQc2pDx//vxsvWOPPbYn/Kw1TLfCH3HEEbFu3bosBK3N95sAAQIECBAgQIAAAQIECBAgQIAAgR0jUOkAdMOGDbFo0aLo7OyM/fffP6vA8uXLIz3gqK9pwYIF2aJ0+3u9KQWgaXryySfrLTaPAAECBAgQIECAAAECBAgQIECAAIEhFKj0LfAvvvhirF+/Pvbee++47bbb4s4774wlS5bE8OHDs3lnnHFGvOc979mqHOm7PtM0fvz4rebX3tTm1x6QVJvvNwECBAgQIECAAAECBAgQIECAAAECQy9Q6QC09gCkX/ziF3HzzTfHrrvuGulhSC+88EL2kx529N///d9x0UUX9VRm5cqV2eta0Nmz4P9f7Lzzztmr2nq9l9fen3zyybF06dLa261+n3/++fGBD3xgq3lVerP77rtXabjGWgGBYcOGZaN0bFeg2IYY48aNy35QECijgPN5GatqTH0JjBkzJnvuQV/LzSfQ7gLpnO7zebtXUf8bERg5cqRj/U2oSgegte//TA8ruuqqq2LatGnZsbN58+bsatCvfvWrMXfu3DjyyCPj3e9+d2zatCnWrFmTrdPXA47SH35p6u82+rR82bJlfQag6TtE01WoVZ2qPPaq1rwq46794VyV8RpnNQWcw6tZ96qN2vm8ahWv5njTce5Yr2btqzRqx3iVql3dsTqfv1X7SgegH/vYx2LmzJnR3d0de+yxR89/DengSE9zT1eCptvi/+Vf/iULQNMfdenp76tXr+4z4KwFn11dXT3bq/ciXUGaAtV6U2rb17J665dtXpXHXrZaGs9bArUPVukfV0wEyipQCz6dw8taYeNKAs7njoMqCNTO5+lzi88uVah4dceYzumO8erWvwojL+P5vDamPPWrdACaruI8+OCD+3T7gz/4gywAff7557NAMkGn2+TT93uuWLGibrva/LFjx9ZdXps5b9682sttfqerQ19++eVt5ldlRpXHXpUaV22cEyZMyD5c9fW1F1XzMN7yCaR/HKx9Ncwbb7wRA30NTPkEjKgqAukfzUeMGBGvvvpqVYZsnBUTSBdiTJw4MRv1qlWrIj0g1kSgjALp7/V096a/PctYXWNKAh0dHTFp0qQMI12oV5a/RadMmZK7wNW9z7oBstr3gaRb0mt/zKUANE21oLP3ZmofEnbZZZfei7wnQIAAAQIECBAgQIAAAQIECBAgQGCIBSodgN5+++3xjW98I7vVvZ577V+D0oONat/5WUvQFy1aVK9J1Ob3d2Vp3YZmEiBAgAABAgQIECBAgAABAgQIECDQdIFKB6D33ntv3HrrrXHLLbfUhf3hD3+YzX/HO97Rszx9Z2iaUtveU/res/vuuy+bXXugUu91vCdAgAABAgQIECBAgAABAgQIECBAYOgEKh2AHnfccZl0Ci2fe+65rdQff/zxSFeIpumss87qWZaeCL/vvvvGwoULo/f3eKYwdcmSJbHPPvvEjBkzetp4QYAAAQIECBAgQIAAAQIECBAgQIDAjhGo9EOQPvjBD8bDDz8cTzzxRHz84x+P6dOnZz/PPvts3H///VlFzjnnnDjwwAN7qpOeFHf22WfHpZdeGldddVU88sgjMXXq1Hjqqaey1+mL8S+88MKep4T2NPSCAAECBAgQIECAAAECBAgQIECAAIEhF6h0AJqeivWlL30puw3+tttui3TVZ/pJ01577RWf/exnI13x2Xs65phj4pprrskC0BSU1sLSdGXo5z//+TjkkEN6N/GeAAECBAgQIECAAAECBAgQIECAAIEdIFDpADR5jxo1KrvF/WMf+1j86le/imXLlsX+++8f48aN67cchx56aHaLfLrlffHixZEejjR58uQYPrzS3yrQr5mFBAgQIECAAAECBAgQIECAAAECBIZaoPIBaA28s7Mz9t577+ynNq+R3xMnToz0YyJAgAABAgQIECBAgAABAgQIECBAoHgCLlcsXk30iAABAgQIECBAgAABAgQIECBAgACBJgkIQJsEaTMECBAgQIAAAQIECBAgQIAAAQIECBRPQABavJroEQECBAgQIECAAAECBAgQIECAAAECTRIQgDYJ0mYIECBAgAABAgQIECBAgAABAgQIECiegAC0eDXRIwIECBAgQIAAAQIECBAgQIAAAQIEmiQgAG0SpM0QIECAAAECBAgQIECAAAECBAgQIFA8AQFo8WqiRwQIECBAgAABAgQIECBAgAABAgQINElAANokSJshQIAAAQIECBAgQIAAAQIECBAgQKB4AgLQ4tVEjwgQIECAAAECBAgQIECAAAECBAgQaJKAALRJkDZDgAABAgQIECBAgAABAgQIECBAgEDxBASgxauJHhEgQIAAAQIECBAgQIAAAQIECBAg0CQBAWiTIG2GAAECBAgQIECAAAECBAgQIECAAIHiCQhAi1cTPSJAgAABAgQIECBAgAABAgQIECBAoEkCAtAmQdoMAQIECBAgQIAAAQIECBAgQIAAAQLFExCAFq8mekSAAAECBAgQIECAAAECBAgQIECAQJMEBKBNgrQZAgQIECBAgAABAgQIECBAgAABAgSKJyAALV5N9IgAAQIECBAgQIAAAQIECBAgQIAAgSYJCECbBGkzBAgQIECAAAECBAgQIECAAAECBAgUT0AAWrya6BEBAgQIECBAgAABAgQIECBAgAABAk0SEIA2CdJmCBAgQIAAAQIECBAgQIAAAQIECBAonoAAtHg10SMCBAgQIECAAAECBAgQIECAAAECBJokIABtEqTNECBAgAABAgQIECBAgAABAgQIECBQPAEBaPFqokcECBAgQIAAAQIECBAgQIAAAQIECDRJQADaJEibIUCAAAECBAgQIECAAAECBAgQIECgeAIC0OLVRI8IECBAgAABAgQIECBAgAABAgQIEGiSgAC0SZA2Q4AAAQIECBAgQIAAAQIECBAgQIBA8QQEoMWriR4RIECAAAECBAgQIECAAAECBAgQINAkAQFokyBthgABAgQIECBAgAABAgQIECBAgACB4gkIQItXEz0iQIAAAQIECBAgQIAAAQIECBAgQKBJAgLQJkHaDAECBAgQIECAAAECBAgQIECAAAECxRMQgBavJnpEgAABAgQIECBAgAABAgQIECBAgECTBASgTYK0GQIECBAgQIAAAQIECBAgQIAAAQIEiicgAC1eTfSIAAECBAgQIECAAAECBAgQIECAAIEmCQhAmwRpMwQIECBAgAABAgQIECBAgAABAgQIFE9AAFq8mugRAQIECBAgQIAAAQIECBAgQIAAAQJNEhCANgnSZggQIECAAAECBAgQIECAAAECBAgQKJ6AALR4NdEjAgQIECBAgAABAgQIECBAgAABAgSaJCAAbRKkzRAgQIAAAQIECBAgQIAAAQIECBAgUDwBAWjxaqJHBAgQIECAAAECBAgQIECAAAECBAg0SUAA2iRImyFAgAABAgQIECBAgAABAgQIECBAoHgCAtDi1USPCBAgQIAAAQIECBAgQIAAAQIECBBokoAAtEmQNkOAAAECBAgQIECAAAECBAgQIECAQPEEBKDFq4keESBAgAABAgQIECBAgAABAgQIECDQJAEBaJMgbYYAAQIECBAgQIAAAQIECBAgQIAAgeIJCECLVxM9IkCAAAECBAgQIECAAAECBAgQIECgSQIC0CZB2gwBAgQIECBAgAABAgQIECBAgAABAsUTEIAWryZ6RIAAAQIECBAgQIAAAQIECBAgQIBAkwQEoE2CtBkCBAgQIECAAAECBAgQIECAAAECBIon0Fm8LulR1QVmzZrVJ8GcOXP6XGYBAQIECBAgQIAAAQIECBAgQIAAgd4CrgDtLeI9AQIECBAgQIAAAQIECBAgQIAAAQKlERCAlqaUBkKAAAECBAgQIECAAAECBAgQIECAQG8BAWhvEe8JECBAgAABAgQIECBAgAABAgQIECiNgAC0NKU0EAIECBAgQIAAAQIECBAgQIAAAQIEegsIQHuLeE+AAAECBAgQIECAAAECBAgQIECAQGkEBKClKaWBECBAgAABAgQIECBAgAABAgQIECDQW0AA2lvEewIECBAgQIAAAQIECBAgQIAAAQIESiMgAC1NKQ2EAAECBAgQIECAAAECBAgQIECAAIHeAgLQ3iLeEyBAgAABAgQIECBAgAABAgQIECBQGgEBaGlKaSAECBAgQIAAAQIECBAgQIAAAQIECPQWEID2FvGeAAECBAgQIECAAAECBAgQIECAAIHSCAhAS1NKAyFAgAABAgQIECBAgAABAgQIECBAoLeAALS3iPcECBAgQIAAAQIECBAgQIAAAQIECJRGQABamlIaCAECBAgQIECAAAECBAgQIECAAAECvQUEoL1FvCdAgAABAgQIECBAgAABAgQIECBAoDQCAtDSlNJACBAgQIAAAQIECBAgQIAAAQIECBDoLdDZe4b3O16gs7Mzdt111x3fkQL2gEsBi6JLAwp0dHRk6zh+B6SyQpsKDBs2rKfnY8eOjdGjR/e894JAmQTS+Twd787nZaqQwrR2AAAqyElEQVSqsWwpsOX5fNSoUdHV1bXlYq8JlEZg+PDhzuelqaaBDCSQzuU+u0QIQAc6UnbA8s2bN8f69et3wJ6Lv0suxa+RHm4rkD5gpcnxu62NOeUQSKFQ+se7NG3cuDE2bNhQjoEZBYFeAikcSud05/NeMN6WRiAd37Xz+aZNmxzrpamsgfQWSMe583lvFe/LJJA+s4wYMSIbUpkyptqY8tRKAJpHrcVt0h+Pb7zxRov30p6bf/3119uz43pdaYEJEyZE+j8dx2+lD4NSDz5d8Tly5MhsjGvWrImVK1eWerwGV12B7u7u7I8J5/PqHgNlH3m6Sihd+ZmmdevWxfLly8s+ZOOrqEC6YyWFoM7nFT0AKjDsdIFC7a6s9A+3ZTnWx4wZk7t6vgM0N52GBAgQIECAAAECBAgQIECAAAECBAgUXUAAWvQK6R8BAgQIECBAgAABAgQIECBAgAABArkFBKC56TQkQIAAAQIECBAgQIAAAQIECBAgQKDoAgLQoldI/wgQIECAAAECBAgQIECAAAECBAgQyC0gAM1NpyEBAgQIECBAgAABAgQIECBAgAABAkUXEIAWvUL6R4AAAQIECBAgQIAAAQIECBAgQIBAbgEBaG46DQkQIECAAAECBAgQIECAAAECBAgQKLqAALToFdI/AgQIECBAgAABAgQIECBAgAABAgRyCwhAc9NpSIAAAQIECBAgQIAAAQIECBAgQIBA0QUEoEWvkP4RIECAAAECBAgQIECAAAECBAgQIJBbQACam05DAgQIECBAgAABAgQIECBAgAABAgSKLiAALXqF9I8AAQIECBAgQIAAAQIECBAgQIAAgdwCAtDcdBoSIECAAAECBAgQIECAAAECBAgQIFB0gc6id1D/CGwpMGvWrC3fbvN6zpw528wzgwABAgQIECBAgAABAgQIECBAoLoCrgCtbu2NnAABAgQIECBAgAABAgQIECBAgEDpBQSgpS+xARIgQIAAAQIECBAgQIAAAQIECBCoroAAtLq1N3ICBAgQIECAAAECBAgQIECAAAECpRcQgJa+xAZIgAABAgQIECBAgAABAgQIECBAoLoCAtDq1t7ICRAgQIAAAQIECBAgQIAAAQIECJReQABa+hIbIAECBAgQIECAAAECBAgQIECAAIHqCghAq1t7IydAgAABAgQIECBAgAABAgQIECBQegEBaOlLbIAECBAgQIAAAQIECBAgQIAAAQIEqisgAK1u7Y2cAAECBAgQIECAAAECBAgQIECAQOkFBKClL7EBEiBAgAABAgQIECBAgAABAgQIEKiugAC0urU3cgIECBAgQIAAAQIECBAgQIAAAQKlFxCAlr7EBkiAAAECBAgQIECAAAECBAgQIECgugIC0OrW3sgJECBAgAABAgQIECBAgAABAgQIlF5AAFr6EhsgAQIECBAgQIAAAQIECBAgQIAAgeoKCECrW3sjJ0CAAAECBAgQIECAAAECBAgQIFB6AQFo6UtsgAQIECBAgAABAgQIECBAgAABAgSqKyAArW7tjZwAAQIECBAgQIAAAQIECBAgQIBA6QUEoKUvsQESIECAAAECBAgQIECAAAECBAgQqK6AALS6tTdyAgQIECBAgAABAgQIECBAgAABAqUXEICWvsQGSIAAAQIECBAgQIAAAQIECBAgQKC6AgLQ6tbeyAkQIECAAAECBAgQIECAAAECBAiUXkAAWvoSGyABAgQIECBAgAABAgQIECBAgACB6goIQKtbeyMnQIAAAQIECBAgQIAAAQIECBAgUHoBAWjpS2yABAgQIECAAAECBAgQIECAAAECBKor0FndoRt5GQVmzZrV57DmzJnT5zILCBAgQIAAAQIECBAgQIAAAQIEyingCtBy1tWoCBAgQIAAAQIECBAgQIAAAQIECBB4U0AA6jAgQIAAAQIECBAgQIAAAQIECBAgQKC0AgLQ0pbWwAgQIECAAAECBAgQIECAAAECBAgQEIA6BggQIECAAAECBAgQIECAAAECBAgQKK2AALS0pTUwAgQIECBAgAABAgQIECBAgAABAgQ8Bd4xQOBNgf6eHp+APEHeYUKAAAECBAgQIECAAAECBAgQaE8BV4C2Z930mgABAgQIECBAgAABAgQIECBAgACBBgQEoA0gWYUAAQIECBAgQIAAAQIECBAgQIAAgfYUEIC2Z930mgABAgQIECBAgAABAgQIECBAgACBBgQEoA0gWYUAAQIECBAgQIAAAQIECBAgQIAAgfYUEIC2Z930mgABAgQIECBAgAABAgQIECBAgACBBgQEoA0gWYUAAQIECBAgQIAAAQIECBAgQIAAgfYUEIC2Z930mgABAgQIECBAgAABAgQIECBAgACBBgQEoA0gWYUAAQIECBAgQIAAAQIECBAgQIAAgfYUEIC2Z930mgABAgQIECBAgAABAgQIECBAgACBBgQEoA0gWYUAAQIECBAgQIAAAQIECBAgQIAAgfYUEIC2Z930mgABAgQIECBAgAABAgQIECBAgACBBgQ6G1jHKgRKITBr1qxSjMMgCBAgQIAAAQIECBAgQIAAAQIEGhdwBWjjVtYkQIAAAQIECBAgQIAAAQIECBAgQKDNBASgbVYw3SVAgAABAgQIECBAgAABAgQIECBAoHEBAWjjVtYkQIAAAQIECBAgQIAAAQIECBAgQKDNBASgbVYw3SVAgAABAgQIECBAgAABAgQIECBAoHEBAWjjVtYkQIAAAQIECBAgQIAAAQIECBAgQKDNBDwFvs0Kprs7RqC/J8jPmTNnx3TKXgkQIECAAAECBAgQIECAAAECBAYUcAXogERWIECAAAECBAgQIECAAAECBAgQIECgXQUEoO1aOf0mQIAAAQIECBAgQIAAAQIECBAgQGBAAbfAD0hkBQL9C/R3e3xq6Rb5/v0sJUCAAAECBAgQIECAAAECBAi0UkAAmlN37dq1cccdd8Rjjz0WS5cujalTp8a0adPipJNOio6Ojpxb1YwAAQIECBAgQIAAAQIECBAgQIAAgWYKCEBzaC5btizOOeecWLx4cdZ6woQJcc8992Q/Dz/8cMye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CBAgQIAAgSYJDNv85tSkbdkMgUEJfOMb34jrr78+a/PFL34xTjnllEG1tzIBAgQIFEPgrrvuiosvvjjrzOc+97k4++yzi9ExvSBAgACBQQn8+Mc/jlmzZmVtPvShD8Wll146qPZWJkCAAIFiCPzyl7+Mk046KevM0UcfHTfccEMxOrYDe9G5A/dt1xUX2LhxY6xfvz5T2LRpU8U1DJ8AAQLtK5DO4c7n7Vs/PSdAgEBNYMvz+YYNG2qz/SZAgACBNhNI1zrWPp87n79VPLfAt9lBrLsECBAgQIAAAQIECBAgQIAAAQIECDQuIABt3MqaBAgQIECAAAECBAgQIECAAAECBAi0mYAAtM0KprsECBAgQIAAAQIECBAgQIAAAQIECDQuIABt3MqaBAgQIECAAAECBAgQIECAAAECBAi0mYAAtM0KprsECBAgQIAAAQIECBAgQIAAAQIECDQuMOzNJ0Ntbnx1axJonsBzzz0XCxcuzDb4O7/zOzFlypTmbdyWCBAgQGDIBF566aV46qmnsv29/e1vj/3333/I9m1HBAgQINA8gddeey0effTRbIN77bVXvOMd72jexm2JAAECBIZMYPXq1fHAAw9k+9ttt91i+vTpQ7bvou5IAFrUyugXAQIECBAgQIAAAQIECBAgQIAAAQLbLeAW+O0mtAECBAgQIECAAAECBAgQIECAAAECBIoqIAAtamX0iwABAgQIECBAgAABAgQIECBAgACB7RYQgG43oQ0QIECAAAECBAgQIECAAAECBAgQIFBUAQFoUSujXwQIECBAgAABAgQIECBAgAABAgQIbLdA53ZvwQYIDFJg7dq1cccdd8Rjjz0WS5cujalTp8a0adPipJNOio6OjkFuzeoECBAg0EqBVatWxU033dTvLk455ZQ44IADtlrHuX4rDm8IECCwwwTmzp0b//zP/xyXXXZZHHzwwX324+c//3ncfvvt8eKLL8bYsWPjXe96Vxx//PGx//77N7VNnxuzgAABAgT6FWjkfH7//ffHk08+2ed2dt111/joRz+6zfI8/x+wzUYKPsNT4AteoLJ1b9myZXHOOefE4sWLs6FNmDAhXnvttez1McccE7Nnz46urq6yDdt4CBAg0LYC6QPUZz7zmX77f+WVV8axxx7bs45zfQ+FFwQIENihAk899VR89rOfjQ0bNsTXvva17KKDeh1KFydce+212aJx48bFunXrsp/Ro0fH3/3d38Vhhx22TbM8bbbZiBkECBAg0JBAo+fz8847Lx5//PE+t5n+UeuWW27ZanlVzueuAN2q7N60WuCKK67Iws8ZM2bEJZdcEt3d3fHSSy/FxRdfHA8++GBcd911ccEFF7S6G7ZPgAABAg0KLFy4MFtz+vTp2ZVA9ZqlK/m3nJzrt9TwmgABAjtG4IknnsguLkjhZ39T+qM6fQZPFyGkixGOPvroLDD97ne/2/PZ/LbbbovJkyf3bCZPm57GXhAgQIDAoAQaPZ+njdY+u6d//Bo5cuQ2+9lpp522mlel87kAdKvSe9NKgaeffjoeffTRSP+SnK4WGjVqVLa7PffcM66++uo47bTTYt68efGpT30qev9H2cp+2TYBAgQI9C1Q+xCVboM89dRT+17x/5c41w9IZAUCBAi0VCB9dcnXv/71uOuuu7L9DB8+PDZt2tTnPtOVQJs3b47TTz890h1ZaRoxYkR88IMfjF/96lfZV1elMPTTn/50zzbytOlp7AUBAgQINCQw2PP5K6+8EsuXL4+JEydm5/BGdlKl87mHIDVyRFinKQLz58/PtpNuk6yFn7UNp1vhjzjiiOxWmxSCmggQIECgGALPPvts1pEDDzywoQ451zfEZCUCBAi0TOCTn/xkFn6OGTMmLr300thvv/363Ff64zpdoJCmE088cZv1avPuvvvu7KrQtEKeNtts2AwCBAgQGFBgMOfztLHahQuNfm6v2vlcADrgIWeFZgksWLAg21S6/b3elALQNPX3hb312plHgAABAq0RSLdNLlq0KDo7O3segpH+VTk94Kivybm+LxnzCRAgMDQC6XuYU3D5rW99K0444YR+d/qzn/0su/pzr732ij322GObdQ866KDszqzXX389fvGLX2TL87TZZsNmECBAgMCAAoM5n6eN9Q5A02f52jNX6u2saudzt8DXOwrMa4lA+q7PNI0fP77u9mvzaw9IqruSmQQIECAwZALpScDr16+PvffeO9L3v915552xZMmSSLdTpnlnnHFGvOc979mqP871W3F4Q4AAgSEXmDNnTuy+++4N7Xegc3baSPqMvmLFiux7/NPDM/K0aagzViJAgACBrQQGcz5PDWsBaAo+P//5z0f67tCNGzdm/5D1u7/7u9lD8dLt8bWpaudzV4DWKu93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pgBd4N2879QaAQQQQAABBBBAAAEEEEAAAQQQQAABJwQIgDpxm6kkAggggAACCCCAAAIIIIAAAggggAACbgoQAHXzvlNrBBBAAAEEEEAAAQQQQAABBBBAAAEEnBAgAOrEbaaSCCCAAAIIIIAAAggggAACCCCAAAIIuClAANTN+06tEUAAAQQQQAABBBBAAAEEEEAAAQQQcEKAAKgTt5lKIoAAAggggAACCCCAAAIIIIAAAggg4KYAAVA37zu1RgABBBBAAAEEEEAAAQQQQAABBBBAwAkBAqBO3GYqiQACCCCAAAIIIIAAAggggAACCCCAgJsCBEDdvO/UGgEEEEAAAQQQQAABBBBAAAEEEEAAAScECIA6cZupJAIIIIAAAggggAACCCCAAAIIIIAAAm4KEAB1875TawQQQAABBBBAAAEEEEAAAQQQQAABBJwQIADqxG2mkggggAACCCCAAAIIIIAAAggggAACCLgpQADUzftOrRFAAAEEEEAAAQQQQAABBBBAAAEEEHBCgACoE7eZSiKAAAIIIIAAAggggAACCCCAAAIIIOCmAAFQN+87tUYAAQQQQAABBBBAAAEEEEAAAQQQQMAJAQKgTtxmKokAAggggAACCCCAAAIIIIAAAggggICbAgRA3bzv1BoBBBBAAAEEEEAAAQQQQAABBBBAAAEnBAiAOnGbqSQCCCCAAAIIIIAAAggggAACCCCAAAJuCvwDmVvcHSUEW0oAAAAASUVORK5CYII=" width="672" /></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co"># without zeroes</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">fish <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="st">  </span><span class="kw">filter</span>(count <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="st">  </span><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(count), <span class="dt">binwidth =</span> <span class="dv">1</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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AgQIEMi7gAA07yOkfQQIECBAgAABAgQIECBAgAABAgQIZBYQgGamU5EAAQIECBAgQIAAAQIECBAgQIAAgbwLCEDzPkLaR4AAAQIECBAgQIAAAQIECBAgQIBAZgEBaGY6FQkQIECAAAECBAgQIECAAAECBAgQyLuAADTvI6R9BAgQIECAAAECBAgQIECAAAECBAhkFhCAZqZTkQABAgQIECBAgAABAgQIECBAgACBvAsIQPM+QtpHgAABAgQIECBAgAABAgQIECBAgEBmAQFoZjoVCRAgQIAAAQIECBAgQIAAAQIECBDIu4AANO8jpH0ECBAgQIAAAQIECBAgQIAAAQIECGQWEIBmplORAAECBAgQIECAAAECBAgQIECAAIG8CwhA8z5C2keAAAECBAgQIECAAAECBAgQIECAQGYBAWhmOhUJECBAgAABAgQIECBAgAABAgQIEMi7gAA07yOkfQQIECBAgAABAgQIECBAgAABAgQIZBYQgGamU5EAAQIECBAgQIAAAQIECBAgQIAAgbwLCEDzPkLaR4AAAQIECBAgQIAAAQIECBAgQIBAZgEBaGY6FQkQIECAAAECBAgQIECAAAECBAgQyLuAADTvI6R9BAgQIECAAAECBAgQIECAAAECBAhkFhCAZqZTkQABAgQIECBAgAABAgQIECBAgACBvAsIQPM+QtpHgAABAgQIECBAgAABAgQIECBAgEBmgabMNVUk8AuBBQsW9GixdOnSHtdZQYAAAQIECBAgQIAAAQIECBAgQKDWAs4ArbWw/RMgQIAAAQIECBAgQIAAAQIECBAgUDcBAWjd6B2YAAECBAgQIECAAAECBAgQIECAAIFaCwhAay1s/wQIECBAgAABAgQIECBAgAABAgQI1E1AAFo3egcmQIAAAQIECBAgQIAAAQIECBAgQKDWAgLQWgvbPwECBAgQIECAAAECBAgQIECAAAECdRMo3VPgf/7zn4evfvWrYf369aGtrS0cf/zxYdasWeGMM87oEbm9vT3ccccd4dFHHw2tra1h+vTpYebMmWHevHmhsbGxx3pWECBAgAABAgQIECBAgAABAgQIECCQb4FSBaCPPPJIuPzyy8OOHTsS9dGjR4ennnoqfP3rXw/veMc7wiWXXLJfoLl58+Zw0UUXhY0bNyZ1DjvssLBixYrk66GHHgqLFi0Kzc3N+R5F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AQI1FBCA1hDXrgkQIECAAAECBAgQIECAAAECBAgQqK+AALS+/o5OgAABAgQIECBAgAABAgQIECBAgEANBQSgNcS1awIECBAgQIAAAQIECBAgQIAAAQIE6isgAK2vv6MTIECAAAECBAgQIECAAAECBAgQIFBDAQFoDXHtmgABAgQIECBAgAABAgQIECBAgACB+goIQOvr7+gECBAgQIAAAQIECBAgQIAAAQIECNRQQABaQ1y7JkCAAAECBAgQIECAAAECBAgQIECgvgIC0Pr6OzoBAgQIECBAgAABAgQIECBAgAABAjUUEIDWENeuCRAgQIAAAQIECBAgQIAAAQIECBCor4AAtL7+jk6AAAECBAgQIECAAAECBAgQIECAQA0FBKA1xLVrAgQIECBAgAABAgQIECBAgAABAgTqKyAAra+/oxMgQIAAAQIECBAgQIAAAQIECBAgUEMBAWgNce2aAAECBAgQIECAAAECBAgQIECAAIH6CghA6+vv6AQIECBAgAABAgQIECBAgAABAgQI1FBAAFpDXLsmQIAAAQIECBAgQIAAAQIECBAgQKC+AgLQ+vo7OgECBAgQIECAAAECBAgQIECAAAECNRQQgNYQ164JECBAgAABAgQIECBAgAABAgQIEKivgAC0vv6OToAAAQIECBAgQIAAAQIECBAgQIBADQUEoDXEtWsCBAgQIECAAAECBAgQIECAAAECBOorIACtr7+jEyBAgAABAgQIECBAgAABAgQIECBQQwEBaA1x7ZoAAQIECBAgQIAAAQIECBAgQIAAgfoKCEDr6+/oBAgQIECAAAECBAgQIECAAAECBAjUUEAAWkNcuyZAgAABAgQIECBAgAABAgQIECBAoL4CAtD6+js6AQIECBAgQIAAAQIECBAgQIAAAQI1FBCA1hDXrgkQIECAAAECBAgQIECAAAECBAgQqK+AALS+/o5OgAABAgQIECBAgAABAgQIECBAgEANBQSgNcS1awIECBAgQIAAAQIECBAgQIAAAQIE6isgAK2vv6MTIECAAAECBAgQIECAAAECBAgQIFBDAQFoDXHtmgABAgQIECBAgAABAgQIECBAgACB+goIQOvr7+gECBAgQIAAAQIECBAgQIAAAQIECNRQQABaQ1y7JkCAAAECBAgQIECAAAECBAgQIECgvgIC0Pr6OzoBAgQIECBAgAABAgQIECBAgAABAjUUEIDWENeuCRAgQIAAAQIECBAgQIAAAQIECBCor4AAtL7+jk6AAAECBAgQIECAAAECBAgQIECAQA0FBKA1xLVrAgQIECBAgAABAgQIECBAgAABAgTqKyAAra+/oxMgQIAAAQIECBAgQIAAAQIECBAgUEMBAWgNce2aAAECBAgQIECAAAECBAgQIECAAIH6CghA6+vv6AQIECBAgAABAgQIECBAgAABAgQI1FBAAFpDXLsmQIAAAQIECBAgQIAAAQIECBAgQKC+AgLQ+vo7OgECBAgQIECAAAECBAgQIECAAAECNRQQgNYQ164JECBAgAABAgQIECBAgAABAgQIEKivgAC0vv6OToAAAQIECBAgQIAAAQIECBAgQIBADQUEoDXEtWsCBAgQIECAAAECBAgQIECAAAECBOorIACtr7+jEyBAgAABAgQIECBAgAABAgQIECBQQwEBaA1x7ZoAAQIECBAgQIAAAQIECBAgQIAAgfoKCEDr6+/oBAgQIECAAAECBAgQIECAAAECBAjUUEAAWkNcuyZAgAABAgQIECBAgAABAgQIECBAoL4CAtD6+js6AQIECBAgQIAAAQIECBAgQIAAAQI1FBCA1hDXrgkQIECAAAECBAgQIECAAAECBAgQqK+AALS+/o5OgAABAgQIECBAgAABAgQIECBAgEANBQSgNcS1awIECBAgQIAAAQIECBAgQIAAAQIE6isgAK2vv6MTIECAAAECBAgQIECAAAECBAgQIFBDAQFoDXHtmgABAgQIECBAgAABAgQIECBAgACB+goIQOvr7+gECBAgQIAAAQIECBAgQIAAAQIECNRQQABaQ1y7JkCAAAECBAgQIECAAAECBAgQIECgvgIC0Pr6OzoBAgQIECBAgAABAgQIECBAgAABAjUUEIDWENeuCRAgQIAAAQIECBAgQIAAAQIECBCor0BTfQ9f/qM3NDSE4cOHl6KjQ4cO7exHc3Nz5+veXpSl77310bpyC1Tmvblc7nHWuzcEhgwZ0vnGvO+k8KLkAnHeNzU1leYzW8mHS/cGKBDnemUx7ysSvpddoLGxMenisGHDQuXzfdn7rH+DW6Ay56OCeb93Lrzxr9/gnhs163384TpixIia7b9eO4596k+/xo0bV68mOi6BqgqYy1XltLMCCMRAyLwvwEBpYtUE4i8K8RcEC4HBJBDnvHk/mEZcX8eMGQOBwKATMO/3DrkAtMZTv729PWzZsqXGRzk4ux85cmSo/MXZvHlzaGtr6/PAP/3pT/vcxgYE8iwQ5/3o0aPDiy++mOdmahuBqglMmDAhORNuz5495n3VVO0o7wJx3sfPbFu3bs17U7WPwIAF4pVcLS0tyX62b99u3g9Y1A6KIFCZ95s2bQodHR1FaLI2EhiQQDyRoXI1V5nm/eTJkzO7uAdoZjoVCRAgQIAAAQIECBAgQIAAAQIECBDIu4AANO8jpH0ECBAgQIAAAQIECBAgQIAAAQIECGQWEIBmplORAAECBAgQIECAAAECBAgQIECAAIG8CwhA8z5C2keAAAECBAgQIECAAAECBAgQIECAQGYBAWhmOhUJECBAgAABAgQIECBAgAABAgQIEMi7gAA07yOkfQQIECBAgAABAgQIECBAgAABAgQIZBYQgGamU5EAAQIECBAgQIAAAQIECBAgQIAAgbwLCEDzPkLaR4AAAQIECBAgQIAAAQIECBAgQIBAZgEBaGY6FQkQIECAAAECBAgQIECAAAECBAgQyLuAADTvI6R9BAgQIECAAAECBAgQIECAAAECBAhkFhCAZqZTkQABAgQIECBAgAABAgQIECBAgACBvAsIQPM+QtpHgAABAgQIECBAgAABAgQIECBAgEBmAQFoZjoVCRAgQIAAAQIECBAgQIAAAQIECBDIu4AANO8jpH0ECBAgQIAAAQIECBAgQIAAAQIECGQWEIBmplORAAECBAgQIECAAAECBAgQIECAAIG8CwhA8z5C2keAAAECBAgQIECAAAECBAgQIECAQGYBAWhmOhUJECBAgAABAgQIECBAgAABAgQIEMi7gAA07yOkfQQIECBAgAABAgQIECBAgAABAgQIZBYQgGamU5EAAQIECBAgQIAAAQIECBAgQIAAgbwLCEDzPkLaR4AAAQIECBAgQIAAAQIECBAgQIBAZgEBaGY6FQkQIECAAAECBAgQIECAAAECBAgQyLuAADTvI6R9BAgQIECAAAECBAgQIECAAAECBAhkFhCAZqZTkQABAgQIECBAgAABAgQIECBAgACBvAsIQPM+QtpHgAABAgQIECBAgAABAgQIECBAgEBmAQFoZjoVCRAgQIAAAQIECBAgQIAAAQIECBDIu4AANO8jpH0ECBAgQIAAAQIECBAgQIAAAQIECGQWEIBmplORAAECBAgQIECAAAECBAgQIECAAIG8CwhA8z5C2keAAAECBAgQIECAAAECBAgQIECAQGYBAWhmOhUJECBAgAABAgQIECBAgAABAgQIEMi7gAA07yOkfQQIECBAgAABAgQIECBAgAABAgQIZBYQgGamU5EAAQIECBAgQIAAAQIECBAgQIAAgbwLCEDzPkLaR4AAAQIECBAgQIAAAQIECBAgQIBAZgEBaGY6FQkQIECAAAECBAgQIECAAAECBAgQyLuAADTvI6R9BAgQIECAAAECBAgQIECAAAECBAhkFhCAZqZTkQABAgQIECBAgAABAgQIECBAgACBvAsIQPM+QtpHgAABAgQIECBAgAABAgQIECBAgEBmAQFoZjoVCRAgQIAAAQIECBAgQIAAAQIECBDIu4AANO8jpH0ECBAgQIAAAQIECBAgQIAAAQIECGQWEIBmplORAAECBAgQIECAAAECBAgQIECAAIG8CwhA8z5C2keAAAECBAgQIECAAAECBAgQIECAQGYBAWhmOhUJECBAgAABAgQIECBAgAABAgQIEMi7gAA07yOkfQQIECBAgAABAgQIECBAgAABAgQIZBYQgGamU5EAAQIECBAgQIAAAQIECBAgQIAAgbwLCEDzPkLaR4AAAQIECBAgQIAAAQIECBAgQIBAZgEBaGY6FQkQIECAAAECBAgQIECAAAECBAgQyLuAADTvI6R9BAgQIECAAAECBAgQIECAAAECBAhkFhCAZqZTkQABAgQIECBAgAABAgQIECBAgACBvAsIQPM+QtpHgAABAgQIECBAgAABAgQIECBAgEBmAQFoZjoVCRAgQIAAAQIECBAgQIAAAQIECBDIu4AANO8jpH0ECBAgQIAAAQIECBAgQIAAAQIECGQWEIBmplORAAECBAgQIECAAAECBAgQIECAAIG8CwhA8z5C2keAAAECBAgQIECAAAECBAgQIECAQGYBAWhmOhUJECBAgAABAgQIECBAgAABAgQIEMi7gAA07yOkfQQIECBAgAABAgQIECBAgAABAgQIZBYQgGamU5EAAQIECBAgQIAAAQIECBAgQIAAgbwLCEDzPkLaR4AAAQIECBAgQIAAAQIECBAgQIBAZgEBaGY6FQkQIECAAAECBAgQIECAAAECBAgQyLuAADTvI6R9BAgQIECAAAECBAgQIECAAAECBAhkFhCAZqZTkQABAgQIECBAgAABAgQIECBAgACBvAsIQPM+QtpHgAABAgQIECBAgAABAgQIECBAgEBmgabMNXNa8eWXXw7/9m//Fp5++unws5/9LBx++OHhqKOOCueee26YMGFCaqvb29vDHXfcER599NHQ2toapk+fHmbOnBnmzZsXGhsbU+soJECAAAECBAgQIECAAAECBAgQIEAg/wKlCkBXrVoVrrnmmtDW1pYEly0tLeGxxx4Lq1evDt/85jfDxz72sTB37twuo7J58+Zw0UUXhY0bNyblhx12WFixYkXy9dBDD4VFixaF5ubmLnW8IUCAAAECBAgQIECAAAECBAgQIECgGAKluQT+hRde6Aw/FyxYEO69997wta99Lfl+wQUXJKHotdde2xl0Vobn6quvTspmz54dli1bFu68885w6623hqOPPjo88MAD4cYbb6xs6jsBAgQIECBAgAABAgQIECBAgAABAgUTKE0AetdddyUh59ve9rbw/ve/PwwbNiwZivh94cKF4Ywzzgg7duwIcbvK8uSTTyZnhw4fPjwsXrw4jB07Nlk1ZcqUcP311ydnkS5fvjxs27atUsV3AgQIECBAgAABAgQIECBAgAABAgQKJFCaAHTNmjUJ+6mnnprKH8/wjMuPf/zjzvXxkvm4nH766eGQQw5JXlf+iJfCn3LKKeG1114LMQS1ECBAgAABAgQIECBAgAABAgQIECBQPIHSBKDxUvXbbrstzJkzJ3UUXnnllaR83LhxnevXrVuXvK6Eo50rfvEiBqBxWbt27S9KfCNAgAABAgQIECBAgAABAgQIECBAoEgCpXkIUrzU/Ygjjki17+jo6DyL8/jjj+/cJt43NC77hqKdK/cprzwgad91+76OT5vvadm9e3doaChHzjxkyJDObsbX/elXf7bp3KkXBHIoUJn35nIOB0eTai5g3tec2AFyJNDfzzY5arKmEMgkUPlsEyub95kIVSqgQOUzTfxeeV3AbmgygX4L7Puz3rzfy1aaALS3WfDZz342PP/88yHe2/Od73xn56bbt29PXvcUgI4ZMyZZX9mus2K3F2effXZob2/vVrr3bXzw0vz581PXFbkw3i+1cs/U3voxceLE3lZbR6AwAuZyYYZKQ6skED80mfdVwrSbQgg0NTWFESNGFKKtGkmgWgJxzpv31dK0nyIItLS0FKGZ2kigqgLm/V7O0geg8Ynu8Ssm3n/7t3/bea/PeGZmfChSXEaPHr1Xo9ufo0aNSkp6Cje7be5tisC8efNSSt8oWrFixRtvvCJAgAABAgQIECBAgAABAgQIECBQZYFSB6A333xz+MpXvpKEn5dffnmYMWNGJ18MROPT39va2no8e7MSfDY3N3fWS3sR7yEaH5aUthx66KE97j9t+zyXNTY2hnh2RFx27twZYog80KViPND9qE+gVgJx3sevnv6O1+q49kugXgLx37x49ueePXvM+3oNguMedIGhQ4cmcz7eNslCoOwC8Wd85febXbt2BfO+7COuf1Eg/v4ff9bHz/TxM46FQNkFYnYTf4+NS5nmfbz9ZdallAFoDOfipeff+ta3kn/cr7jiiuRJ792Rxo8fH+L9Pbdt29Z9VfK+Uj5y5MjU9ZXCz33uc5WX+31vbW0NlQcw7beyYAXRYd/bAsTweKBLWWwG6qB+fgXivI9niZur+R0jLauuwIQJEzr/s8u8r66tveVXIM77+J+yW7duzW8jtYxAlQRi+Fm5HDJeEWfeVwnWbnItUJn3W7ZsEfrneqQ0rloC8VaP8aS/uJRp3k+ePDkzUTmezrNP92No+dd//ddJ+BnDuhtuuCE1/IxVYgAal0rQmbzZ54/Kh4F4FqeFAAECBAgQIECAAAECBAgQIECAAIHiCZQqAI2B5cUXXxzWrFkT3vSmN4V//ud/DieeeGKPo3L44Ycn6zZs2JC6TaX8uOOOS12vkAABAgQIECBAgAABAgQIECBAgACBfAuUJgCN9/G49NJLw9NPPx2OOeaYJPz8pV/6pV71586dm6xfuXLlftvF+1ved999SfnMmTP3W6+AAAECBAgQIECAAAECBAgQIECAAIH8C5QmAL3rrrvCE088kVzWft1114WxY8f2qT9nzpwwbdq0sH79+rB8+fIu299yyy3h5ZdfDlOnTg3xIUcWAgQIECBAgAABAgQIECBAgAABAgSKJ1CKhyDFm9bHy93j8vOf/zzMnz+/x5F485vfHD7/+c8n6+MTEBcuXBjiQ5Kuueaa8PDDD4fp06cnQWp8HZ8Sd8kllyRPw+1xh1YQIECAAAECBAgQIECAAAECBAgQIJBbgVIEoM8880yXBxnt2rWrR/COjo4u60477bSwZMmSJAC9//77Q/yKSzwz9MMf/nCYMWNGl+29IUCAAAECBAgQIECAAAECBAgQIECgOAKlCECPPfbY8OCDD2ZWnzVrVrj99tuTS943btwY4sORJk2aFBoaSnOHgMw2KhIgQIAAAQIECBAgQIAAAQIECBAoskApAtBqDUBLS0uIXxYCBAgQIECAAAECBAgQIECAAAECBMoh4BTHcoyjXhAgQIAAAQIECBAgQIAAAQIECBAgkCIgAE1BUUSAAAECBAgQIECAAAECBAgQIECAQDkEBKDlGEe9IECAAAECBAgQIECAAAECBAgQIEAgRUAAmoKiiAABAgQIECBAgAABAgQIECBAgACBcggIQMsxjnpBgAABAgQIECBAgAABAgQIECBAgECKgAA0BUURAQIECBAgQIAAAQIECBAgQIAAAQLlEBCAlmMc9YIAAQIECBAgQIAAAQIECBAgQIAAgRQBAWgKiiICBAgQIECAAAECBAgQIECAAAECBMohIAAtxzjqBQECBAgQIECAAAECBAgQIECAAAECKQIC0BQURQQIECBAgAABAgQIECBAgAABAgQIlENAAFqOcdQLAgQIECBAgAABAgQIECBAgAABAgRSBASgKSiKCBAgQIAAAQIECBAgQIAAAQIECBAoh4AAtBzjqBcECBAgQIAAAQIECBAgQIAAAQIECKQICEBTUBQRIECAAAECBAgQIECAAAECBAgQIFAOAQFoOcZRLwgQIECAAAECBAgQIECAAAECBAgQSBEQgKagKCJAgAABAgQIECBAgAABAgQIECBAoBwCAtByjKNeECBAgAABAgQIECBAgAABAgQIECCQIlD1APTmm28OH/rQh8KTTz6Zcrj0oquvvjq89a1vDZ/4xCfSN1BKgAABAgQIECBAgAABAgQIECBAgACBDAJVD0DvvPPO8OlPfzo888wz/W7OqlWrwsMPP3xAoWm/d25DAgQIECBAgAABAgQIECBAgAABAgQGrUBTPXu+a9eusH79+vD4448nzRgxYkQ9m+PYBAgQIECAAAECBAgQIECAAAECBAiUTGBAAeg73/nO8O1vf7sLyc6dO5P38+fPDw0NvZ9gGrfdvXt3Z/2TTz6587UXBAgQIECAAAECBAgQIECAAAECBAgQGKjAgALQT33qU2HGjBmhEnru25i0sn3Xd399wgknhN/93d/tXuw9AQIECBAgQIAAAQIECBAgQIAAAQIEMgsMKAA99thjw0033RT+67/+q7MBy5cvDz/5yU/C29/+9nDkkUd2lqe9GDp0aBg5cmQ46qijwu///u+HQw89NG0zZQQIECBAgAABAgQIECBAgAABAgQIEMgkMKAANB7xwgsvTL4qR4+XxccA9IMf/GCIry0ECBAgQIAAAQIECBAgQIAAAQIECBCol8CAA9DuDf/jP/7j8Na3vjUcc8wx3Vd5T4AAAQIECBAgQIAAAQIECBAgQIAAgYMqUPUA9LzzzjuoHXAwAgQIECBAgAABAgQIECBAgAABAgQI9CRQ9QB03wO99NJL4amnngqvvvpq6Ojo2HdV6uu3vOUtYfr06anrFBIgQIAAAQIECBAgQIAAAQIECBAgQOBABWoSgMbQ8/LLLw/f+MY3+hV8Vhq9aNGicOWVV1be+k6AAAECBAgQIECAAAECBAgQIECAAIEBCVQ9AN22bVt497vfHX70ox8NqGEqEyBAgAABAgQIECBAgAABAgQIECBAYKACVQ9Ar7rqqs7wM17O/gd/8Adh2rRpYdKkSWHIkCG9tvfNb35zr+utJECAAAECBAgQIECAAAECBAgQIECAwIEIVD0A/e53v5scf9asWWHlypXhsMMOO5D22JYAAQIECBAgQIAAAQIECBAgQIAAAQJVE2io2p5e39GuXbvC448/nuzy/e9/v/Czmrj2RYAAAQIECBAgQIAAAQIECBAgQIDAAQtUNQBtbGwMI0eOTBoRzwC1ECBAgAABAgQIECBAgAABAgQIECBAoJ4CVQ1AY0d+/dd/PenPs88+m3z3BwECBAgQIECAAAECBAgQIECAAAECBOolUPUA9Kyzzkr68vnPf75efXJcAgQIECBAgAABAgQIECBAgAABAgQIJAJVD0Avvvji8J73vCesWrUq/OVf/mXYtm0bagIECBAgQIAAAQIECBAgQIAAAQIECNRFoOpPgV+3bl1YuHBhWL16dfjHf/zHcOutt4aTTjopTJ06NUyYMKHXTsazR88888xet7GSAAECBAgQIECAAAECBAgQIECAAAEC/RWoegD6N3/zN+Gee+7pPP6mTZvCihUrOt/39qKpqUkA2huQdQQIECBAgAABAgQIECBAgAABAgQIHJBA1S+BP6Cj25gAAQIECBAgQIAAAQIECBAgQIAAAQI1FKj6GaC33XZb6OjoyNTkQw45JFM9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976XvJwxY0alyHcCBAgQIECAAAECBAgQIECAAAECBAgMWKCqAWhsze/8zu8kjVq0aFH40Y9+1GcD40OQvvSlLyXbnXTSSX1ubwMCBAgQIECAAAECBAgQIECAAAECBAj0V6DqAegHPvCBEC9l37ZtW5gzZ06IT4V/6aWXurRnz549yb1CP/ShD4V3v/vdYffu3eHkk08+oPuGdtmhNwQIECBAgAABAgQIECBAgAABAgQIEEgRqHoA+uY3vzn80z/9U3Ko1tbW8PGPfzxMnDgxjBo1Khx33HHh6KOPDsOHDw9HHXVU+PSnPx3a2tqS91/5yldCU1NTShMVESBAgAABAgQIECBAgAABAgQIECBAIJtA1QPQ2IwFCxaEb3zjG2HKlCmdrdq+fXv44Q9/GDZs2BDa29s7y3/7t387fP/73w/HHntsZ5kXBAgQIECAAAECBAgQIECAAAECBAgQqIZAzU65jPcCPeecc0K8x+fdd9+dBJ8/+9nPwogRI0I8SzR+nXrqqeHMM8+sRj/sgwABAgQIECBAgAABAgQIECBAgAABAvsJ1CwAjUeK9wKNZ3jGLwsBAgQIECBAgAABAgQIECBAgAABAgQOtkBNLoE/2J1wPAIECBAgQIAAAQIECBAgQIAAAQIECKQJCEDTVJQRIECAAAECBAgQIECAAAECBAgQIFAKAQFoKYZRJwgQIECAAAECBAgQIECAAAECBAgQSBMQgKapKCNAgAABAgQIECBAgAABAgQIECBAoBQCAtBSDKNOECBAgAABAgQIECBAgAABAgQIECCQJiAATVNRRoAAAQIECBAgQIAAAQIECBAgQIBAKQQEoKUYRp0gQIAAAQIECBAgQIAAAQIECBAgQCBNQACapqKMAAECBAgQIECAAAECBAgQIECAAIFSCAhASzGMOkGAAAECBAgQIECAAAECBAgQIECAQJqAADRNRRkBAgQIECBAgAABAgQIECBAgAABAqUQEICWYhh1ggABAgQIECBAgAABAgQIECBAgACBNAEBaJqKMgIECBAgQIAAAQIECBAgQIAAAQIESiHQVIpe6ERhBRYsWNBj25cuXdrjOisIECBAgAABAgQIECBAgAABAgQI9EfAGaD9UbINAQIECBAgQIAAAQIECBAgQIAAAQKFFBCAFnLYNJoAAQIECBAgQIAAAQIECBAgQIAAgf4ICED7o2QbAgQIECBAgAABAgQIECBAgAABAgQKKSAALeSwaTQBAgQIECBAgAABAgQIECBAgAABAv0REID2R8k2BAgQIECAAAECBAgQIECAAAECBAgUUkAAWshh02gCBAgQIECAAAECBAgQIECAAAECBPojIADtj5JtCBAgQIAAAQIECBAgQIAAAQIECBAopIAAtJDDptEECBAgQIAAAQIECBAgQIAAAQIECPRHQADaHyXbECBAgAABAgQIECBAgAABAgQIECBQSAEBaCGHTaMJECBAgAABAgQIECBAgAABAgQIEOiPgAC0P0q2IUCAAAECBAgQIECAAAECBAgQIECgkAIC0EIOm0YTIECAAAECBAgQIECAAAECBAgQINAfAQFof5RsQ4AAAQIECBAgQIAAAQIECBAgQIBAIQUEoIUcNo0mQIAAAQIECBAgQIAAAQIECBAgQKA/AgLQ/ijZhgABAgQIECBAgAABAgQIECBAgACBQgoIQAs5bBpNgAABAgQIECBAgAABAgQIECBAgEB/BASg/VGyDQECBAgQIECAAAECBAgQIECAAAEChRQQgBZy2DSaAAECBAgQIECAAAECBAgQIECAAIH+CAhA+6NkGwIECBAgQIAAAQIECBAgQIAAAQIECinQVMhW97PRr776avjoRz8aJk2aFK644ooea7W3t4c77rgjPProo6G1tTVMnz49zJw5M8ybNy80Njb2WM8KAgQIECBAgAABAgQIECBAgAABAgTyLVDaAHTPnj3hqquuCk888URoauq5m5s3bw4XXXRR2LhxYzJShx12WFixYkXy9dBDD4VFixaF5ubmfI+i1hEgQIAAAQIECBAgQIAAAQIECBAgkCpQykvg29rawt///d+H733ve6md3rfw6quvTsLP2bNnh2XLloU777wz3HrrreHoo48ODzzwQLjxxhv33dxrAgQIECBAgAABAgQIECBAgAABAgQKJFC6ADRexn7BBReEu+++OzQ09N69J598MqxevToMHz48LF68OIwdOzYZuilTpoTrr78+ufx9+fLlYdu2bQUaUk0lQIAAAQIECBAgQIAAAQIECBAgQKAi0HtCWNmqIN//4z/+I3z4wx8OL774YohndH7kIx/pteWrVq1K1p9++unhkEMO6bJtvBT+lFNOCa+99lqIIaiFAAECBAgQIECAAAECBAgQIECAAIHiCZQqAH3llVfCEUccES699NJw3XXXhUMPPbTXEVm3bl2yPoalaUsMQOOydu3atNXKCBAgQIAAAQIECBAgQIAAAQIECBDIuUDPTwfKecPTmjd37tzwe7/3e70+9Gjfei+88ELydty4cfsWd76ulFcekNS5otuLl156KcSHLqUtsbyvS/HT6uWxbMiQIZ3Niq9r3a9a77+zM14Q6EWgMu/Nx16QrCqtgHlf2qHVsRSBg/HZJuWwiggcdIHKZ5t4YPP+oPM7YJ0EKvM+frbx+aZOg+CwB1WgMufjQc37vfSlCkDHjx9/QBNq+/btyfaVoLN75TFjxiRFle26r6+8f9vb3hba29srb7t8v/baa8P8+fO7lJXhTbxfauWeqbXqz8SJE2u1a/slcMAC5uMBk6lQcIH4ocm8L/ggav4BCTQ1NYURI0YcUB0bEyi6QJzz5n3RR1H7D0SgpaXlQDa3LYFSCJj3e4exVAHogczM3bt3hx07diRVRo8enVp11KhRSXlP4WZqJYUHTWDevHm9HmvFihW9rreSAAECBAgQIECAAAECBAgQIECg/AKDNgCNpwDHp7+3tbX1ePZmJfhsbm7udSZUHpaUtlG8D2llP2nri1TW2NjYeXuBnTt3hhgi13IZqNtA69eyb/ZdHIE47+NXfCCahcBgEIj/5sWzP+MtXMz7wTDi+hgFhg4dmsz5jo4OIARKLxB/xld+v9m1a1cw70s/5Dr4ukD8/T/+rI+fbXq6fR0oAmUSiFe2xN9j41KmeT9s2LDMwzRoA9AoFi+Zj/f33LZtWypgpXzkyJGp6yuFn//85ysv9/ve2toa4sOZyrBEh31vCxDD41ouA3UbaP1a9s2+iyMQ5308S9x8Ks6YaenABCZMmND5n13m/cAs1S6OQJz38T9Ot27dWpxGaymBjAIx/KxcDhmviDPvM0KqViiByrzfsmWL0L9QI6exWQXirR7jSX9xKdO8nzx5claSUKqnwB+oQuWeoZWgs3v9yoeBvp4m372e9wQIECBAgAABAgQIECBAgAABAgQI5ENgUAeghx9+eDIKGzZsSB2NSvlxxx2Xul4hAQIECBAgQIAAAQIECBAgQIAAAQL5FhjUAejcuXOT0Vm5cuV+oxTvb3nfffcl5TNnztxvvQICBAgQIECAAAECBAgQIECAAAECBPIvMKgD0Dlz5oRp06aF9evXh+XLl3cZrVtuuSW8/PLLYerUqWH27Nld1nlDgAABAgQIECBAgAABAgQIECBAgEAxBAb1Q5DiExAXLlwYrrjiinDNNdeEhx9+OEyfPj088cQTyev4lLhLLrkkeRpuMYZTKwkQIECAAAECBAgQIECAAAECBAgQ2FdgUJ8BGiFOO+20sGTJkjBp0qRw//33h5tvvjkJP+OZoZ/85CfDjBkz9vXymgABAgQIECBAgAABAgQIECBAgACBAgmU+gzQGG4++OCDfQ7HrFmzwu23355c8r5x48YQH44UA9GGhkGfD/dpZwMCBAgQIECAAAECBAgQIECAAAECeRYodQB6oPAtLS0hflkIECBAgAABAgQIECBAgAABAgQIECiHgFMcyzGOekGAAAECBAgQIECAAAECBAgQIECAQIqAADQFRREBAgQIECBAgAABAgQIECBAgAABAuUQEICWYxz1ggABAgQIECBAgAABAgQIECBAgACBFAEBaAqKIgIECBAgQIAAAQIECBDzFtcpAAAwMUlEQVQgQIAAAQIEyiEgAC3HOOoFAQIECBAgQIAAAQIECBAgQIAAAQIpAgLQFBRFBAgQIECAAAECBAgQIECAAAECBAiUQ0AAWo5x1AsCBAgQIECAAAECBAgQIECAAAECBFIEBKApKIoIECBAgAABAgQIECBAgAABAgQIECiHgAC0HOOoFwQIECBAgAABAgQIECBAgAABAgQIpAgIQFNQFBEgQIAAAQIECBAgQIAAAQIECBAgUA4BAWg5xlEvCBAgQIAAAQIECBAgQIAAAQIECBBIERCApqAoIkCAAAECBAgQIECAAAECBAgQIECgHAIC0HKMo14QIECAAAECBAgQIECAAAECBAgQIJAiIABNQVFEgAABAgQIECBAgAABAgQIECBAgEA5BASg5RhHvSBAgAABAgQIECBAgAABAgQIECBAIEVAAJqCoogAAQIECBAgQIAAAQIECBAgQIAAgXIICEDLMY56QYAAAQIECBAgQIAAAQIECBAgQIBAioAANAVFEQECBAgQIECAAAECBAgQIECAAAEC5RAQgJZjHPWCAAECBAgQIECAAAECBAgQIECAAIEUAQFoCooiAgQIECBAgAABAgQIECBAgAABAgTKISAALcc46gUBAgQIECBAgAABAgQIECBAgAABAikCAtAUFEUECBAgQIAAAQIECBAgQIAAAQIECJRDQABajnHUCwIECBAgQIAAAQIECBAgQIAAAQIEUgQEoCkoiggQIECAAAECBAgQIECAAAECBAgQKIeAALQc46gXBAgQIECAAAECBAgQIECAAAECBAikCAhAU1AUESBAgAABAgQIECBAgAABAgQIECBQDgEBaDnGUS8IECBAgAABAgQIECBAgAABAgQIEEgREICmoCgiQIAAAQIECBAgQIAAAQIECBAgQKAcAgLQcoyjXhAgQIAAAQIECBAgQIAAAQIECBAgkCIgAE1BUUSAAAECBAgQIECAAAECBAgQIECAQDkEBKDlGEe9IECAAAECBAgQIECAAAECBAgQIEAgRUAAmoKiiAABAgQIECBAgAABAgQIECBAgACBcggIQMsxjnpBgAABAgQIECBAgAABAgQIECBAgECKgAA0BUURAQIECBAgQIAAAQIECBAgQIAAAQLlEBCAlmMc9YIAAQIECBAgQIAAAQIECBAgQIAAgRQBAWgKiiICBAgQIECAAAECBAgQIECAAAECBMohIAAtxzjqBQECBAgQIECAAAECBAgQIECAAAECKQIC0BQURQQIECBAgAABAgQIECBAgAABAgQIlENAAFqOcdQLAgQIECBAgAABAgQIECBAgAABAgRSBASgKSiKCBAgQIAAAQIECBAgQIAAAQIECBAoh4AAtBzjqBcECBAgQIAAAQIECBAgQIAAAQIECKQICEBTUBQRIECAAAECBAgQIECAAAECBAgQIFAOAQFoOcZRLwgQIECAAAECBAgQIECAAAECBAgQSBEQgKagKCJAgAABAgQIECBAgAABAgQIECBAoBwCAtByjKNeECBAgAABAgQIECBAgAABAgQIECCQItCUUqaIQC4EFixYkIt2aAQBAgQIECBAgAABAgQIECBAgEBxBZwBWtyx03ICBAgQIECAAAECBAgQIECAAAECBPoQEID2AWQ1AQIECBAgQIAAAQIECBAgQIAAAQLFFRCAFnfstJwAAQIECBAgQIAAAQIECBAgQIAAgT4EBKB9AFlNgAABAgQIECBAgAABAgQIECBAgEBxBQSgxR07LSdAgAABAgQIECBAgAABAgQIECBAoA8BAWgfQFYTIECAAAECBAgQIECAAAECBAgQIFBcAQFoccdOywkQIECAAAECBAgQIECAAAECBAgQ6ENAANoHkNUECBAgQIAAAQIECBAgQIAAAQIECBRXQABa3LHTcgIECBAgQIAAAQIECBAgQIAAAQIE+hAQgPYBZDUBAgQIECBAgAABAgQIECBAgAABAsUVEIAWd+y0nAABAgQIECBAgAABAgQIECBAgACBPgQEoH0AWU2AAAECBAgQIECAAAECBAgQIECAQHEFmorb9GK0vKGhIQwfPrwYje2jlUOHDu3corm5ufN1Xl+UxT2vvoOlXZV5bz4NlhHXzyFDhnQimPedFF6UXCDO+6amptJ8Ziv5cOneAAXiXK8s5n1FwveyCzQ2NiZdHDZsWKh8vi97n/VvcAtU5nxUMO/3zoU3/vUb3HOjZr2PP1xHjBhRs/3Xa8exT3nv17hx4+rF47glFDCfSjioutSrQAyEzPteiawsmUD8RSH+gmAhMJgE4pw37wfTiOvrmDFjIBAYdALm/d4hF4DWeOq3t7eHLVu21PgoB2f3I0eODJW/OJs3bw5tbW0H58AZj/LTn/40Y03VCLwhEOf96NGjw4svvvhGoVcESiwwYcKE5Ey4PXv2mPclHmdd6yoQ5338zLZ169auK7wjUEKBeCVXS0tL0rPt27eb9yUcY13aX6Ay7zdt2hQ6Ojr230AJgZIJxBMZKldzlWneT548OfNIuQdoZjoVCRAgQIAAAQIECBAgQIAAAQIECBDIu4AANO8jpH0ECBAgQIAAAQIECBAgQIAAAQIECGQWEIBmplORAAECBAgQIECAAAECBAgQIECAAIG8CwhA8z5C2keAAAECBAgQIECAAAECBAgQIECAQGYBAWhmOhUJECBAgAABAgQIECBAgAABAgQIEMi7gAA07yOkfQQIECBAgAABAgQIECBAgAABAgQIZBYQgGamU5EAAQIECBAgQIAAAQIECBAgQIAAgbwLCEDzPkLaR4AAAQIECBAgQIAAAQIECBAgQIBAZgEBaGY6FQkQIECAAAECBAgQIECAAAECBAgQyLuAADTvI6R9BAgQIECAAAECBAgQIECAAAECBAhkFhCAZqZTkQABAgQIECBAgAABAgQIECBAgACBvAsIQPM+QtpHgAABAgQIECBAgAABAgQIECBAgEBmgabMNVUkkHOBBQsW9NjCpUuX9rjOCgIECBAgQIAAAQIECBAgQIAAgfIIOAO0PGOpJwQIECBAgAABAgQIECBAgAABAgQIdBMQgHYD8ZYAAQIECBAgQIAAAQIECBAgQIAAgfIICEDLM5Z6QoAAAQIECBAgQIAAAQIECBAgQIBANwEBaDcQbwkQIECAAAECBAgQIECAAAECBAgQKI+AALQ8Y6knBAgQIECAAAECBAgQIECAAAECBAh0ExCAdgPxlgABAgQIECBAgAABAgQIECBAgACB8ggIQMszlnpCgAABAgQIECBAgAABAgQIECBAgEA3AQFoNxBvCRAgQIAAAQIECBAgQIAAAQIECBAoj4AAtDxjqScECBAgQIAAAQIECBAgQIAAAQIECHQTEIB2A/GWAAECBAgQIECAAAECBAgQIECAAIHyCAhAyzOWekKAAAECBAgQIECAAAECBAgQIECAQDcBAWg3EG8JECBAgAABAgQIECBAgAABAgQIECiPgAC0PGOpJwQIECBAgAABAgQIECBAgAABAgQIdBNo6vbeWwKDQmDBggW99nPp0qW9rreSAAECBAgQIECAAAECBAgQIECgGALOAC3GOGklAQIECBAgQIAAAQIECBAgQIAAAQIZBASgGdBUIUCAAAECBAgQIECAAAECBAgQIECgGAIC0GKMk1YSIECAAAECBAgQIECAAAECBAgQIJBBQACaAU0VAgQIECBAgAABAgQIECBAgAABAgSKISAALcY4aSUBAgQIECBAgAABAgQIECBAgAABAhkEBKAZ0FQhQIAAAQIECBAgQIAAAQIECBAgQKAYAgLQYoyTVhIgQIAAAQIECBAgQIAAAQIECBAgkEFAAJoBTRUCBAgQIECAAAECBAgQIECAAAECBIohIAAtxjhpJQECBAgQIECAAAECBAgQIECAAAECGQQEoBnQVCFAgAABAgQIECBAgAABAgQIECBAoBgCAtBijJNWEiBAgAABAgQIECBAgAABAgQIECCQQUAAmgFNFQIECBAgQIAAAQIECBAgQIAAAQIEiiEgAC3GOGklAQIECBAgQIAAAQIECBAgQIAAAQIZBJoy1FGFQOkFFixYkLmPS5cuzVy3lhV761MR2xyt8truWo5j1n33Nv4ss6qqR4AAAQIECBAgQIAAAQJFEHAGaBFGSRsJECBAgAABAgQIECBAgAABAgQIEMgkIADNxKYSAQIECBAgQIAAAQIECBAgQIAAAQJFEBCAFmGUtJEAAQIECBAgQIAAAQIECBAgQIAAgUwCAtBMbCoRIECAAAECBAgQIECAAAECBAgQIFAEAQFoEUZJGwkQIECAAAECBAgQIECAAAECBAgQyCQgAM3EphIBAgQIECBAgAABAgQIECBAgAABAkUQEIAWYZS0kQABAgQIECBAgAABAgQIECBAgACBTAIC0ExsKhEgQIAAAQIECBAgQIAAAQIECBAgUAQBAWgRRkkbCRAgQIAAAQIECBAgQIAAAQIECBDIJCAAzcSmEgECBAgQIECAAAECBAgQIECAAAECRRAQgBZhlLSRAAECBAgQIECAAAECBAgQIECAAIFMAgLQTGwqESBAgAABAgQIECBAgAABAgQIECBQBAEBaBFGSRsJECBAgAABAgQIECBAgAABAgQIEMgk0JSplkoECPQosGDBgh7X9bVi6dKlvW4ykH33tuO+9ttXu3rbdy3X9dbuvLa5L4/e+tRX3TKu782jqGNcxnHSp3wI9Pb3JbbQ35l8jJNWECBAgAABAgSyCvi8l1UuBGeAZrdTkwABAgQIECBAgAABAgQIECBAgACBnAsIQHM+QJpHgAABAgQIECBAgAABAgQIECBAgEB2AQFodjs1CRAgQIAAAQIECBAgQIAAAQIECBDIuYAANOcDpHkECBAgQIAAAQIECBAgQIAAAQIECGQXEIBmt1OTAAECBAgQIECAAAECBAgQIECAAIGcC3gK/OsD1N7eHu64447w6KOPhtbW1jB9+vQwc+bMMG/evNDY2JjzIdQ8AgQIECBAgAABAgQIECBAgAABAgR6Ehj0AejmzZvDRRddFDZu3JgYHXbYYWHFihXJ10MPPRQWLVoUmpube/JTToAAAQIECBAgQIAAAQIECBAgQIBAjgUG/SXwV199dRJ+zp49Oyxbtizceeed4dZbbw1HH310eOCBB8KNN96Y4+HTNAIECBAgQIAAAQIECBAgQIAAAQIEehMY1AHok08+GVavXh2GDx8eFi9eHMaOHZtYTZkyJVx//fXJ5e/Lly8P27Zt683QOgIECBAgQIAAAQIECBAgQIAAAQIEciowqAPQVatWJcNy+umnh0MOOaTLEMVL4U855ZTw2muvhRiCWggQIECAAAECBAgQIECAAAECBAgQKJ7AoA5A161bl4xYvPw9bYkBaFzWrl2btloZAQIECBAgQIAAAQIECBAgQIAAAQI5FxjUD0F64YUXkuEZN25c6jBVyisPSErd6PXCTZs2hT179qSu3r17d2hoKEfOPGTIkM4+xtdl6Vdnp3LwIq+meW1Xb0NWrTZX5n219tdbm+u5roj9K2Kb6znGWY7NOItafusYz97Hxmeb3n2sLY9A5bNN7JF5X55x1ZPeBSrzPv5b6N/D3q2sLbZAZX5X5nzsjXm/d0wHdQC6ffv2RKESdO4leePPMWPGJG8q272xpuuruXPnhvb29q6Fv3h37bXXhvnz56euK3JhvF9q5Z6pRe5H3to+ceLEvDUpaU9e29UbVrXbXO399db2eqwrYv+K2OZ6jG3WY8YPTYyz6uWznvHsfVyamprCiBEjet/IWgIlE4hz3rwv2aDqTq8CLS0tva63kkDRBdI+75n3e0d10Aag8czMHTt2JAqjR49OneOjRo1KynsKN1MrDcLCFStWDMJe16fLg816sPU3zqrB2Ofe/jbx6E3HOgJdBfx96erhHQECBAgQIECgbAI+72Uf0UEbgMZTgOPT39va2no8e7MSfDY3N/cq/Gu/9mvJw5LSNopnl1b2k7a+SGWNjY0hnh0Rl507d4YYIlsIlF0gzvv4FR+IZiEwGATiv3nx7M94axfzfjCMuD5GgaFDhyZzvqOjAwiB0gvEn/GV32927doVzPvSD7kOvi4Qf/+PP+vjZ5uebl8HikCZBGJ2E3+PjUuZ5v2wYcMyD9OgDUCj2Pjx40O8v+e2bdtSASvlI0eOTF1fKfzCF75Qebnf99bW1vDKK6/sV17Eguiw720BYnhsIVB2gTjv41niZfl7XPbx0r+BC0yYMKHzP7vM+4F72kMxBOK8j/9hvXXr1mI0WCsJDEAghp+VyyHjFXHm/QAwVS2MQGXeb9myRehfmFHT0IEIxJPx4kl/cSnTvJ88eXJmlnI8nSdj92MAGpdK0Nl9N5UPA4ceemj3Vd4TIECAAAECBAgQIECAAAECBAgQIFAAgUEdgB5++OHJEG3YsCF1qCrlxx13XOp6hQQIECBAgAABAgQIECBAgAABAgQI5FtgUAeg8entcVm5cuV+oxTvb3nfffcl5TNnztxvvQICBAgQIECAAAECBAgQIECAAAECBPIvMKgD0Dlz5oRp06aF9evXh+XLl3cZrVtuuSW8/PLLYerUqWH27Nld1nlDgAABAgQIECBAgAABAgQIECBAgEAxBAb1Q5DiExAXLlwYrrjiinDNNdeEhx9+OEyfPj088cQTyev4lLhLLrkkeRpuMYZTKwkQIECAAAECBAgQIECAAAECBAgQ2FdgUJ8BGiFOO+20sGTJkjBp0qRw//33h5tvvjkJP+OZoZ/85CfDjBkz9vXymgABAgQIECBAgAABAgQIECBAgACBAgkM6jNAK+M0a9ascPvttyeXvG/cuDHEhyPFQLShYdDnwxUi3wkQIECAAAECBAgQIECAAAECBAgUUkAAus+wtbS0hPhlIUCAAAECBAgQIECAAAECBAgQIECgHAJOcSzHOOoFAQIECBAgQIAAAQIECBAgQIAAAQIpAgLQFBRFBAgQIECAAAECBAgQIECAAAECBAiUQ0AAWo5x1AsCBAgQIECAAAECBAgQIECAAAECBFIEBKApKIoIECBAgAABAgQIECBAgAABAgQIECiHgAC0HOOoFwQIECBAgAABAgQIECBAgAABAgQIpAgIQFNQFBEgQIAAAQIECBAgQIAAAQIECBAgUA4BAWg5xlEvCBAgQIAAAQIECBAgQIAAAQIECBBIERCApqAoIkCAAAECBAgQIECAAAECBAgQIECgHAIC0HKMo14QIECAAAECBAgQIECAAAECBAgQIJAiIABNQVFEgAABAgQIECBAgAABAgQIECBAgEA5BASg5RhHvSBAgAABAgQIECBAgAABAgQIECBAIEVgyJ7Xl5RyRQT2E1i6dGn41Kc+lZRfddVV4T3vec9+2yggQIAAgWILvOMd7wg/+clPQkNDQ1i7dm2xO6P1BAgQILCfwCOPPBIuvPDCpPzcc88NH//4x/fbRgEBAgQIFFvgox/9aFixYkXSia997WvhmGOOKXaHqtD6pirswy4GicDu3bvDzp07k97u2rVrkPRaNwkQIDC4BOLP+fgVA1ALAQIECJRPwGf68o2pHhEgQKC7QMxsKvmN8x736vjtpvss8Z4AAQIECBAgQIAAAQIECBAgQIAAgdIICEBLM5Q6QoAAAQIECBAgQIAAAQIECBAgQIBAdwEBaHcR7wkQIECAAAECBAgQIECAAAECBAgQKI2AALQ0Q6kjBAgQIECAAAECBAgQIECAAAECBAh0FxCAdhfxngABAgQIECBAgAABAgQIECBAgACB0ggMef1pUHtK0xsdqanAM888E5566qnkGCeccEJ405veVNPj2TkBAgQIHHyBBx54ILz66qthyJAh4Zxzzjn4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AggggAACCCBQhARoAVqEbhZVRQABBBBAAAEEEEAAAQQQQAABBBBAAIHbEyAAente7I0AAggggAACCCCAAAIIIIAAAggggAACRUiALvBF6GZRVQQQQAABBBBAIJQF1q1bJ7/++qv8/fffUrlyZalXr560b99eIiIicrzsGzduyJYtW2T79u2yb98+qVGjhjRu3FgaNWokUVFRjmX3798v//zzj5QoUUKaNGniuI9m6uREly9flvj4eKlfv769n3VOzUhISJAyZcrI9evXzf4bN26Us2fPSlJSkjl2hQoV7HLWwk8//SQnT560VuXQoUOyefNms6710XqREEAAAQQQQAABBIIjUOzWvyk4h+IoCCCAAAIIIIAAAgjcvsCyZcvktddek127dvkUrl27tkycOFFSUlJ8tmnG6tWrTdk//vjDZ7sGHqdNm+ZY9rnnnpOZM2dKTEyM6Czs/lKdOnVEg6WPPvqoLF261N4tKytLypUrZ9bXrFljgrRdu3b1CmrqxsjISJk8ebIMGDDALqsLGtTVgKlT0mPHxcU5bSIPAQQQQAABBBBAIAABusAHgEYRBBBAAAEEEEAAgeAIaICyS5cuJvhptcbs27evaf2pZ9Dgo04UtGjRIp8TalltIarBTy2bmJgovXv3lhYtWpiWnydOnJAePXqIBjvzM2lgtGPHjib4WbduXenQoYNYrT619WhqaqoJgnrWQVt53n///XZW1apV5cEHHzT/aP1ps7CAAAIIIIAAAggERYAAaFAYOQgCCCCAAAIIIIDA7Qrs2LFDhg4dKjdv3hQNAGpLyp9//tm0zNTWoJs2bTJdy7XDUp8+fUy3cuscu3fvljfffNOs1qxZU9avXy+//PKLzJ49W3744QfJzMyUZs2ame3a0vOLL76wigb963vvvSeVKlUy9dd6rVy5Uo4fPy5paWn2ubQVqF6nlfTali9fbq3KK6+8ItotXv/Fxsba+SwggAACCCCAAAII3LkAAdA7N+QICCCAAAIIIIAAAgEIjBs3Tq5cuWJKLliwQFq2bOl1lOTkZBk+fLjJu3DhgixcuNDe3q9fP7l48aJp+Zmeni66r2fSoOh3331nApOar4HWc+fOee4S1GUNdrZp08Y+ZrFixUTrqK1ZNWlL1oyMDHs7CwgggAACCCCAAAIFJ0AAtOCsORMCCCCAAAIIIIDA/wR0/Etr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" width="672" /></p>
<p><span class="pagebreak"></span></p>
<p>A <em>zero-inflated</em> model assumes that the zero observations have two different origins  structural and sampling zeroes.</p>

<div class="example">
<span id="exm:unnamed-chunk-33" class="example"><strong>Example 4.5  </strong></span>
</div>

<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>A zero-inflated model is a <strong>mixture model</strong> because the distribution is a weighted average of the sampling model (i.e.Poisson) and a point-mass at <span class="math inline">\(0\)</span>.</p>
<p>For <span class="math inline">\(Y\sim ZIP(\lambda)\)</span>,</p>
<p><span class="math display">\[
Y \sim \begin{cases}
0 &amp; \text{with probability } \pi \\
\text{Poisson}(\lambda) &amp; \text{with probability } 1-\pi
\end{cases}
\]</span>
So that,</p>
<p><span class="math display">\[
Y = \qquad \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
\]</span></p>
<p>To simulate from this distribution,</p>
<p><br /><br /><br /><br /><br /><br /><br /></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">n &lt;-<span class="st"> </span><span class="dv">1000</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">lambda &lt;-<span class="st"> </span><span class="dv">5</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">pi &lt;-<span class="st"> </span><span class="fl">0.3</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">u &lt;-<span class="st"> </span><span class="kw">rbinom</span>(n, <span class="dv">1</span>, pi)</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">zip &lt;-<span class="st"> </span>u<span class="op">*</span><span class="dv">0</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span><span class="op">-</span>u)<span class="op">*</span><span class="kw">rpois</span>(n, lambda)</a>
<a class="sourceLine" id="cb22-7" data-line-number="7"></a>
<a class="sourceLine" id="cb22-8" data-line-number="8"><span class="co"># zero inflated model</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9"><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(zip), <span class="dt">binwidth =</span> <span class="dv">1</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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tNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhbQABaN52KBAgQIECAAAECBAgQIECAAAECBAg0u4AAtNlHSPsIECBAgAABAgQIECBAgAABAgQIEKhboL3umioSqFOgo6Ojzpqq1RJYsWJFrWJlBAgQIECAAAECBAgQIECAAIGWFHAHaEsOu04TIECAAAECBAgQIECAAAECBAgQaA0BAWhrjLNeEiBAgAABAgQIECBAgAABAgQIEGhJAQFoSw67ThMgQIAAAQIECBAgQIAAAQIECBBoDQEBaGuMs14SIECAAAECBAgQIECAAAECBAgQaEkBAWhLDrtOEyBAgAABAgQIECBAgAABAgQIEGgNAQFoa4yzXhIgQIAAAQIECBAgQIAAAQIECBBoSQEBaEsOu04TIECAAAECBAgQIECAAAECBAgQaA0BAWhrjLNeEiBAgAABAgQIECBAgAABAgQIEGhJAQFoSw67ThMgQIAAAQIECBAgQIAAAQIECBBoDQEBaGuMs14SIECAAAECBAgQIECAAAECBAgQaEkBAWhLDrtOEyBAgAABAgQIECBAgAABAgQIEGgNAQFoa4yzXhIgQIAAAQIECBAgQIAAAQIECBBoSQEBaEsOu04TIECAAAECBAgQIECAAAECBAgQaA0BAWhrjLNeEiBAgAABAgQIECBAgAABAgQIEGhJAQFoSw67ThMgQIAAAQIECBAgQIAAAQIECBBoDQEBaGuMs14SIECAAAECBAgQIECAAAECBAgQaEkBAWhLDrtOEyBAgAABAgQIECBAgAABAgQIEGgNAQFoa4yzXhIgQIAAAQIECBAgQIAAAQIECBBoSQEBaEsOu04TIECAAAECBAgQIECAAAECBAgQaA0BAWhrjLNeEiBAgAABAgQIECBAgAABAgQIEGhJAQFoSw67ThMgQIAAAQIECBAgQIAAAQIECBBoDQEBaGuMs14SIECAAAECBAgQIECAAAECBAgQaEkBAWhLDrtOEyBAgAABAgQIECBAgAABAgQIEGgNAQFoa4yzXhIgQIAAAQIECBAgQIAAAQIECBBoSQEBaEsOu04TIECAAAECBAgQIECAAAECBAgQaA0BAWhrjLNeEiBAgAABAgQIECBAgAABAgQIEGhJAQFoSw67ThMgQIAAAQIECBAgQIAAAQIECBBoDQEBaGuMs14SIECAAAECBAgQIECAAAECBAgQaEkBAWhLDrtOEyBAgAABAgQIECBAgAABAgQIEGgNAQFoa4yzXhIgQIAAAQIECBAgQIAAAQIECBBoSQEBaEsOu04TIECAAAECBAgQIECAAAECBAgQaA2B9rJ18/HHH48vfOELsXHjxujs7Ixjjz02Fi1aFKeffnq/Xd21a1fcfPPNsW7duti6dWvMnz8/Fi5cGGeddVaMHj26z3r11OlzR1YSIECAAAECBAgQIECAAAECBAgQIDBsAqUKQL/73e/Ge9/73njmmWcysEMOOSR+8pOfxBe/+MV46UtfGhdddNEBgea2bdviggsuiM2bN2d1ZsyYEatWrcp+7rnnnli+fHmMHTu2xwDUU6fHDiwQIECAAAECBAgQIECAAAECBAgQIJCLQGkegf/lL38Zf//3f5+Fn69+9avjxhtvjFtvvTWuuuqqmDdvXnzlK1+JT3ziEwegXn755Vn4uXjx4rjtttvilltuiRtuuCGOPvrouOuuu+Laa69tSJ0DdmIFAQIECBAgQIAAAQIECBAgQIAAAQLDLlCaADTdtbljx4444ogj4sILL4zDDz88u9tzyZIlcf7552eQa9as6QH6wAMPxL333hsTJkyIK664IqZOnZqVp31cffXVWf2VK1dm+61UrKdOpa7fBAgQIECAAAECBAgQIECAAAECBAjkK1CaADQ97n7SSSdlYeeoUT27dcopp2Sqjz32WPYdnxXiSiB62mmnxfjx4yurs9/pUfi0v927d0cKQStTPXUqdf0mQIAAAQIECBAgQIAAAQIECBAgQCBfgZ5JYb7HbujRzjnnnPjwhz+cfddn7x1v2rQpW5XuCp0+fXq1eMOGDdl8evy9rykFoGm67777qsX11KlWNkOAAAECBAgQIECAAAECBAgQIECAQK4CpXoJUm+59Kb29evXx0c+8pGsKIWk3adHHnkkW5w2bVr31dX5yvrKC5JSQT11qjvsNnPJJZf0eLS+W1GcffbZkR7dNxEYikDlfB1KHduWR2D06NHR1tYWzoPyjGlZe9Le/rtLj8pXz5S1r/pVfIH02ZqmdK7u37+/+B3Sg9IKdH8Cbty4ca4HSjvS5elY+nx1rpZnPMvcE9eu5Rnd3/0tpDx9ynryoQ99KHt0PT3Cnj5c3/Oe98RZZ53Vo5c7d+7MlvsLDKZMmZKVV7ZLC5X5odTJdtLrP1//+tfjiSee6LX2N4snnHBC9r2kfRZaSaAfgfRdtqbWFkh/+en+B3Rra+h9EQR8bhVhlLQxCfT+qiQqBJpZIF0LuB5o5hHStoqAa9eKhN9FEXDtWpSR6rudpXkEvnf3/ud//idmzZqV/eG/d+/eSN/d+eijj1Y327dvX/bG+LQifX9oX9PkyZOz1elO0jTVUyer6D8ECBAgQIAAAQIECBAgQIAAAQIECIyIQGnvAL3++uuzx0H37NkTn/vc5+Izn/lMrFu3Lq655po47rjjIv1rU0rvOzs7oxJw9h6ByvqxY8dmRfXU6b3PynJqU1dXV2Wxx+9JkybFr371qx7rLBAYSMA5M5BQucvTXenpM+Wpp54qd0f1rvAC6VwdM2ZM1o/HH3/cY8WFH9FydyA9npmeCNqyZUv2D+Hl7q3eFVkgfa5WnlB7+umnq0+tFblP2l5uAdeu5R7fMvXOtWtzjebs2bPrblBpA9D0XXhpShcDb37zm+P//u//4mtf+1p89rOfjfR4fJrSHaLp+z137NiRLff+T2V9CiQrUz11KnW7/54/f373xR7z27Zty4LZHistEBhAoL9AfYBqikskkL6fznlQogEtaVe6f49iOl+7L5e0y7pVYIHKY8TpXE1PApkINKtA5ftqU/tcDzTrKGlXb4H0ueratbeK5WYT6H6t6tq12UZnaO0p7SPwvRnOOOOMbNVPfvKTalEKM9NUCTqrBb+d2b59ezbX/c3x9dTpvV/LBAgQIECAAAECBAgQIECAAAECBAjkI1CaADTd2XnFFVfEY4891qdc5XG7yr/kp43mzJmTbbtp06Y+61TWL1iwoFpeT51qZTMECBAgQIAAAQIECBAgQIAAAQIECOQqUJoA9N57742vfvWr8c1vfrNPwPXr12frn/e851XLly5dms2vXr26uq4yk27Hv+OOO7LFhQsXVlZHPXWqlc0QIECAAAECBAgQIECAAAECBAgQIJCrQGkC0Eowme4EfeSRR3ogpvDzxhtvzNadc8451bIlS5bEvHnzYuPGjbFy5crq+jSTXqKUvvD+yCOPjMWLF1fL6qlTrWyGAAECBAgQIECAAAECBAgQIECAAIFcBUrzEqQUbH7nO9+JtWvXxute97o48cQTY9GiRfGzn/0su5MzfXHta1/72kgBZmVKL0patmxZXHLJJXHllVdmddPLie6///5sPj02f9FFF2Vvkz+YOpW6fhMgQIAAAQIECBAgQIAAAQIECBAgkK9A26+Dwf35HnL4jrZ79+7493//9/j85z8fu3btqh4ofW/nhRdeGKeffnp1XfeZdIdoCkAfffTR6up0Z+g73vGOeOELX1hd132mnjrd69eaL/tb4Ds6Omp1X1mdAitWrKizpmplEEgvaNuzZ088+eSTZeiOPpRYYObMmTF27Nish+nP3RJdhpR41Fq3a+PHj4/0Msz0HfPeAt+650ERej5u3LiYMWNG1tSdO3dG5WWuRWi7NramQLp2TX9/d6625vgXqdeuXZtrtA477LC6G1SaO0CTQPoL1Rvf+MZ4/etfHw8//HBs3bo1nv3sZ0c6YWtN6U7Rm266KXvkffPmzdnLkebOnRujRvX/DQH11KnVBmUECBAgQIAAAQIECBAgQIAAAQIECDReoFQBaIUnvek93cGZfoYypaB0oLC09/7qqdN7H5YJECBAgAABAgQIECBAgAABAgQIEBgegf5vcRye49krAQIECBAgQIAAAQIECBAgQIAAAQIEchMQgOZG7UAECBAgQIAAAQIECBAgQIAAAQIE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uy+Xra/6U3yB0aNHZ51I/8DkEfjij2eZe9D9EXjXA2Ue6fL0zbVrecay7D3pfq3q2rXYo+0lSMUeP60nQIAAAQIECBAgQIAAAQIECBAgQKCGgAC0Bo4iAgQIECBAgAABAgQIECBAgAABAgSKLSAALfb4aT0BAgQIECBAgAABAgQIECBAgAABAjUEBKA1cBQRIECAAAECBAgQIECAAAECBAgQIFBsAQFoscdP6wkQIECAAAECBAgQIECAAAECBAgQqCEgAK2Bo4gAAQIECBAgQIAAAQIECBAgQIAAgWILCECLPX5aT4AAAQIECBAgQIAAAQIECBAgQIBADQEBaA0cRQQIECBAgAABAgQIECBAgAABAgQIFFtAAFrs8dN6AgQIECBAgAABAgQIECBAgAABAgRqCAhAa+AoIkCAAAECBAgQIECAAAECBAgQIECg2AIC0GKPn9YTIECAAAECBAgQIECAAAECBAgQIFBDQABaA0cRAQIECBAgQIAAAQIECBAgQIAAAQLFFhCAFnv8tJ4AAQIECBAgQIAAAQIECBAgQIAAgRoCAtAaOIoIECBAgAABAgQIECBAgAABAgQIECi2gAC02OOn9QQIECBAgAABAgQIECBAgAABAgQI1BAQgNbAUUSAAAECBAgQIECAAAECBAgQIECAQLEFBKDFHj+tJ0CAAAECBAgQIECAAAECBAgQIECghoAAtAaOIgIECBAgQIAAAQIECBAgQIAAAQIEii0gAC32+Gk9AQIECBAgQIAAAQIECBAgQIAAAQI1BASgNXAUESBAgAABAgQIECBAgAABAgQIECBQbAEBaLHHT+sJECBAgAABAgQIECBAgAABAgQIEKghIACtgaOIAAECBAgQIECAAAECBAgQIECAAIFiCwhAiz1+Wk+AAAECBAgQIECAAAECBAgQIECAQA0BAWgNHEUECBAgQIAAAQIECBAgQIAAAQIECBRbQABa7PHTegIECBAgQIAAAQIECBAgQIAAAQIEaggIQGvgKCJAgAABAgQIECBAgAABAgQIECBAoNgCAtBij5/WEyBAgAABAgQIECBAgAABAgQIECBQQ0AAWgNHEQECBAgQIECAAAECBAgQIECAAAECxRYQgBZ7/LSeAAECBAgQIECAAAECBAgQIECAAIEaAgLQGjiKCBAgQIAAAQIECBAgQIAAAQIECBAotoAAtNjjp/UECBAgQIAAAQIECBAgQIAAAQIECNQQEIDWwFFEgAABAgQIECBAgAABAgQIECBAgECxBQSgxR4/rSdAgAABAgQIECBAgAABAgQIECBAoIaAALQGjiICBAgQIECAAAECBAgQIECAAAECBIotIAAt9vhpPQECBAgQIECAAAECBAgQIECAAAECNQQEoDVwFBEgQIAAAQIECBAgQIAAAQIECBAgUGwBAWixx0/rCRAgQIAAAQIECBAgQIAAAQIECBCoISAArYGjiAABAgQIECBAgAABAgQIECBAgACBYgsIQIs9flpPgAABAgQIECBAgAABAgQIECBAgEANAQFoDRxFBAgQIECAAAECBAgQIECAAAECBAgUW0AAWuzx03oCBAgQIECAAAECBAgQIECAAAECBGoICEBr4CgiQIAAAQIECBAgQIAAAQIECBAgQKDYAgLQYo+f1hMgQIAAAQIECBAgQIAAAQIECBAgUENAAFoDRxEBAgQIECBAgAABAgQIECBAgAABAsUWEIAWe/y0ngABAgQIECBAgAABAgQIECBAgACBGgIC0Bo4iggQIECAAAECBAgQIECAAAECBAgQKLaAALTY46f1BAgQIECAAAECBAgQIECAAAECBAjUEBCA1sBRRIAAAQIECBAgQIAAAQIECBAgQIBAsQUEoMUeP60nQIAAAQIECBAgQIAAAQIECBAgQKCGgAC0Bo4iAgQIECBAgAABAgQIECBAgAABAgSKLSAALfb4aT0BAgQIECBAgAABAgQIECBAgAABAjUEBKA1cBQRIECAAAECBAgQIECAAAECBAgQIFBsAQFoscdP6wkQIECAAAECBAgQIECAAAECBAgQqCEgAK2Bo4gAAQIECBAgQIAAAQIECBAgQIAAgWILCECLPX5aT4AAAQIECBAgQIAAAQIECBAgQIBADYH2GmWFLNqyZUv8x3/8Rzz44IPx2GOPxZw5c+Koo46K1772tTF79uw++7Rr1664+eabY926dbF169aYP39+LFy4MM4666wYPXp0w+r0uSMrCRAgQIAAAQIECBAgQIAAAQIECBAYNoFSBaBr1qyJK6+8Mjo7O7PgcubMmfG9730v7r333vjyl78c7373u2Pp0qU9MLdt2xYXXHBBbN68OVs/Y8aMWLVqVfZzzz33xPLly2Ps2LEHXafHDiwQIECAAAECBAgQ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1qzJXkA0lNB0sPu2HQECBAgQIECAAAECBAgQIECAAAECrSswoo/Ap5cVbdy4MX7wgx9kIzBx4sTWHQk9J0CAAAECBAgQIECAAAECBAgQIECg4QIHFYC+7GUvi2984xs9GrVnz55s+Zxzzqn5EqG0Udp237591fonnnhidd4MAQIECBAgQIAAAQIECBAgQIAAAQIEDlbgoALQD3/4w3H88cdnQWbvhlSC0N7r+1t+wQteEK985Sv7K7aeAAECBAgQIECAAAECBAgQIECAAAECQxY4qAD0mGOOiU984hPx3//939UDr1y5Mv73f/83XvKSl8Szn/3s6vq+ZsaMGROTJk2Ko446Kl7zmtfE9OnT+9rMOgIECBAgQIAAAQIECBAgQIAAAQIECNQlcFABaDrim9/85uyncvT0WHwKQN/2trdFmjcRIECAAAECBAgQIECAAAECBAgQIEBgpAQOOgDt3fA3vOENcfLJJ8fzn//83kWWCRAgQIAAAQIECBAgQIAAAQIECBAgkKtAwwPQc889N9cOOBgBAgQIECBAgAABAgQIECBAgAABAgT6E2h4ANr9QL/85S/jJz/5STz99NPR1dXVvajP+ec973kxf/78PsusJECAAAECBAgQIECAAAECBAgQIECAwFAFhiUATaHne9/73vjSl740qOCz0ujly5fHpZdeWln0mwABAgQIECBAgAABAgQIECBAgAABAgcl0PAAdMeOHXH22WfHT3/604NqmMoECBAgQIAAAQIECBAgQIAAAQIECBA4WIGGB6CXXXZZNfxMj7P/2Z/9WcybNy/mzp0bbW1tNdv73Oc+t2a5QgIECBAgQIAAAQIECBAgQIAAAQIECAxFoOEB6Le+9a3s+IsWLYrVq1fHjBkzhtIe2xIgQIAAAQIECBAgQIAAAQIECBAgQKBhAqMatqdf72jv3r3xgx/8INvlm970JuFnI3HtiwABAgQIECBAgAABAgQIECBAgACBIQs0NAAdPXp0TJo0KWtEugPURIAAAQIECBAgQIAAAQIECBAgQIAAgZEUaGgAmjry+7//+1l/Hnrooey3/xAgQIAAAQIECBAgQIAAAQIECBAgQGCkBBoegJ555plZXz71qU+NVJ8clwABAgQIECBAgAABAgQIECBAgAABAplAwwPQCy+8MF71qlfFmjVr4q/+6q9ix44dqAkQIECAAAECBAgQIECAAAECBAgQIDAiAg1/C/yGDRti2bJlce+998Y//dM/xQ033BAnnHBCHHnkkTF79uyanUx3j55xxhk1t1FIgAABAgQIECBAgAABAgQIECBAgACBwQo0PAD927/92/jKV75SPf6vfvWrWLVqVXW51kx7e7sAtBaQMgIECBAgQIAAAQIECBAgQIAAAQIEhiTQ8Efgh3R0GxMgQIAAAQIECBAgQIAAAQIECBAgQGAYBRp+B+iNN94YXV1ddTV5/PjxddVTiQABAgQIECBAgAABAgQIECBAgAABAn0JNDwAnTx5cl/HsY4AAQIECBAgQIAAAQIECBAgQIAAAQK5C3gEPndyByRAgAABAgQIECBAgAABAgQIECBAIC8BAWhe0o5DgAABAgQIECBAgAABAgQIECBAgEDuAg1/BH7jxo2xbdu2ujpyxBFHxOGHH15XXZUIECBAgAABAgQIECBAgAABAgQIECDQW6DhAejb3/72+MpXvtL7OINavvTSS2P58uWD2tZGBAgQIECAAAECBAgQIECAAAECBAgQGEjAI/ADCSknQIAAAQIECBAgQIAAAQIECBAgQKCwAg2/A/Sd73xnvPa1r+0XZO/evbF9+/b4+c9/Hl/+8pez3y996UvjX//1X2PKlCn91lNAgAABAgQIECBAgAABAgQIECBAgACBoQo0PABdunTpoNtw2WWXxate9arskfmrrroqrrnmmkHXtSEBAgQIECBAgAABAgQIECBAgAABAgQGEhjRR+DTHZ/p+0LTi48+8pGPxB133DFQe5UTIECAAAECBAgQIECAAAECBAgQIEBg0AIjGoCmVo4dOzb++I//OGvwN7/5zUE33IYECBAgQIAAAQIECBAgQIAAAQIECBAYSGDEA9DUwBe84AVZO+++++6B2qucAAECBAgQIECAAAECBAgQIECAAAECgxZoigB0zZo1WYPHjBkz6IbbkAABAgQIECBAgAABAgQIECBAgAABAgMJjHgAmr4DdPXq1Vk7TzzxxIHaq5wAAQIECBAgQIAAAQIECBAgQIAAAQKDFmj4W+C/+MUvxqZNm2o2oKurK55++ulYv3593Hbbbdm2bW1t8ZKXvKRmPYUECBAgQIAAAQIECBAgQIAAAQIECBAYikDDA9B/+7d/y97sPpRGpG0vuuii+MM//MOhVrM9AQIECBAgQIAAAQIECBAgQIAAAQIE+hVoeADa75H6KVi0aFFccMEF8ed//uf9bGE1AQIECBAgQIAAAQIECBAgQIAAAQIE6hNoeAC6YsWK6OzsHLA16YVH06ZNi4kTJw64rQ0IECBAgAABAgQIECBAgAABAgQIECBQj0DDA9A5c+bU0w51CBAgQIAAAQIECBAgQIAAAQIECBAg0HCBhgeg/bXwqaeeigcffDDGjRsXKSSdPn16pBcfmQgQIECAAAECBAgQIECAAAECBAgQIDBcAqOGa8dpvxs2bIhXvvKV8axnPSsOOeSQWLhwYSxYsCBmzpwZs2fPjmXLlsX3vve94WyCfRMgQIAAAQIECBAgQIAAAQIECBAg0MICwxKAdnV1xbvf/e5ILzi65ZZb4uGHHz6AeMuWLfGpT30qlixZEv/4j/94QLkVBAgQIECAAAECBAgQIECAAAECBAgQOFiBYXkE/v3vf3811EyPuZ9++unx/Oc/P4488sh4+umn4xe/+EV8//vfj/vuuy8qYencuXPj/PPPP9j+qE+AAAECBAgQIECAAAECBAgQIECAAIGqQMMD0PXr10cKQNN08sknx8c+9rHsTtDqEbvN3HrrrfHXf/3X8fOf/zze9ra3xdlnn529Gb7bJmYJECBAgAABAgQIECBAgAABAgQIECBQt0DDH4G/9tprY8+ePXHUUUfF7bff3m/4mVr8ile8IlIIOnHixEgvSbr++uvr7oiKBAgQIECAAAECBAgQIECAAAECBAgQ6C3Q8AA0PdaepuXLlw/qbs5jjz023vzmN2d17rzzzuy3/xAgQIAAAQIECBAgQIAAAQIECBAgQKARAg0NQPfu3RsPPPBA1q6TTjpp0O2rbJu+G9REgAABAgQIECBAgAABAgQIECBAgACBRgk0NAAdNWpUtLf/5mtFd+7cOeg2phcjpWnq1KmDrmNDAgQIECBAgAABAgQIECBAgAABAgQIDCTQ0AA0vfH9mGOOyY75rW99a6BjV8vvvvvubP64446rrjNDgAABAgQIECBAgAABAgQIECBAgACBgxVoaACaGrN48eKsTZdeemls2rRpwPZ99atfrb78aNGiRQNubwMCBAgQIECAAAECBAgQIECAAAECBAgMVqDhAeh73vOemDx5cjz55JNx2mmnxac//elI3w3ae9qxY0dcdtll8epXvzr2798f6e7Pc889t/dmlgkQIECAAAECBAgQIECAAAECBAgQIFC3wG++sLPu6gdWPOyww+IDH/hAXHjhhfHwww9nb3h/17veFc95znNi3rx5sXv37njooYfiwQcfjMp3f44ZMyY++9nPxtixYw/coTUECBAgQIAAAQIECBAgQIAAAQIECBCoU6Dt13df7q+zbs1qX//61+NNb3pTFoLW2nDhwoXxsY99LP7gD/6g1mYtVZbujq28TKqMHT/nnHPK2K0R79N//dd/jXgbNGDkBMaNGxf79u2LPXv2jFwjHJnAIATSuZpempimzs7OQdSwCYGRE0jnajpnnasjNwaOPDiByrmatu7q6nI9MDg2W42ggGvXEcR36CEJuHYdEtewbzxhwoS6j9HwO0ArLfmjP/qj+OEPfxif+MQnst8/+tGP4sc//nGkuz3nz5+f/Zx55pnR0dERo0ePrlTz+9cC6WVSlb8cAiEwWAHnzGClyrudz47yjm1Ze+Zzq6wjW55+Vc7Ryu/y9ExPyiaQrgG6T87Z7hrmm1XAtWuzjox29Sfgs7U/mWKsH7YANHV/6tSpcfHFF1cl0s2mvf9wrhaaqQqkf7VNd4GaCAxF4IknnhjK5rYtmcCsWbOyuz3S9y+bCDSzwMyZM6tfebN169bse8Cbub3a1toC48ePj+nTp8e2bduyu+xbW0Pvm1kg3aE0Y8aMrIm7du2K7du3N3NztY1ApGvX9PV4zlUnQ7MLuHZtrhFKX7tZ79TwlyD1bsgzzzxTXdU9/Pzud79b/Q7Q6gZmCBAgQIAAAQIECBAgQIAAAQIECBAg0ECBYQtA77777njFK14RL3zhC/ts7nnnnZf9q8/rX//6cOdan0RWEiBAgAABAgQIECBAgAABAgQIECBwkALDEoB++tOfjqVLl8Ztt90WP/3pT7Nb27u3M72o4xe/+EX2hfJf+MIX4oQTTogNGzZ038Q8AQIECBAgQIAAAQIECBAgQIAAAQIEDlqg4QHoxo0b4y//8i+rbx588YtffEAAmlqd3lj9lre8JXvZz0MPPRRvfOMbfbfSQQ+nHRAgQIAAAQIECBAgQIAAAQIECBAg0F2g4QHoFVdcEeklPoceemh84xvfiNtvvz0mT57c/ZhZ6Pmyl70sPvnJT8bq1aujvb09vve978X111/fYzsLBAgQIECAAAECBAgQIECAAAECBAgQOBiBhgeg99xzT9aejo6OOPPMMwds2xlnnBF/8Rd/kW33zW9+c8DtbUCAAAECBAgQIECAAAECBAgQIECAAIHBCjQ0AN27d2+kx9nTdO6552a/B/OfU045JdvsRz/60WA2tw0BAgQIECBAgAABAgQIECBAgAABAgQGJdDQALStrS17vD0dOT0GP9jpmWeeyTYdP378YKvYjgABAgQIECBAgAABAgQIECBAgAABAgMKNDQAHTVqVDz72c/ODnrXXXcNePDKBt/+9rez2eOPP76yym8CBAgQIECAAAECBAgQIECAAAECBAgctEBDA9DUmj/5kz/JGrV8+fL46U9/OmAD00uQPvOZz2TbnXDCCQNubwMCBAgQIECAAAECBAgQIECAAAECBAgMVqDhAehb3/rWSI+y79ixI5YsWRLprfC//OUve7Rn//792XeFvv3tb4+zzz479u3bFyeeeOKQvje0xw4tECBAgAABAgQIECBAgAABAgQIECBAoA+Bhgegz33uc+Of//mfs0Nt3bo13ve+98Whhx4akydPjgULFsTRRx8dEyZMiKOOOio++tGPRmdnZ7b8+c9/Ptrb2/toolUECBAgQIAAAQIECBAgQIAAAQIECBCoT6DhAWhqRkdHR3zpS1+KI444otqqnTt3xo9//OPYtGlT7Nq1q7r+5S9/eXz/+9+PY445prrODAECBAgQIECAAAECBAgQIECAAAECBBohMGy3XKbvAn3xi18c6Ts+b7/99iz4fOyxx2LixImR7hJNP6ecckqcccYZjeiHfRAgQIAAAQIECBAgQIAAAQIECBAgQOAAgWELQNOR0neBpjs804+JAAECBAgQIECAAAECBAgQIECAAAECeQsMyyPweXfC8QgQIECAAAECBAgQIECAAAECBAgQINCXgAC0LxXrCBAgQIAAAQIECBAgQIAAAQIECBAohYAAtBTDqBMECBAgQIAAAQIECBAgQIAAAQIECPQlIADtS8U6AgQIECBAgAABAgQIECBAgAABAgRKISAALcUw6gQBAgQIECBAgAABAgQIECBAgAABAn0JCED7UrGOAAECBAgQIECAAAECBAgQIECAAIFSCAhASzGMOkGAAAECBAgQIECAAAECBAgQIECAQF8CAtC+VKwjQIAAAQIECBAgQIAAAQIECBAgQKAUAgLQUgyjThAgQIAAAQIECBAgQIAAAQIECBAg0JeAALQvFesIECBAgAABAgQIECBAgAABAgQIECiFgAC0FMOoEwQIECBAgAABAgQIECBAgAABAgQI9CUgAO1LxToCBAgQIECAAAECBAgQIECAAAECBEohIAAtxTDqBAECBAgQIECAAAECBAgQIECAAAECfQkIQPtSsY4AAQIECBAgQIAAAQIECBAgQIAAgVIICEBLMYw6QYAAAQIECBAgQIAAAQIECBAgQIBAXwIC0L5UrCNAgAABAgQIECBAgAABAgQIECBAoBQCAtBSDKNOECBAgAABAgQIECBAgAABAgQIECDQl4AAtC8V6wgQIECAAAECBAgQIECAAAECBAgQKIWAALQUw6gTBAgQIECAAAECBAgQIECAAAECBAj0JdDe10rrCBAgQIAAAQIEfiPQ0dGBosECK1asaPAe7Y4AAQIECBAgQIBA/wLuAO3fRgkBAgQIECBAgAABAgQIECBAgAABAgUXEIAWfAA1nwABAgQIECBAgAABAgQIECBAgACB/gUEoP3bKCFAgAABAgQIECBAgAABAgQIECBAoOACAtCCD6DmEyBAgAABAgQIECBAgAABAgQIECDQv4AAtH8bJQQIECBAgAABAgQIECBAgAABAgQIFFxAAFrwAdR8AgQIECBAgAABAgQIECBAgAABAgT6FxCA9m+jhAABAgQIECBAgAABAgQIECBAgACBggsIQAs+gJpPgAABAgQIECBAgAABAgQIECBAgED/AgLQ/m2UECBAgAABAgQIECBAgAABAgQIECBQcAEBaMEHUPMJECBAgAABAgQIECBAgAABAgQIEOhfQADav40SAgQIECBAgAABAgQIECBAgAABAgQKLiAALfgAaj4BAgQIECBAgAABAgQIECBAgAABAv0LCED7t1FCgAABAgQIECBAgAABAgQIECBAgEDBBQSgBR9AzSdAgAABAgQIECBAgAABAgQIECBAoH8BAWj/NkoIECBAgAABAgQIECBAgAABAgQIECi4gAC04AOo+QQIECBAgAABAgQIECBAgAABAgQI9C8gAO3fRgkBAgQIECBAgAABAgQIECBAgAABAgUXEIAWfAA1nwABAgQIECBAgAABAgQIECBAgACB/gUEoP3bKCFAgAABAgQIECBAgAABAgQIECBAoOACAtCCD6DmEyBAgAABAgQIECBAgAABAgQIECDQv4AAtH8bJQQIECBAgAABAgQIECBAgAABAgQIFFygveDtr9n8p59+Ot71rnfF3Llz45JLLul32127dsXNN98c69ati61bt8b8+fNj4cKFcdZZZ8Xo0aP7rFdPnT53ZCUBAgQIECBAgAABAgQIECBAgAABAsMmUNoAdP/+/XHZZZfF/fffH+3t/Xdz27ZtccEFF8TmzZsz5BkzZsSqVauyn3vuuSeWL18eY8eO7TEA9dTpsQMLBAgQIEBgGAQ6OjqGYa92SYAAAQIECBAgQIAAgWILlPIR+M7OzviHf/iH+Pa3vz3g6Fx++eVZ+Ll48eK47bbb4pZbbokbbrghjj766Ljrrrvi2muvPWAf9dQ5YCdWECBAgAABAgQIECBAgAABAgQIECAw7AKlC0DTY+znn39+3H777TFqVO3uPfDAA3HvvffGhAkT4oorroipU6dm4EcccURcffXV2ePvK1eujB07dlQHop461cpmCBAgQIAAAQIECBAgQIAAAQIECBDIVaB2QphrUw7+YF//+tfjHe94Rzz66KOR7uh85zvfWXOna9asycpPO+20GD9+fI9t06PwJ510UuzevTtSCFqZ6qlTqes3AQIECBAgQIAAAQIECBAgQIAAAQL5CpQqAH3iiSfi8MMPj4svvjiuuuqqmD59ek3NDRs2ZOUpLO1rSgFomu67775qcT11qpXNECBAgAABAgQIECBAgAABAgQIECCQq0D/bwfKtRmNOdjSpUvjT//0T2u+9Kj7kR555JFscdq0ad1XV+cr6ysvSEoF9dSp7rDbzPvf//546qmnuq353exLXvKSOPHEE3+3whyBQQhUvsJhEJvapIQCo0ePjra2tupXeZSwi7pEgECJBIryZ1b6bE3TlClTIr1g00SgWQW6f/VXeoFrUf4fa1ZP7Rp+gfT56lwdfmdHOHiByrVA2lO6HjAVV6BUAeisWbOGNBI7d+7Mtq8Enb0rV07uynapvDI/lDq995uW0wuX0h2rfU3HHntsnHrqqX0VWUegX4GJEyf2W6agNQTSX37a20v1sd4aA6eXBFpQoGh/ZqXvizcRKIrAmDFjIv2YCDS7QLp2da42+yhpX3eBol2/dG+7+YhSPQI/lAHdt29fPPPMM1mVQw45pM+qkydPztbv2rUr+11PnT53bCUBAgQIECBAgAABAgQIECBAgAABArkItOytQulfm9K/5nd2dkYl4OwtXlmfbs1PUz11eu+zsnzdddfFnj17Kos9fqfvLn388cd7rLNAYCAB58xAQuUuT3eld3V19fvVGuXuvd4RIFA0gaL8mZWuAdMTQempnfQP4SYCzSqQ7qKrPPae/n5TeWqtWdurXQTStWv6+7Bz1bnQ7ALps7Vyp/KWLVt8Jc4ID9hQn/zu3tyWDUATQoJL3++5Y8eO7ibV+cr6SZMmVdfVU6daudvMcccd122p5+y2bduyYLbnWksEagv0F6jXrqW0LALpu+nSX86dB2UZUf0gUG6BonxWVb73K7VXAFruc7LovUs3alQm1wMVCb+bWcC1azOPjrZ1F+j+HeDpeqD7cvftzDe/wO/+pGz+tja8hZXkuBJ09j7A9u3bs1Xd3yZfT53e+7VMgAABAgQIECBAgAABAgQIECBAgEA+Ai19B+icOXMy5U2bNsWSJUsOEE/r07RgwYJqWT11qpXNECBAgAABAgQIREdHB4VhEFixYsUw7NUuCRBBXyByAAArqElEQVQgQIAAAQLFF2jpO0CXLl2ajeDq1asPGMn06Mgdd9yRrV+4cGG1vJ461cpmCBAgQIAAAQIECBAgQIAAAQIECBDIVaClA9B01+e8efNi48aNsXLlyh7w119/faQvuD3yyCNj8eLF1bJ66lQrmyFAgAABAgQIECBAgAABAgQIECBAIFeBln4Evq2tLZYtWxaXXHJJXHnllbF27dqYP39+3H///dl8etPXRRddFGm7ylRPnUpdvwkQIECAAAECBAgQIECAAAECBAgQyFegpe8ATdSnnnpqXHPNNTF37ty4884747rrrsvCz3Rn6Ic+9KE4/vjjDxiReuocsBMrCBAgQIAAAQIECBAgQIAAAQIECBAYdoFS3wGagsq77757QMRFixbFTTfdlD3yvnnz5kgvOkqB6KhR/efD9dQZsCE2IECAAAECBAgQIECAAAECBAgQIECgoQKlDkCHKjVz5sxIP0OZ6qkzlP3blgABAmUU8AboMo6qPhEgQIAAAQIECBAgQKA5Bfq/xbE526tVBAgQIECAAAECBAgQIECAAAECBAgQGLSAAHTQVDYkQIAAAQIECBAgQIAAAQIECBAgQKBoAgLQoo2Y9hIgQIAAAQIECBAgQIAAAQIECBAgMGgBAeigqWxIgAABAgQIECBAgAABAgQIECBAgEDRBASgRRsx7SVAgAABAgQIECBAgAABAgQIECBAYNACAtBBU9mQAAECBAgQIECAAAECBAgQIECAAIGiCQhAizZi2kuAAAECBAgQIECAAAECBAgQIECAwKAFBKCDprIhAQIECBAgQIAAAQIECBAgQIAAAQJFExCAFm3EtJcAAQIECBAgQIAAAQIECBAgQIAAgUELCEAHTWVDAgQIECBAgAABAgQIECBAgAABAgSKJiAALdqIaS8BAgQIECBAgAABAgQIECBAgAABAoMWEIAOmsqGBAgQIECAAAECBAgQIECAAAECBAgUTUAAWrQR014CBAgQIECAAAECBAgQIECAAAECBAYtIAAdNJUNCRAgQIAAAQIECBAgQIAAAQIECBAomoAAtGgjpr0ECBAgQIAAAQIECBAgQIAAAQIECAxaQAA6aCobEiBAgAABAgQIECBAgAABAgQIECBQNIH2ojVYewkQIECAAAECBAgQOFCgo6PjwJXWHLTAihUrDnofdkCAAAECBAiMrIA7QEfW39EJECBAgAABAgQIECBAgAABAgQIEBhGAQHoMOLaNQECBAgQIECAAAECBAgQIECAAAECIysgAB1Zf0cnQIAAAQIECBAgQIAAAQIECBAgQGAYBQSgw4hr1wQIECBAgAABAgQIECBAgAABAgQIjKyAAHRk/R2dAAECBAgQIECAAAECBAgQIECAAIFhFBCADiOuXRMgQIAAAQIECBAgQIAAAQIECBAgMLICAtCR9Xd0AgQIECBAgAABAgQIECBAgAABAgSGUUAAOoy4dk2AAAECBAgQIECAAAECBAgQIECAwMgKCEBH1t/RCRAgQIAAAQIECBAgQIAAAQIECBAYRgEB6DDi2jUBAgQIECBAgAABAgQIECBAgAABAiMrIAAdWX9HJ0CAAAECBAgQIECAAAECBAgQIEBgGAUEoMOIa9cECBAgQIAAAQIECBAgQIAAAQIECIysgAB0ZP0dnQABAgQIECBAgAABAgQIECBAgACBYRQQgA4jrl0TIECAAAECBAgQIECAAAECBAgQIDCyAgLQkfV3dAIECBAgQIAAAQIECBAgQIAAAQIEhlFAADqMuHZNgAABAgQIECBAgAABAgQIECBAgMDICghAR9bf0QkQIECAAAECBAgQIECAAAECBAgQGEYBAegw4to1AQIECBAgQIAAAQIECBAgQIAAAQIjK9A+sod3dAIECDS3QEdHR3M3UOsIECBAgAABAgQIECBAgACBmgLuAK3Jo5AAAQIECBAgQIAAAQIECBAgQIAAgSILCECLPHraToAAAQIECBAgQIAAAQIECBAgQIBATQEBaE0ehQQIECBAgAABAgQIECBAgAABAgQIFFlAAFrk0dN2AgQIECBAgAABAgQIECBAgAABAgRqCghAa/IoJECAAAECBAgQIECAAAECBAgQIECgyAIC0CKPnrYTIECAAAECBAgQIECAAAECBAgQIFBTQABak0chAQIECBAgQIAAAQIECBAgQIAAAQJFFhCAFnn0tJ0AAQIECBAgQIAAAQIECBAgQIAAgZoCAtCaPAoJECBAgAABAgQIECBAgAABAgQIECiygAC0yKOn7QQIECBAgAABAgQIECBAgAABAgQI1BQQgNbkUUiAAAECBAgQIECAAAECBAgQIECAQJEFBKBFHj1tJ0CAAAECBAgQIECAAAECBAgQIECgpoAAtCaPQgIECBAgQIAAAQIECBAgQIAAAQIEiiwgAC3y6Gk7AQIECBAgQIAAAQIECBAgQIAAAQI1BQSgNXkUEiBAgAABAgQIECBAgAABAgQIECBQZAEBaJFHT9sJECBAgAABAgQIECBAgAABAgQIEKgpIACtyaOQAAECBAgQIECAAAECBAgQIECAAIEiC7QXufFlbvvo0aPL3D19GwYB58wwoNolAQIECBAg0PICRbjGGjXqd/e1tLW1RRHa3PInVosDpPM0nbfO1RY/EQrQ/XSuVqZ0vu7fv7+y6HfBBASgTThgY8aMiWnTpjVhyzSpmQXmzJnTzM3TNgIECBAgQIBAIQWKdo01ceLESD8mAs0u0N7eHhMmTGj2ZmofgarA7Nmzq/NmiicgAG3CMevq6ootW7Y0Ycs0qZkFnDPNPDraRoAAAQIECBRVoAjXWOkGiilTpmTEnZ2d8fTTTxeVW7tbRGDq1KmR/t67c+fOFumxbhZVIJ2rKaxP0xNPPOEO0BEeyJkzZ9bdAgFo3XTDVzHdUr179+7hO4A9l1LAOVPKYdUpAgQIECBAYIQFinCN1f0RzX379vm7xAifMw4/sED6O+/evXudqwNT2WKEBdJnamVKfx54BL6iUbzfv/uymOK1XYsJECBAgAABAgQIECBAgAABAgQIECBQU0AAWpNHIQECBAgQIECAAAECBAgQIECAAAECRRYQgBZ59LSdAAECBAgQIECAAAECBAgQIECAAIGaAgLQmjwKCRAgQIAAAQIECBAgQIAAAQIECBAosoAAtMijp+0ECBAgQIAAAQIECBAgQIAAAQIECNQUEIDW5FFIgAABAgQIECBAgAABAgQIECBAgECRBQSgRR49bSdAgAABAgQIECBAgAABAgQIECBAoKZAe81ShQQIECBAgAABAgQIEGhhgY6Ojhbu/fB1fcWKFcO3c3smQIAAAQK9BNwB2gvEIgECBAgQIECAAAECBAgQIECAAAEC5REQgJZnLPWEAAECBAgQIECAAAECBAgQIECAAIFeAgLQXiAWCRAgQIAAAQIECBAgQIAAAQIECBAoj4AAtDxjqScECBAgQIAAAQIECBAgQIAAAQIECPQSEID2ArFIgAABAgQIECBAgAABAgQIECBAgEB5BASg5RlLPSFAgAABAgQIECBAgAABAgQIECBAoJeAALQXiEUCBAgQIECAAAECBAgQIECAAAECBMojIAAtz1jqCQECBAgQIECAAAECBAgQIECAAAECvQQEoL1ALBIgQIAAAQIECBAgQIAAAQIECBAgUB4BAWh5xlJPCBAgQIAAAQIECBAgQIAAAQIECBDoJSAA7QVikQABAgQIECBAgAABAgQIECBAgACB8ggIQMszlnpCgAABAgQIECBAgAABAgQIECBAgEAvAQFoLxCLBAgQIECAAAECBAgQIECAAAECBAiUR0AAWp6x1BMCBAgQIECAAAECBAgQIECAAAECBHoJCEB7gVgkQIAAAQIECBAgQIAAAQIECBAgQKA8AgLQ8oylnhAgQIAAAQIECBAgQIAAAQIECBAg0EtAANoLxCIBAgQIECBAgAABAgQIECBAgAABAuUREICWZyz1hAABAgQIECBAgAABAgQIECBAgACBXgIC0F4gFgkQIECAAAECBAgQIECAAAECBAgQKI+AALQ8Y6knBAgQIECAAAECBAgQIECAAAECBAj0EhCA9gKxSIAAAQIECBAgQIAAAQIECBAgQIBAeQQEoOUZSz0hQIAAAQIECBAgQIAAAQIECBAgQKCXgAC0F4hFAgQIECBAgAABAgQIECBAgAABAgTKIyAALc9Y6gkBAgQIECBAgAABAgQIECBAgAABAr0E2nstWyRAgAABAgQIECBAgAABAsMq0NHRMaz7b9Wdr1ixolW7rt8ECBCoKeAO0Jo8CgkQIECAAAECBAgQIECAAAECBAgQKLKAALTIo6ftBAgQIECAAAECBAgQIECAAAECBAjUFBCA1uRRSIAAAQIECBAgQIAAAQIECBAgQIBAkQUEoEUePW0nQIAAAQIECBAgQIAAAQIECBAgQKCmgAC0Jo9CAgQIECBAgAABAgQIECBAgAABAgSKLOAt8EUePW0n0E3AmzS7YZglQIAAAQIECBAgQIAAAQIECPxWwB2gTgUCBAgQIECAAAECBAgQIECAAAECBEorIAAt7dDqGAECBAgQIECAAAECBAgQIECAAAECAlDnAAECBAgQIECAAAECBAgQIECAAAECpRUQgJZ2aHWMAAECBAgQIECAAAECBAgQIECAAAEBqHOAAAECBAgQIECAAAECBAgQIECAAIHSCghASzu0OkaAAAECBAgQIECAAAECBAgQIECAgADUOUCAAAECBAgQIECAAAECBAgQIECAQGkFBKClHVodI0CAAAECBAgQIECAAAECBAgQIEBAAOocIECAAAECBAgQIECAAAECBAgQIECgtALtpe2ZjhEgQIAAAQIECBAgQIAAgRYS6OjoaKHe5tfVFStW5HcwRyJAYFgE3AE6LKx2SoAAAQIECBAgQIAAAQIECBAgQIBAMwgIQJthFLSBAAECBAgQIECAAAECBAgQIECAAIFhERCADgurnRIgQIAAAQIECBAgQIAAAQIECBAg0AwCAtBmGAVtIECAAAECBAgQIECAAAECBAgQIEBgWAS8BGlYWO2UAAECBAgQIECAAAECBAgQKIOAl0sNzyh6udTwuNpr3wLuAO3bxVoCBAgQIECAAAECBAgQIECAAAECBEog4A7QOgdx165dcfPNN8e6deti69atMX/+/Fi4cGGcddZZMXr06Dr3qhoBAgQIECBAgAABAgQIECBAgAABAo0UEIDWoblt27a44IILYvPmzVntGTNmxKpVq7Kfe+65J5YvXx5jx46tY8+qECBAgAABAgQIECBAgAABAgQIECDQSAGPwNehefnll2fh5+LFi+O2226LW265JW644YY4+uij46677oprr722jr2qQoAAAQIECBAgQIAAAQIECBAgQIBAowUEoEMUfeCBB+Lee++NCRMmxBVXXBFTp07N9nDEEUfE1VdfnT3+vnLlytixY8cQ92xzAgQIECBAgAABAgQIECBAgAABAgQaLeAR+CGKrlmzJqtx2mmnxfjx43vUTo/Cn3TSSbF27dpIIehrXvOaHuUWCBAgQIAAAQIECBAgQIAAAQIEIjo6OjAMg8CKFSuGYa/F36U7QIc4hhs2bMhqpMff+5pSAJqm++67r69i6wgQIECAAAECBAgQIECAAAECBAgQyFHAHaBDxH7kkUeyGtOmTeuzZmV95QVJfW7065VbtmyJvXv39lm8b9++GDVKNt0njpUECBAgQIAAAQIECBAgQIAAAQJ9CsiT+mQJAWjfLv2u3blzZ1ZWCTp7bzhlypRsVWW73uWV5Ze//OXxxBNPVBZ7/H7f+94X5513Xo91FggQIECAAAECBAgQIECAAAECBAjUEjj00ENrFbdsmQB0CEOf7sx85plnshqHHHJInzUnT56crd+1a1ef5VZGrFq1CgMBAgQIECBAgAABAgQIECBAgACBXAQEoENgTrcRp7e/d3Z2Rn8BZ2X92LFja+75hS98YWzfvr3PbWbNmtXv/vusYGXDBdra2qIyhl1dXf1+XUHDD2yHBOoUGDNmTOzfvz/S+Woi0MwC6VytPJZT+TOzmdurba0tkM7VdM7u3r07+4xtbQ29b2YB167NPDra1peAa9e+VKxrRgHXrs01KuPGjau7QQLQIdKlcDJ9v+eOHTv6rFlZP2nSpD7LKys//vGPV2YP+L1t27Z+H48/YGMrhkUghZ8zZ87M9p3+gt5fWD0sB7dTAnUIpM+mPXv2xJNPPllHbVUI5CeQPlsr/8C0detWoVJ+9I5Uh8D48eNj+vTpkc7V9CSQiUCzCqS/EM6YMSNrnmvXZh0l7eoukK5d0z8u+XtWdxXzzSjg2rW5RuWwww6ru0HetDNEuvRBnaZK0Nm7euUDPF0smwgQIECAAAECBAgQIECAAAECBAgQGFkBAegQ/efMmZPV2LRpU581K+sXLFjQZ7mVBAgQIECAAAECBAgQIECAAAECBAjkJyAAHaL10qVLsxqrV68+oGZ6NOqOO+7I1i9cuPCAcisIECBAgAABAgQIECBAgAABAgQIEMhXQAA6RO8lS5bEvHnzYuPGjbFy5coeta+//vrYsmVLHHnkkbF48eIeZRYIECBAgAABAgQIECBAgAABAgQIEMhfwEuQhmie3rC4bNmyuOSSS+LKK6+MtWvXxvz58+P+++/P5tMbwi666KJI25kIECBAgAABAgQIECBAgAABAgQIEBhZAXeA1uF/6qmnxjXXXBNz586NO++8M6677ros/Ex3hn7oQx+K448/vo69qkKAAAECBAgQIECAAAECBAgQIECAQKMF3AFap+iiRYvipptuyh5537x5c6SXI6VAdNQomXKdpKoRIECAAAECBAgQIECAAAECBAgQaLiAAPQgSWfOnBnpx0SAAAECBAgQIECAAAECBAgQIECAQPMJuF2x+cZEiwgQIECAAAECBAgQIECAAAECBAgQaJCAALRBkHZDgAABAgQIECBAgAABAgQIECBAgEDzCQhAm29MtIgAAQIECBAgQIAAAQIECBAgQIAAgQYJCEAbBGk3BAgQIECAAAECBAgQIECAAAECBAg0n4AAtPnGRIsIECBAgAABAgQIECBAgAABAgQIEGiQgAC0QZB2Q4AAAQIECBAgQIAAAQIECBAgQIBA8wkIQJtvTLSIAAECBAgQIECAAAECBAgQIECAAIEGCQhAGwRpNwQIECBAgAABAgQIECBAgAABAgQINJ+AALT5xkSLCBAgQIAAAQIECBAgQIAAAQIECBBokIAAtEGQdkOAAAECBAgQIECAAAECBAgQIECAQPMJCECbb0y0iAABAgQIECBAgAABAgQIECBAgACBBgm07f/11KB92Q2B0gjcc8898Za3vCXrz3nnnRcXX3xxafqmIwQIEBhJgde97nVx3333ZU1Yu3ZtHHLIISPZHMcmQIBAKQS+9a1vxVvf+tasL294wxvi3e9+dyn6pRMECBAYaYFzzz03fvjDH2bN+M53vhOTJ08e6SY5fp0C7XXWU41AqQX27dsXe/bsyfrY1dVV6r7qHAECBPIUSJ+plc9X/wabp7xjESBQZoHu16579+4tc1f1jQABArkKdL92zfXADtZwAY/AN5zUDgkQIECAAAECBAgQIECAAAECBAgQaBYBAWizjIR2ECBAgAABAgQIECBAgAABAgQIECDQcAEBaMNJ7ZAAAQIECBAgQIAAAQIECBAgQIAAgWYREIA2y0hoBwECBAgQIECAAAECBAgQIECAAAECDRcQgDac1A4JECBAgAABAgQIECBAgAABAgQIEGgWgbZfv4F1f7M0RjsINIvA448/HuvWrcuaM2/evDjmmGOapWnaQYAAgUILfOc734lt27ZlfVi6dGmMGTOm0P3ReAIECDSDgGvXZhgFbSBAoIwCa9eujSeffDLr2ote9KJob28vYzdbok8C0JYYZp0kQIAAAQIECBAgQIAAAQIECBAg0JoCHoFvzXHXawIECBAgQIAAAQIECBAgQIAAAQItISAAbYlh1kkCBAgQIECAAAECBAgQIECAAAECrSkgAG3NcddrAgQIECBAgAABAgQIECBAgAABAi0hIABtiWHWSQIECBAgQIAAAQIECBAgQIAAAQKtKeD1Va057npdQ+DHP/5x3HTTTfGLX/wiJk2aFMcdd1yceeaZ8ZznPKdGLUUECBAgMBSB9evXx8c//vFYvHhxLFu2bChVbUuAAAEC3QTWrVsXq1atioceeihGjx4d8+bNi1e+8pWxYMGCbluZJUCAAIGBBG6//fb43Oc+F5deemnNz9A777wz7r777nj44f9v706AtZz6AID/S6VNdhFFM5ZibFkbZJB9HWRkX7LMGGRfsm+fnRjL0MhWhoksMSa7YdBkhCFGlklChIoSLZ9zvnnvd6t737hu79L7e2au+9znnOcsvzPzevs/5zxnUsybNy+6desWvXv3jl133XVxVUgvo4Bd4MuIr+rKExgxYkQMHjw4N6xjx47xxx9/5J927drFtddeG7169aq8RmsRAQIEqkxgxowZccwxx8SUKVOib9++cemll1ZZDzSXAAEClSFw6623xuOPP54bs+yyy8b8+fPzd9cWLVrE8ccfH0cffXRlNFQrCBAgUOECH374YZx22mkxZ86cuP3222OzzTZbpMWzZ8+Oc845J9KD/HR06tQp/54+fXr+ne65/vrrI8UPHJUnYAl85Y2JFpVJIH3g3XbbbdGmTZu4+uqr47nnnstP09OH4KxZs+Lss8+O7777rkytUy0BAgSWHoGbbropBz+Xnh7pCQECBEovkGYgpeBn+u6a/kH+1FNPxZNPPhmnnnpqbsyQIUMizQ51ECBAgEBxgRTQHDRoUA5+FsuZVi+lvGmmffqMTTNG08+9994bXbt2jXHjxuXgabEypJVPQAC0fPZqrjCBBx54ID81P+KII6JPnz6Rnpy3bt06+vXrFwcffHD8+eef+UtlhTVbcwgQIFBVAqNHj46XXnopVlhhhapqt8YSIECg0gReeOGF3KQ0k36//fbLr25abrnl4pBDDoltt902p6Wl8Q4CBAgQ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mAABAgQIECBAgEAxgZkzZ8bEiRPze+lS0LNdu3bFsksjQIAAAQI1JyAAWnNDrsMECBAgQIAAAQIECBAgQIAAAQIEakfAJki1M9Z6SoAAAQIECBAgQIAAAQIECBAgQKDmBARAa27IdZgAAQIECBAgQIAAAQIECBAgQIBA7QgIgNbOWOspAQIECBAgQIAAAQIECBAgQIAAgZoTEACtuSHXYQIECBAgQIAAAQIECBAgQIAAAQK1IyAAWjtjracECBAgQIAAAQIECBAgQIAAAQIEak5AALTmhlyHCRAgQIAAAQIECBAgQIAAAQIECNSOgABo7Yy1nhIgQIAAAQIECBAgQIAAAQIECBCoOQEB0Jobch0mQIAAAQIECBAgQIAAAQIECBAgUDsCAqC1M9Z6SoAAAQIECBAgQIAAAQIECBAgQKDmBARAa27IdZgAAQIECBAgQIAAAQIECBAgQIBA7QgIgNbOWOspAQIECBAgQIAAAQIECBAgQIAAgZoTEACtuSHXYQIECBAgQIAAgWICM2bMiBYtWuSfCy+8sFhWaQQIECBAgAABAlUgIABaBYOkiQQIECBAgAABAgQIECBAgAABAgQINE2gVdNucxcBAgQIECBAgACBpVMgzf5s27Zt7lyrVr4uL52jrFcECBAgQIBALQm0mP/XUUsd1lcCBAgQIECAAAECBAgQIECAAAECBGpHwBL42hlrPSVAgAABAgQIECBAgAABAgQIECBQcwLW9NTckOswAQIECBAgQGDpF5g6dWp8/vnn/6ijvXr1irTkfd68eTF27Nh8b5cuXWKttdaqK2fixInx3XffRceOHWPDDTeMtJhq/Pjx8eabb8akSZOie/fuseuuu8aaa65Zd48TAgQIECBAgACB8gpYAl9ef7UTIECAAAECBAgsAYHhw4fH4Ycf/o9K/vHHH2PllVeOtAt8p06d8r0XXHBBXHPNNXXlDBw4MAYPHhzbbLNNPPfcc7H33nvH22+/XZeeTtq0aRMDBgyIW265JZ8vkOgPAgQIECBAgACBkguYAVpychUSIECAAAECBAgsaYEOHTpEt27dGqymdevWeZOj3377Lb766qucZ6WVVop27do1mL+hiz/99FP06dMnPvroo1h//fVjt912izlz5sTo0aPjiy++iDvvvDMmTJgQzz77bJ5V2lAZrhEgQIAAAQIECJRGQAC0NM5qIUCAAAECBAgQKKHA/vvvH+mnsePXX3+NHXbYISenGZsjR46M9u3bN5Z9keufffZZvnb88cfHXXfdFSmomo5Zs2bFscceG48++mgOhqa0U089Naf5DwECBAgQIECAQHkEbIJUHne1EiBAgAABAgQIlEkgzdTs169fjBs3Lrfg3nvvzbM5/2lz0jL4IUOG1AU/0/1pFulDDz0Ua6+9di6u/vL5f1q+/AQIECBAgAABAs0jIADaPI5KIUCAAAECBAgQqBKBU045JZ5//vnc2osuuiiOOuqoJrX8sssua/C+NBv0nHPOyWlpw6S0OZKDAAECBAgQIECgfAICoOWzVzMBAgQIECBAgECJBf7zn//EPffck2s99NBD44orrmhSC1q2bBm77LJLo/em2aGF47333iuc+k2AAAECBAgQIFAGAQHQMqCrkgABAgQIECBAoPQCjzzySAwaNChX3Lt37xg6dGi0aNGiSQ3p0qXLAkvfFy6k/gZMhaX2C+fxNwECBAgQIECAQGkEBEBL46wWAgQIECBAgACBMgq8/vrreXOi+fPnR/fu3eOpp57KO8E3tUmdO3cuemunTp3q0idOnFh37oQAAQIECBAgQKD0AgKgpTdXIwECBAgQIECAQAkFPvnkkzjggANi9uzZsfzyy8ezzz4bq6666r9qwffff1/0/m+++aYu/d/WVVeQEwIECBAgQIAAgSYJCIA2ic1NBAgQIECAAAEC1SAwZcqU2GuvveLnn3+OVq1axYgRI6Jnz57/uunffvttpN3kGzvqz/pcZ511GsvmOgECBAgQIECAQAkEBEBLgKwKAgQIECBAgACB0gvMnDkz9t133/jyyy9z5XfeeWf07du3WRoyd+7cup3kGyrwscceq7u855571p07IUCAAAECBAgQKL2AAGjpzdVIgAABAgQIECCwhAXmzZsXhx12WIwZMybXdMEFF8QJJ5zQrLVefvnlkQKhCx8p4Hrffffly3369ImuXbsunMXfBAgQIECAAAECJRRoVcK6VEWAAAECBAgQIECgJAJnnHFG3ugoVbbPPvvEcccdFx988EHMmjUr0kZIDR1pZ/f6u7c3lKf+tbFjx8Yee+wRDz74YKyxxho56bXXXov+/fvHH3/8kZfc33bbbfVvcU6AAAECBAgQIFAGAQHQMqCrkgABAgQIECBAYMkKPPzww3UVjBo1KtLP4o5zzz03rrvuusVlq0vfYost4sUXX4wUOF133XXze0anTp2a01u3bh1DhgyJTTfdtC6/EwIECBAgQIAAgfIIWAJfHne1EiBAgAABAgQIVLlAmu2ZZpa2bds2JkyYEIXg50477RSvvvpqHHXUUVXeQ80nQIAAAQIECCwdAi3+WgLU8BqgpaN/ekGAAAECBAgQIECg2QQGDhwYgwcPzuWl93+2bNkyL3d/991349dff40ePXp452ezaSuIAAECBAgQINA8ApbAN4+jUggQIECAAAECBGpUoE2bNtG7d+8a7b1uEyBAgAABAgQqX8AS+MofIy0kQIAAAQIECBAgQIAAAQIECBAgQKCJAgKgTYRzGwECBAgQIECAAAECBAgQIECAAAEClS8gAFr5Y6SFBAgQIECAAAECBAgQIECAAAECBAg0UcA7QJsI5zYCBAgQIECAAIHaE1h99dVjo402qr2O6zEBAgQIECBAoIoF7AJfxYOn6QQIECBAgAABAgQIECBAgAABAgQIFBewBL64j1QCBAgQIECAAAECBAgQIECAAAECBKpYQAC0igdP0wkQIECAAAECBAgQIECAAAECBAgQKC4gAFrcRyoBAgQIECBAgAABAgQIECBAgAABAlUsIABaxYOn6QQIECBAgAABAgQIECBAgAABAgQIFBcQAC3uI5UAAQIECBAgQIAAAQIECBAgQIAAgSoWEACt4sHTdAIECBAgQIAAAQIECBAgQIAAAQIEigsIgBb3kUqAAAECBAgQIECAAAECBAgQIECAQBULCIBW8eBpOgECBAgQIECAAAECBAgQIECAAAECxQUEQIv7SCVAgAABAgQIECBAgAABAgQIECBAoIoFBECrePA0nQABAgQIECBAgAABAgQIECBAgACB4gICoMV9pBIgQIAAAQIECBAgQIAAAQIECBAgUMUCAqBVPHiaToAAAQIECBAgQIAAAQIECBAgQIBAcQEB0OI+UgkQIECAAAECBAgQIECAAAECBAgQqGKB/wJVRZqmj6ZIwAAAAABJRU5ErkJggg==" width="672" /></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co"># Poisson(5)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(<span class="kw">rpois</span>(n, lambda)), <span class="dt">binwidth =</span> <span class="dv">1</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAJACAYAAABMocy1AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N0NkF1lfT/w377mFTaQQAKMvEkaGSyTGIegVhDiSxSlFl9K6wtGSnFitWIZikMhDlActQWhtlqlpk6F6sBUrWDiGCECJlMKotCgNRDAiIqQFxPyusnun+f0f9Zks6/3nnv37L2fM7Pee885z3N+z+e5Xna/Oeeelt4XlrAQIECAAAECBAgQIECAAAECBAgQIECgAQVaG3BMhkSAAAECBAgQIECAAAECBAgQIECAAIFMQADqjUCAAAECBAgQIECAAAECBAgQIECAQMMKCEAbdmoNjAABAgQIECBAgAABAgQIECBAgAABAaj3AAECBAgQIECAAAECBAgQIECAAAECDSsgAG3YqTUwAgQIECBAgAABAgQIECBAgAABAgQEoN4DBAgQIECAAAECBAgQIECAAAECBAg0rIAAtGGn1sAIECBAgAABAgQIECBAgAABAgQIEBCAeg8QIECAAAECBAgQIECAAAECBAgQINCwAgLQhp1aAyNAgAABAgQIECBAgAABAgQIECBAQADqPUCAAAECBAgQIECAAAECBAgQIECAQMMKCEAbdmoNjAABAgQIECBAgAABAgQIECBAgAABAaj3AAECBAgQIECAAAECBAgQIECAAAECDSsgAG3YqTUwAgQIECBAgAABAgQIECBAgAABAgQEoN4DBAgQIECAAAECBAgQIECAAAECBAg0rEB7w45sHA9sy5YtsXPnznE8gvFV+lFHHZUVvHfv3nj22WfHV/GqJTBCgY6OjpgxY0b2Hk/vdQuBRhQ48sgjo62tLXp7e+PXv/51Iw7RmAhEa2trzJw5MzZt2hS7d+8mQqAhBaZPnx6dnZ3Z2J555pno6elpyHEaFIFZs2bF1q1bY8eOHTAINKRAV1dXTJ48ORvbc889F93d3VWNM89vKunEGaCVqGlDgAABAgQIECBAgAABAgQIECBAgMC4EBCAjotpUiQBAgQIECBAgAABAgQIECBAgAABApUICEArUdOGAAECBAgQIECAAAECBAgQIECAAIFxISAAHRfTpEgCBAgQIECAAAECBAgQIECAAAECBCoREIBWoqYNAQIECBAgQIAAAQIECBAgQIAAAQLjQkAAOi6mSZEECBAgQIAAAQIECBAgQIAAAQIECFQiIACtRE0bAgQIECBAgAABAgQIECBAgAABAgTGhYAAdFxMkyIJECBAgAABAgQIECBAgAABAgQIEKhEQABaiZo2BAgQIECAAAECBAgQIECAAAECBAiMCwEB6LiYJkUSIECAAAECBAgQIECAAAECBAgQIFCJgAC0EjVtCBAgQIAAAQIECBAgQIAAAQIECBAYFwIC0HExTYokQIAAAQIECBAgQIAAAQIECBAgQKASAQFoJWraECBAgAABAgQIECBAgAABAgQIECAwLgQEoONimhRJgAABAgQIECBAgAABAgQIECBAgEAlAgLQStS0IUCAAAECBAgQIECAAAECBAgQIEBgXAgIQMfFNCmSAAECBAgQIECAAAECBAgQIECAAIFKBASglahpQ4AAAQIECBAgQIAAAQIECBAgQIDAuBAQgI6LaVIkAQIECBAgQIAAAQIECBAgQIAAAQKVCAhAK1HThgABAgQIECBAgAABAgQIECBAgACBcSEgAB0X06RIAgQIECBAgAABAgQIECBAgAABAgQqEWivpJE2BAgQIECgkQUWL17cyMMrbGzLli0rrC8dESBAgAABAgQIECBAoFYCzgCtlax+CRAgQIAAAQIECBAgQIAAAQIECBAYcwEB6JhPgQIIECBAgAABAgQIECBAgAABAgQIEKiVgAC0VrL6JUCAAAECBAgQIECAAAECBAgQIEBgzAUEoGM+BQogQIAAAQIECBAgQIAAAQIECBAgQKBWAgLQWsnqlwABAgQIECBAgAABAgQIECBAgACBMRcQgI75FCiAAAECBAgQIECAAAECBAgQIECAAIFaCQhAayWrXwIECBAgQIAAAQIECBAgQIAAAQIExlxAADrmU6AAAgQIECBAgAABAgQIECBAgAABAgRqJSAArZWsfgkQIECAAAECBAgQIECAAAECBAgQGHMBAeiYT4ECCBAgQIAAAQIECBAgQIAAAQIECBColYAAtFay+iVAgAABAgQIECBAgAABAgQIECBAYMwFBKBjPgUKIECAAAECBAgQIECAAAECBAgQIECgVgIC0FrJ6pcAAQIECBAgQIAAAQIECBAgQIAAgTEXEICO+RQogAABAgQIECBAgAABAgQIECBAgACBWgkIQGslq18CBAgQIECAAAECBAgQIECAAAECBMZcQAA65lOgAAIECBAgQIAAAQIECBAgQIAAAQIEaiUgAK2VrH4JECBAgAABAgQIECBAgAABAgQIEBhzgfYxr0ABBwm0trbG5MmTD1pvRW0FWlpauNeWWO9jKNDW1pYdfeLEidHT0zOGlTh0IwmU7b9V6XM8X8pWW16XRwLVCuTv8wkTJkT+2V5tn9oTKJtA+nsoXyZNmhS9vb35S48EGk6gs7Oz4cZkQARygfb238WO6W/Rjo6OfFPdH1te+I+J/5rUnX3oA27fvj2mTJky9E62EiBAgEDNBBYtWlSzvnXcnAIrVqxozoEbNQECBAgQIECAAIESCPwuii1BMUr4P4Hu7u741a9+haNOAkcddVR2pL1798azzz5bp6M6DIH6CqR/aZsxY0b2Hk/vdQsBAvUV8N/1+no38tHSmXEzZ86MTZs2xe7duxt5qMbWxALTp0+P/Ky4Z555xtUrTfxeaPShz5o1K7Zu3Ro7duxo9KEaX5MKdHV19V1p+9xzz0XKu6pZ8vymkj5+d21BJa21IUCAAAECBAgQIECAAAECBAgQIECAQIkFBKAlnhylESBAgAABAgQIECBAgAABAgQIECBQnYAAtDo/rQkQIECAAAECBAgQIECAAAECBAgQKLGAALTEk6M0AgQIECBAgAABAgQIECBAgAABAgSqExCAVuenNQECBAgQIECAAAECBAgQIECAAAECJRYQgJZ4cpRGgAABAgQIECBAgAABAgQIECBAgEB1AgLQ6vy0JkCAAAECBAgQIECAAAECBAgQIECgxAIC0BJPjtIIECBAgAABAgQIECBAgAABAgQIEKhOQABanZ/WBAgQIECAAAECBAgQIECAAAECBAiUWEAAWuLJURoBAgQIECBAgAABAgQIECBAgAABAtUJCECr89OaAAECBAgQIECAAAECBAgQIECAAIESCwhASzw5SiNAgAABAgQIECBAgAABAgQIECBAoDoBAWh1floTIECAAAECBAgQIECAAAECBAgQIFBiAQFoiSdHaQQIECBAgAABAgQIECBAgAABAgQIVCcgAK3OT2sCBAgQIECAAAECBAgQIECAAAECBEosIAAt8eQojQABAgQIECBAgAABAgQIECBAgACB6gQEoNX5aU2AAAECBAgQIECAAAECBAgQIECAQIkFBKAlnhylESBAgAABAgQIECBAgAABAgQIECBQnYAAtDo/rQkQIECAAAECBAgQIECAAAECBAgQKLGAALTEk6M0AgQIECBAgAABAgQIECBAgAABAgSqExCAVuenNQECBAgQIECAAAECBAgQIECAAAECJRYQgJZ4cpRGgAABAgQIECBAgAABAgQIECBAgEB1AgLQ6vy0JkCAAAECBAgQIECAAAECBAgQIECgxAIC0BJPjtIIECBAgAABAgQIECBAgAABAgQIEKhOQABanZ/WBAgQIECAAAECBAgQIECAAAECBAiUWEAAWuLJURoBAgQIECBAgAABAgQIECBAgAABAtUJCECr89OaAAECBAgQIECAAAECBAgQIECAAIESCwhASzw5SiNAgAABAgQIECBAgAABAgQIECBAoDoBAWh1floTIECAAAECBAgQIECAAAECBAgQIFBiAQFoiSdHaQQIECBAgAABAgQIECBAgAABAgQIVCcgAK3OT2sCBAgQIECAAAECBAgQIECAAAECBEosIAAt8eQojQABAgQIECBAgAABAgQIECBAgACB6gQEoNX5aU2AAAECBAgQIECAAAECBAgQIECAQIkFBKAlnhylESBAgAABAgQIECBAgAABAgQIECBQnYAAtDo/rQkQIECAAAECBAgQIECAAAECBAgQKLGAALTEk6M0AgQIECBAgAABAgQIECBAgAABAgSqExCAVuenNQECBAgQIECAAAECBAgQIECAAAECJRYQgJZ4cpRGgAABAgQIECBAgAABAgQIECBAgEB1AgLQ6vy0JkCAAAECBAgQIECAAAECBAgQIECgxAIC0BJPjtIIECBAgAABAgQIECBAgAABAgQIEKhOQABanZ/WBAgQIECAAAECBAgQIECAAAECBAiUWEAAWuLJURoBAgQIECBAgAABAgQIECBAgAABAtUJCECr89OaAAECBAgQIECAAAECBAgQIECAAIESCwhASzw5SiNAgAABAgQIECBAgAABAgQIECBAoDoBAWh1floTIECAAAECBAgQIECAAAECBAgQIFBiAQFoiSdHaQQIECBAgAABAgQIECBAgAABAgQIVCcgAK3OT2sCBAgQIECAAAECBAgQIECAAAECBEosIAAt8eQojQABAgQIECBAgAABAgQIECBAgACB6gQEoNX5aU2AAAECBAgQIECAAAECBAgQIECAQIkF2ktcW9Wl7dixIy699NKYNWtWXHXVVQP2l/b54he/OOC2fOU555wTJ510Uv4ye9y9e3fcfvvt8cADD8TmzZtj9uzZMXfu3Fi0aFG0tbUdsK8XBAgQIECAAAECBAgQIECAAAECBAiMjUDDBqC9vb1x9dVXxyOPPBLt7YMP87HHHsuCzKH4U7C5fwC6ZcuWWLJkSWzYsCFrdvjhh8eKFSuyn9WrV8fSpUujs7NzqC5tI0CAAAECBAgQIECAAAECBAgQIECgDgKDJ4N1OHitDrFz58648cYb4wc/+MGwh1i3bl22z/z58+Pss88ecP90duf+yzXXXJOFnwsWLIgrr7wyurq64umnn44rrrgi7rnnnrjpppuyM0/3b+M5AQIECBAgQIAAAQIECBAgQIAAAQL1F2i4ADRdkv7JT34yfv3rX0dra2v09PQMqZoHoCn8PPfcc4fcN2189NFH4/77749JkybFtddeGxMnTszaHHPMMXH99dfHeeedF8uXL4+LL744DjnkkGH7swMBAgQIECBAgAABAgQIECBAgAABArUTaKibIH33u9+NSy65JAs/09mZH/3oR4eVS5fAp2XOnDnD7pt2WLVqVbbfmWee2Rd+Zite+J90Kfxpp50We/bsyULQfL1HAgQIECBAgAABAgQIECBAgAABAgTGRqChAtBNmzbF0UcfHZdffnl8+tOfjsMOO2xI1b1798b69euz7wg98cQTs323bt0a6QZHgy1r167NNqWAdaAlBaBpefjhhwfabB0BAgQIECBAgAABAgQIECBAgAABAnUUaKhL4BcuXBhve9vbhrzp0f62Tz31VHR3d8exxx4bt956a3z961+PjRs3ZpfOp3Xvec974vWvf/3+TbLv+kwrpk2bdsD6/EW+Pr9BUr7eIwECBAgQIECAAAECBAgQIECAAAEC9RdoqAB0xowZoxLMv//z5z//edx8882R2qebIT355JPZT7rZ0Q9/+MPsjNK84+3bt2dP86AzX58/HnroodnTfL98ff/H888/P9Ld5AdaPvCBD8Sb3/zmgTZZV0OBtra2OOKII2p4BF0TGHuB4c6MH/sKVUCgMQX896Ux53UsR5Vuwtnb2zuWJTg2gZoJpN/L82X69On5U48EGlJg6tSpMWXKlIYcm0ERSPfmyZfBcrR8e60fGyoAHS1W/v2f6WZF1113XcydOzfrIv0ymc4G/cxnPhN33nlnnH766fGa17wmu6HSrl27sn0Gu8FR+vBKy1CX0aft6ezTdMn+QMvzzz8/4rNYB2pvXWUCLS0t3Cuj02ocCbS3N/XH/jiaKaU2moD/7zXajI79ePYPiMa+GhUQqJ2Az8/a2eq5HAI+z8sxD6qovcBYf5439V/CF1xwQaTL5tO/oKfvDs2XFISlu7mnM0FTEPqVr3wlC0BTcp3u/r5z585BA848+Ozs7My780iAAAECBAgQIECAAAECBAgQIECAwBgJNHUAms7iPPnkkwelf+1rX5sFoE888UR29mcKQNNl8un7Pbdt2zZgu3z9cKewr1mzZsD2aWW6NP5Xv/rVoNttKFbgqKOOyjpMN8V69tlni+1cbwRKItDR0ZF9fqX3eHqvWwgQqK+A/67X17uRj5Z+H505c2Z2JVH+D++NPF5ja06BdNl7fkLJM888k/0t1pwSRt3oArNmzYp0I+YdO3Y0+lCNr0kF0gmHkydPzkb/3HPPZffhqYYiz28q6eN3F+NX0rrB26RfLtOyZ8+eyL/TM/+e0Tzo7E+QPrzS4nv2+st4TYAAAQIECBAgQIAAAQIECBAgQKD+Ak0dgN52223x+c9/PrvUfSD69K+NaUk3Nsq/8/PII4/M1q1fvz577P8/+fqhzizt38ZrAgQIECBAgAABAgQIECBAgAABAgRqI9DUAejKlSvjlltuiS9/+csD6t53333Z+lNOOaVve/rO0LSktv2Xnp6euOuuu7LV+Q2V+u/jNQECBAgQIECAAAECBAgQIECAAAEC9RNo6gD0rLPOyqRTaPn4448foP7ggw9GOkM0LRdeeGHftnRH+OOPPz7WrVsXy5cv71ufnqQwdePGjXHcccfFggULDtjmBQECBAgQIECAAAECBAgQIECAAAEC9Rdo6psgveMd74jVq1fHQw89FO973/ti/vz52c9jjz0Wd999dzYbS5YsiTlz5vTNTLpD/EUXXRRXXXVVXHfddZFuZjR79ux45JFHsufpRiOXXXZZpP0sBAgQIECAAAECBAgQIECAAAECBAiMrUBTB6BtbW3xqU99Kjtz89Zbb4101mf6ScuLXvSi+PCHPxzpjM/+yxlnnBE33HBDFoCmoDQPS9OZoZdcckmceuqp/Zt4TYAAAQIECBAgQIAAAQIECBAgQIDAGAg0dACagsp77713SNaJEydml7hfcMEF8ctf/jK2bNkSJ554YkydOnXIdvPmzcsukU+XvG/YsCHSzZFmzZoVra1N/a0CQ5rZSIAAAQIECBAgQIAAAQIECBAgQKDeAg0dgI4Gs729PY499tjsZzTtpk+fHunHQoAAAQIECBAgQIAAAQIECBAgQIBA+QScrli+OVERAQIECBAgQIAAAQIECBAgQIAAAQIFCTgDtCBI3RAgQIAAAQIEBhNYvHjxYJus309g2bJl+73ylAABAgQIECBAgEAxAs4ALcZRLwQIECBAgAABAgQIECBAgAABAgQIlFBAAFrCSVESAQIECBAgQIAAAQIECBAgQIAAAQLFCLgEvhhHvRAgQKD0AosWLSp9jQokQIAAAQIECBAgQIAAAQJFCzgDtGhR/REgQIAAAQIECBAgQIAAAQIECBAgUBoBAWhppkIhBAgQIECAAAECBAgQIECAAAECBAgULSAALVpUfwQIECBAgAABAgQIECBAgAABAgQIlEZAAFqaqVAIAQIECBAgQIAAAQIECBAgQIAAAQJFCwhAixbVHwECBAgQIECAAAECBAgQIECAAAECpREQgJZmKhRCgAABAgQIECBAgAABAgQIECBAgEDRAgLQokX1R4AAAQIECBAgQIAAAQIECBAgQIBAaQQEoKWZCoUQIECAAAECBAgQIECAAAECBAgQIFC0gAC0aFH9ESBAgAABAgQIECBAgAABAgQIECBQGgEBaGmmQiEECBAgQIAAAQIECBAgQIAAAQIECBQtIAAtWlR/BAgQIECAAAECBAgQIECAAAECBAiURkAAWpqpUAgBAgQIECBAgAABAgQIECBAgAABAkULCECLFtUfAQIECBAgQIAAAQIECBAgQIAAAQKlERCAlmYqFEKAAAECBAgQIECAAAECBAgQIECAQNECAtCiRfVHgAABAgQIECBAgAABAgQIECBAgEBpBASgpZkKhRAgQIAAAQIECBAgQIAAAQIECBAgULSAALRoUf0RIECAAAECBAgQIECAAAECBAgQIFAaAQFoaaZCIQQIECBAgAABAgQIECBAgAABAgQIFC0gAC1aVH8ECBAgQIAAAQIECBAgQIAAAQIECJRGQABamqlQCAECBAgQIECAAAECBAgQIECAAAECRQsIQIsW1R8BAgQIECBAgAABAgQIECBAgAABAqUREICWZioUQoAAAQIECBAgQIAAAQIECBAgQIBA0QIC0KJF9UeAAAECBAgQIECAAAECBAgQIECAQGkEBKClmQqFECBAgAABAgQIECBAgAABAgQIECBQtIAAtGhR/REgQIAAAQIECBAgQIAAAQIECBAgUBoBAWhppkIhBAgQIECAAAECBAgQIECAAAECBAgULSAALVpUfwQIECBAgAABAgQIECBAgAABAgQIlEZAAFqaqVAIAQIECBAgQIAAAQIECBAgQIAAAQJFCwhAixbVHwECBAgQIECAAAECBAgQIECAAAECpREQgJZmKhRCgAABAgQIECBAgAABAgQIECBAgEDRAgLQokX1R4AAAQIECBAgQIAAAQIECBAgQIBAaQQEoKWZCoUQIECAAAECBAgQIECAAAECBAgQIFC0gAC0aFH9ESBAgAABAgQIECBAgAABAgQIECBQGgEBaGmmQiEECBAgQIAAAQIECBAgQIAAAQIECBQtIAAtWlR/BAgQIECAAAECBAgQIECAAAECBAiURkAAWpqpUAgBAgQIECBAgAABAgQIECBAgAABAkULCECLFtUfAQIECBAgQIAAAQIECBAgQIAAAQKlERCAlmYqFEKAAAECBAgQIECAAAECBAgQIECAQNECAtCiRfVHgAABAgQIECBAgAABAgQIECBAgEBpBASgpZkKhRAgQIAAAQIECBAgQIAAAQIECBAgULSAALRoUf0RIECAAAECBAgQIECAAAECBAgQIFAaAQFoaaZCIQQIECBAgAABAgQIECBAgAABAgQIFC0gAC1aVH8ECBAgQIAAAQIECBAgQIAAAQIECJRGoL00lSikT6C9vT2OOOKIvtee1Eegra2Ne32oHYUAAQIECAwo4PefAVkGXNnV1RW9vb0DbrOSwHgXSL+X58v06dPzpx4JNKTA1KlTY8qUKQ05NoMi0Nr6u/Mup02bNqYgAtAx5R/44OmX2d27dw+80drCBVLgnBbuhdPqsEQC+/+Hp0RlKYUAAQIHCPj95wCOAV+0tLRE+t2lu7s79u3bN+A+VhIY7wITJ06MPAT1uTDeZ1P9QwlMnjw59u7dm/0MtZ9tBMarwIQJEyL/WzT97tLT01PVUPL8ppJOBKCVqNW4Tfpl9vnnn6/xUXSfC+T/2pb+j7h169Z8tUcCDSXQ0dHRUOMxGAIEGlPAf4eHn9f0R0T6g3nHjh3+wXx4LnuMU4H0e0segKa/i6r9g3mcMii7CQTS5/muXbuyz/QmGK4hNqFAumIlDy23b9+e/QNuNQx5flNJH787F7WS1toQIECAAAECBAgQIECAAAECBAgQIECgxAIC0BJPjtIIECBAgAABAgQIECBAgAABAgQIEKhOQABanZ/WBAgQIECAAAECBAgQIECAAAECBAiUWEAAWuLJURoBAgQIECBAgAABAgQIECBAgAABAtUJCECr89OaAAECBAgQIECAAAECBAgQIECAAIESCwhASzw5SiNAgAABAgQIECBAgAABAgQIECBAoDoBAWh1floTIECAAAECBAgQIECAAAECBAgQIFBiAQFoiSdHaQQIECBAgAABAgQIECBAgAABAgQIVCcgAK3OT2sCBAgQIECAAAECBAgQIECAAAECBEosIAAt8eQojQABAgQIECBAgAABAgQIECBAgACB6gQEoNX5aU2AAAECBAgQIECAAAECBAgQIECAQIkFBKAlnhylESBAgAABAgQIECBAgAABAgQIECBQnYAAtDo/rQkQIECAAAECBAgQIECAAAECBAgQKLGAALTEk6M0AgQIECBAgAABAgQIECBAgAABAgSqExCAVuenNQECBAgQIECAAAECBAgQIECAAAECJRYQgJZ4cpRGgAABAgQIECBAgAABAgQIECBAgEB1AgLQ6vy0JkCAAAECBAgQIECAAAECBAgQIECgxAIC0BJPjtIIECBAgAABAgQIECBAgAABAgQIEKhOQABanZ/WBAgQIECAAAECBAgQIECAAAECBAiUWEAAWuLJURoBAgQIECBAgAABAgQIECBAgAABAtUJCECr89OaAAECBAgQIECAAAECBAgQIECAAIESCwhASzw5SiNAgAABAgQIECBAgAABAgQIECBAoDoBAWh1floTIECAAAECBAgQIECAAAECBAgQIFBiAQFoiSdHaQQIECBAgAABAgQIECBAgAABAgQIVCcgAK3OT2sCBAgQIECAAAECBAgQIECAAAECBEosIAAt8eQojQABAgQIECBAgAABAgQIECBAgACB6gQEoNX5aU2AAAECBAgQIECAAAECBAgQIECAQIkFBKAlnhylESBAgAABAgQIECBAgAABAgQIECBQnYAAtDo/rQkQIECAAAECBAgQIECAAAECBAgQKLGAALTEk6M0AgQIECBAgAABAgQIECBAgAABAgSqExCAVuenNQECBAgQIECAAAECBAgQIECAAAECJRYQgJZ4cpRGgAABAgQIECBAgAABAgQIECBAgEB1AgLQ6vy0JkCAAAECBAgQIECAAAECBAgQIECgxAIC0BJPjtIIECBAgAABAgQIECBAgAABAgQIEKhOQABanZ/WBAgQIECAAAECBAgQIECAAAECBAiUWEAAWuLJURoBAgQIECBAgAABAgQIECBAgAABAtUJCECr89OaAAECBAgQIECAAAECBAgQIECAAIESCwhASzw5SiNAgAABAgQIECBAgAABAgQIECBAoDoBAWh1floTIECAAAECBAgQIECAAAECBAgQIFBiAQFoiSdHaQQIECBAgAABAgQIECBAgAABAgQIVCcgAK3OT2sCBAgQIECAAAECBAgQIECAAAECBEosIAAt8eQojQABAgQIECBAgAABAgQIECBAgACB6gQKD0C/8IUvxEc+8pF49NFHR1zZNddcE6985SvjE5/4xIjb2JEAAQIECBAgQIAAAQIECBAgQIAAAQLDCRQegH7zm9+MG2+8MZ544onhjt23fdWqVbFmzZpRhaZ9jT0hQIAAAQIECBAgQIAAAQIECBAgQIDAIALtg6yvy+p9+/bFunXr4sc//nF2vMmTJ9fluA5CgAABAgQIECBAgAABAgQIECBAgEBzCFQVgJ5zzjnxve997wCp7u7u7PUf/dEfRWvr0CeYpn17enr62r/85S/ve+4JAQIECBAgQIAAAQIECBAgQIAAAQIEqhWoKgD9+7//+zj11FMjDz33L2agdftv7//8pS99abz1rW/tv9prAgQIECBAgAABAgQIECBAgAABAgQIVCxQVQD6kpe8JD73uc/Ff//3f/cVsHz58vj5z38eb3zjG+PYY4/tWz/Qk46OjpgyZUqccMIJ8c53vjMOO+ywgXazjgABAgQIECBAgAABAgQIECBAgAABAhUJVBWApiNeeOGF2U9+9HRZfApAP/jBD0Z6biFAgAABAgQIECBAgAABAgQIECBAgMBYCVQdgPYv/D3veU+88pWvjDlz5vTfVPfXO3bsiEsvvTRmzZoVV1111aDH3717d9x+++3xwAMPxObNm2P27Nkxd+7cWLRoUbS1tQ3YrpI2A3ZkJQECBAgQIECAAAECBAgQIECAAAECNRMoPAA9//zza1bsaDru7e2Nq6++Oh555JFobx98mFu2bIklS5bEhg0bsu4PP/zwWLFiRfazevXqWLp0aXR2dh5w6EraHNCBFwQIECBAgAABAgcJLF68+KB1VgwscOuttw68wVoCBAgQIECAAIGDBAZPBg/adfQrfvOb38T//u//RjoTc+/evcN28Hu/93vZ2ZfD7jjMDjt37owbb7wxfvCDHwyzZ8Q111yThZ8LFiyIK6+8Mrq6uuLpp5+OK664Iu6555646aabsrNI9++okjb7t/ecAAECBAgQIECAAAECBAgQIECAAIH6CNQkAE2h59/8zd/EN77xjREFn/lQ09mWH//4x/OXFT2my9g/+clPxq9//etobW2Nnp6eQft59NFH4/77749JkybFtddeGxMnTsz2PeaYY+L666+P8847L9JNnS6++OI45JBDsm2VtBm0ABsIECBAgAABAgQIECBAgAABAgQIEKipQGvRvW/bti3OPffc7Ds1R3LWZ5HH/+53vxuXXHJJFn6mMzo/+tGPDtn9qlWrsu1nnnlmX/iZN0iXwp922mmxZ8+eLATN11fSJm/rkQABAgQIECBAgAABAgQIECBAgACB+goUfgZo+t7Nn/3sZ9ko0s2E/uRP/iSOP/747EZELS0tQ47upJNOGnL7cBs3bdoURx99dLz3ve+NN73pTXHvvfcO2WTt2rXZ9hSWDrSkAHTNmjXx8MMPxzvf+c5sl0raDNS3dQQIECBAgAABAgQIECBAgAABAgQI1F6g8AD0vvvuy6qeN29erFy5MtKZlPVaFi5cGG9729uGvOnR/rWk7/pMy7Rp0/Zf3fc8X5/fICltqKRNX4f7PUmX6qezSwdajjzyyDjssMMG2mRdDQVSQN//hlc1PJyuCdRVYKibwdW1EAcjQIAAgUIE0ud6uumnhUAjCux/4kxHR4f3eiNOsjH1CbS1tfk7tE/Dk0YTSO/vfEm/u+z/+Z6vr9djoQHovn374sc//nFW+/vf//66hp/poDNmzBiV2/bt27P986Czf+NDDz00W5Xvl17kz0fTpn+/6fWHPvShSGesDrSkmzG9+93vHmiTdTUUSP/HnD59eg2PoGsCBAgQIECAQDEC+e+pxfSmFwLlFajnCTXlVVBZIwtMnTo10o+FQKMLDJaj1WvchX4HaAqQpkyZktWezgAt85JujrRr166sxPwGR/3rzT+Edu/enW2qpE3/Pr0mQIAAAQIECBAgQIAAAQIECBAgQKB+AoWeAZrKfsUrXhHf+ta34sknn4xXvepV9RvJKI+U7hCf7v6+c+fOyAPO/l3k6/PLoitp07/P/PXb3/72vrNJ83X5Y/rO1PxM03ydx9oJ5KF9CrjT+8FCoBEF0ueXhQABAgQaRyD9Q366+spCoBEFJk6cGPllk/4uasQZNqZcYPLkydlX49X7BtL58T0SqLXAhAkT+r6mMuUtKXepZsnzm0r6KDwAPfvss7MA9Oabb453vetdldRUtzbpkvn0/Z7pzvUDLfn6/YEraTNQ33/1V3810Ops3ZYtW2Lr1q2DbrehWIF8ftP/EbkXa6u38gik78+yECBAgEDjCOzYsWPQf8RvnFEaSbMKpN9b8gD0+eefr/oP5mZ1NO7yC6QANP2DVvpMtxBoRIGurq6+ADT9g1Z3d3dVw8zzm0o6KfyUoPTdluedd16sWrUqPvzhDw8aLlZSbNFt8u8MzYPO/v3nYdj+NySqpE3/fr0mQIAAAQIECBAgQIAAAQIECBAgQKA+AoWfAbp27dq46KKL4v77749/+Id/iK9+9asxf/78OO644+KII44YclTp7NGzzjpryH2K3Jjutp6W9evXx+mnn35Q12l9Wk4++eS+bZW06WvsCQECBAgQIECAAAECBAgQIECAAAECdRUoPAD92Mc+Ft/+9rf7BvHss8/GihUr+l4P9aS9vb2uAejChQvjO9/5TqxcuTL+9E//9IDS0uXQd911V7Zu7ty5fdsqadPX2BMCBAgQIECAAAECBAgQIECAAAECBOoqUPgl8HWtvsqDpbM+0w2H1q1bF8uXLz+gt1tuuSU2btyYnbm6YMGCvm2VtOlr7AkBAgQIECBAgAABAgQIECBAgAABAnUVKPwM0K997WtR6R3M0t3+6rm0tLRkl+tfddVVcd1118WaNWti9uzZ8cgjj2TP05dvX3bZZZH2y5dK2uRtPRIgQIAAAQIECBAgQIAAAQIECBAgUF+BwgPQqVOn1ncEVR7tjDPOiBtuuCELQO++++5IP2lJZ4Zecsklceqppx50hEraHNSJFQQIECBAgAABAgQIECBAgAABAgQI1Fyg8AC05hWP4gApqLz33nuHbTFv3ry47bbbskveN2zYEOlGR7NmzYrW1sG/IaCSNsMWYgcCBAgQIECAAAECBAgQIECAAAECBAoVaOgAdLRS06dPj/QzmqWSNqPp374ECBAgQIAAAQIECBAgQIAAAQIECFQuUHgAmm4otGXLlooqOuaYY+Loo4+uqK1GBAgQIECAAAECBAgQIECAAAECBAgQ6C9QeAD6kY98JL797W/3P86IXn/84x+PpUuXjmhfOxEgQIAAAQIECBAgQIAAAQIECBAgQGA4gcG/5HK4lrYTIECAAAECBAgQIECAAAECBAgQIECg5AKFnwH60Y9+NP74j/940GHv27cvtm7dGk888UT853/+Z/b4pje9Kb74xS/GoYceOmg7GwgQIECAAAECBAgQIECAAAECBAgQIDBagcID0IULF464hquvvjrOO++87JL5T3/603HDDTeMuK0dCRAgQIAAAQIECBAgQIAAAQIECBAgMJzAmF4Cn874TN8Xmm589JnPfCbuuuuu4eq1nQABAgQIECBAgAABAgQIECBAgAABAiMWGNMANFXZ2dkZr3/967OCv//974+4cDsSIECAAAECBAgQIECAAAECBAgQIEBgOIExD0BTgS996UuzOu+9997h6rWdAAECBAgQIECAAAECBAgQIECAAAECIxYoRQC6atWqrOCOjo4RF25HAgQIECBAgAABAgQIECBAgAABAgQIDCcw5gFo+g7QlStXZnW+/OUvH65e2wkQIECAAAECBAgQIECAAAECBAgQIDBigcLvAv8f//EfsX79+iEL2Lt3b+zYsSMeeuihuOOOO7J9W1pa4o1vfOOQ7WwkQIAAAQIECBAgQIAAAQIECBAgQIDAaAQKD0D/5V/+Jbuz+2iKSPtedtll8Qd/8AejbWZ/AgQIECBAgAABAgQIECBAgAABAgQIDCpQeAA66JEG2TBv3rxYsmRJvO997xtkD6sJECBAgAABAgQIECBAgAABAgQIECBQmUDhAeiyZcti586dw1aTbng0bdq0mDx58rD72oEAAQIECBAgQIAAAQIECBAgQIAAAQKVCBQegB555JGV1KENAQIECBAgQIAAAQIECBAgQIAAAQIEChcoPAAdrMLnn38+Hn/88ZgwYUKkkPSwww6LdOMjCwECBAgQIECAAAECBAgQIECAAAECBGol0FqrjlO/a9eujbe+9a3xohe9KA455JCYO3dunHzyyTF9+vQ44ogj4qKLLooHH3ywliXomwABAgQIECBAgAABAgQIECBAgACBJhaoSQC6d+/e+Ou//utINzj65je/Gb/4xS8OIt64cWPcfPPNcfrpp8enPvWpg7ZbQYAAAQIECBAgQIAAAQIECBAgQIAAgWoFanIJ/N/+7d/2hZrpMvfXvOY1MWfOnDjuuONix44d8dRTT8WPfvSjePjhhyMPS2fNmhXvfe97qx2P9gQIECBAgAABAgQIECBAgAABAgQIEOgTKDwAfeihhyIFoGl55StfGZ/97GezM0H7jrjfk29961vxl3/5l/HEE0/EBz/4wTj33HOzO8Pvt4unBAgQIECAAAECBAgQIECAAAECBAgQqFig8Evgb7rppuju7o4TTjgh7rzzzkHDz1TxW97ylkgh6OTJkyPdJOmWW26peCAaEiBAgAABAgQIECBAgAABAgQIECBAoL9A4QFouqw9LUuXLh3R2ZynnHJKXHjhhVmbu+++O3v0PwQIECBAgAABAgQIECBAgAABAgQIEChCoNAAdN++ffHoo49mdZ122mkjri/fN303qIUAAQIECBAgQIAAAQIECBAgQIAAAQJFCRQagLa2tkZ7+/99rej27dtHXGO6MVJaurq6RtzGjgQIECBAgAABAgQIECBAgAABAgQIEBhOoNAANN3x/SUveUl2zPvuu2+4Y/dtv/fee7Pnv//7v9+3zhMCBAgQIECAAAECBAgQIECAAAECBAhUK1BoAJqKWbBgQVbTxz/+8Vi/fv2w9X3nO9/pu/nRvHnzht3fDgQIECBAgAABAgQIECBAgAABAgQIEBipQOEB6BVXXBFTp06N3/72t3HmmWfGl770pUjfDdp/2bZtW1x99dXx9re/PXp7eyOd/Xn++ef3381rAgQIECBAgAABAgQIECBAgAABAgQIVCzwf1/YWXHzgxseddRR8YlPfCI+9KEPxS9+8YvsDu+XXnppnHjiiXH88cfHnj174sknn4zHH3888u/+7OjoiC9/+cvR2dl5cIfWECBAgAABAgQIECBAgAABAgQIECBAoEKBwgPQVMdf/MVfxJw5c+L9739/FoJu3rw5Hnzwweynf51z586Nz372s+Hy9/4yXhMgQIAAAQIECBAgQIAAAQIECBAgUK1ATQLQVNTrXve6+J//+Z/43Oc+lz3+5Cc/iZ/+9KeRzvacPXt29nP22WfH4sWLo62trdpxaE+AAAECBAgQIECAAAECBAgQIECAAIGDBGoWgKYjdXV1xeWXX9530PRdn+lO8RYCBAgQIECAAAECBAgQIECAAAECBAjUQ6DwmyD1L3rXrl19q/YPP//rv/6r7ztA+3bwhAABAgQIECBAgAABAgQIECBAgAABAgUK1CwAvffee+Mtb3lLvOxlLxuw3He/+90xY8aMeNe73hWbNm0acB8rCRAgQIAAAQIECBAgQIAAAQIECBAgUI1ATQLQL33pS7Fw4cK444474mc/+1l25/f9i+zp6Ymnnnoqdu7cGbfeemvMnz8/1q5du/8unhMgQIAAAQIECBAgQIAAAQIECBAgQKBqgcID0HXr1sXFF18c3d3dWXFveMMbDgpA04avf/3r8ed//ufR2toaTz75ZFxwwQWRglELAQIECBAgQIAAAQIECBAgQIAAAQIEihIoPAC99tprY+/evTFz5sz43ve+F3feeWdMnTr1gHpT6HnOOefEP//zP8fKlSujvb09HnzwwbjlllsO2M8LAgQIECBAgAABAgQIECBAgAABAgQIVCNQeAC6evXqrJ7FixfH2WefPWxtZ511VvzZn/1Ztt/3v//9Yfe3AwECBAgQIECAAAECBAgQIECAAAECBEYqUGgAum/fvuxy9nTw888/f6Q1xKtf/eps35/85CcjbmNHAgQIECBAgAABAgQIECBAgAABAgQIDCdQaADa0tKSfadnOmi6DH6ky65du7JdJ06cONIm9iNAgAABAgQIECBAgAABAgQIECBAgMCwAoUGoOm7PY899tjsoPfcc8+wB893+MEPfpA9PfXUU/NVHgkQIECAAAECBAgQIECAAAECBAgQIFC1QKEBaKrmD//wD7Oili5dGj/72c+GLTDdBOlf//Vfs/3mz58/7P52IECAAAECBAgQIECAAAECBAgQIECAwEgFCg9AP/CBD0S6lH3btm1x+umnR7or/G9+85sD6unt7c2+K/QjH/lInHvuudHT0xMvf/nLR/W9oQd06AUBAgQIECBAgAABAgQIECBAgAABAgQGECg8AD3ppJPin/7pn7JDbd68Oa688sqYOXNmTJ06NU4++eR48YtfHJMmTYoTTjghbrzxxti5c2f2+t/+7d+ivb19gBKtIkCAAAECBAgQIECAAAECBAgQIECAQGUChQegqYzFixfHN77xjTjmmGP6qtq+fXv89Kc/jfXr18fu3bv71r/5zW+OH/3oR/GSl7ykb50nBAgQIECAAAECBAgQIECAAAECBAgQKEKgZqdcpu8CfcMb3hDpOz7vvPPOLPh85plnYvLkyZHOEk0/r371q+Oss84qYhz6IECAAAECBAgQIECAAAECBAgQIECAwEECNQtA05HSd4GmMzzTj4UAAQIECBAgQIAAAQIECBAgQIAAAQL1FqjJJfD1HoTjESBAgAABAgQIECBAgAABAgQIECBAYCCBmp4BOtABrRteoKWlJTo7O4ff0R6FCnAvlFNnJRNwk7mSTYhyCBAgUKVA+lzv7e2tshfNCZRTIP1eni8dHR3e6zmGx4YUSJ/n/v5vyKk1qBcE2tra+hzSe33/z/e+DXV60vLCL05+c6oT9kgPk24YNWXKlJHubj8CBAiMSGDRokUj2s9OBAgQIECgUQRWrFjRKEMxDgIECBAgQKAKAWeAVoFXq6bd3d3x7LPP1qp7/fYTOOKII7I1e/fujc2bN/fb6iWBxhBwBmhjzKNRECBAgMDoBPxOPTqvsuzd1dXVd0bcc8895wzQskyMOgoXmDFjRqQToHbu3Fl43zokUAaBQw45JLs/UKol5S0pd6lmyfObSvoQgFaiVoc21b4p6lBiQx6Ce0NOq0G9IDCWlxqYAAIECBAgMFYCfrcbK/nijrtv377o6ekprkM9ESiZQHqP+6wq2aQopzCB/T+/x/q97iZIhU2rjggQIECAAAECBAgQIECAAAECBAgQKJuAALRsM6IeAgQIECBAgAABAgQIECBAgAABAgQKExCAFkapIwIECBAgQIAAAQIECBAgQIAAAQIEyiYgAC3bjKiHAAECBAgQIECAAAECBAgQIECAAIHCBASghVHqiAABAgQIECBAgAABAgQIECBAgACBsgm4C3zZZkQ9BAiMWmDx4sWjbqMBAQIECBAgQIAAAQIECBAg0BwCzgBtjnk2SgIECBAgQIAAAQIECBAgQIAAAQJNKSAAbcppN2gCBAgQIECAAAECBAgQIECAAAECzSEgAG2OeTZKAgQIECBAgAABAgQIECBAgAABAk0pIABtymk3aAIECBAgQIAAAQIECBAgQIAAAQLNISAAbY55NkoCBAgQIECAAAECBAgQIECAAAECTSkgAG3KaTdoAgQIECBAgAABAgQIECBAgAABAs0hIABtjnk2SgIECBAgQIAAAQIECBAgQIAAAQJNKSAAbcppN2gCBAgQIECAAAECBAgQIECAAAECzSEgAG2OeTZKAgQIECBAgAABAgQIECBAgAABAk0pIABtymk3aAIECBAgQIAAAQIECBAgQIAAAQLNISAAbY55NkoCBAgQIECAAAECBAgQIECAAAECTSkgAG3KaTdoAgQIECBAgAABAgQIECBAgAABAs0hIABtjnk2SgIECBAgQIAAAQIECBAgQIAAAQJNKSAAbcppN2gCBAgQIECAAAECBAgQIECAAAECzSEgAG2OeTZKAgQIECBAgAABAgQIECBAgAABAk0pIABtymk3aAIECBAgQIAAAQIECBAgQIAAAQLNISAAbY55NkoCBAgQIECAAAECBAgQIECAAAECTSkgAG3KaTdoAgQIECBAgAABAgQIECBAgAABAs0hIABtjnk2SgIECBAgQIAAAQIECBAgQIAAAQJNKSAAbcppN2gCBAgQIECAAAECBAgQIECAAAECzSEgAG2OeTZKAgQIECBAgAABAgQIECBAgAABAk0pIABtymk3aAIECBAgQIAAAQIECBAgQIAAAQLNISAAbY55NkoCBAgQIECAAAECBAgQIECAAAECTSkgAG3KaTdoAgQIECBAgAABAgQIECBAgAABAs0hIABtjnk2SgIECBAgQIAAAQIECBAgQIAAAQJNKSAAbcppN2gCBAgQIECAAAECBAgQIECAAAECzSEgAG2OeTZKAgQIECBAgAABAgQIECBAgAABAk0pIABtymk3aAIECBAgQIAAAQIECBAgQIAAAQLNISAAbY55NkoCBAgQIECAAAECBAgQIECAAAECTSkgAG3KaTdoAgQIECBAgAABAgQIECBAgAABAs0hIABtjnk2SgIECBAgQIAAAQIECBAgQIAAAQJNKSAAbcppN2gCBAgQIECAAAECBAgQIECAAAECzSEgAG2OeTZKAgQIECBAgAABAgQIECBAgAABAk0pIABtymk3aAIECBAgQIAAAQIECBAgQIAAAQLNISAAbY55NkoCBAgQIECAAAECBAgQIECAAAECTSkgAG3KaTdoAgQIECBAgAABAgQIECBAgAABAs0hIABtjnk2SgIECBAgQIAAAQIECBAgQIAAAQJNKSAAbcppN2gCBAgQIECAAAECBAgQIECAAAECzSEgAG2OeTZKAgQIECBAgAABAgQIECBAgAABAk0pIABtymk3aAIECBAgQIAAAQIECBAgQIAAAQLNISAAbY55NkoCBAgQIECAAAECBAgQIECAAAECTSkgAG3KaTdoAgQIECBAgAABAgQIECBAgAABAs0hIABtjnk2SgIECBAgQIAAAQIECBAgQIAAAQJNKdDelKPeb9A7duyIL37xi/utOfjpOeecEyeddNIBG3bv3h233357PPDAA7F58+aYPXt2zJ07NxYtWhRtbW0H7OsFAQIECBAgQIAAAQIECBAgQIAAAQJjI9D0Aehjjz2WBZlD8adgc/8AdMuWLbFkyZLYsGFD1uzwww+PFStWZD+rV6+OpUuXRmdn51Bd2kaAAAECBAgQIECAAAECBAgQIECAQB0Emj4AXbduXcY8f/78OPvsswckT2d37r9cc801Wfi5YMGCuPLKK6OrqyuefvrpuOKKK+Kee+6Jm266KS699NL9m3hOgAABAgQIECBAgAABAgQIECBAgMAYCAhA/38AmsLPc889d9gpePTRR+P++++PSZMmxbXXXhsTJ07M2hxzzDFx/fXXx3nnnRfLly+Piy++OA455JBh+7MDAQIECBAgQIAAAQIECBAgQIAAAQK1E2j6myClS+DTMmfOnBEpr1q1KtvvzDPP7As/84bpUvjTTjst9uzZk4Wg+XqPBAgQIECAAAECBAgQIECAAAECBAiMjUBTB6B79+6N9evXR3t7e5x44onZDGzdujXSDY4GW9auXZttSpe/D7SkADQtDz/88ECbrSNAgAABAgQIECBAgAABAgQIECBAoI4CTX0J/FNPPRXd3d1x7LHHxq233hpf//rXY+PGjdHa2pqte8973hOvf/3rD5iO9F2faZk2bdoB6/MX+fr8Bkn5+v6PH/vYxyKFrQMt6TL6V73qVQNtsq6GAmneDzvssBoeQdcECBAgQIAAAQL1FPC7XT21iztWOkElX9L9FiwEGllg8uTJMWHChEYeorE1sUBHR0ff6NPXRPb29va9rveT3/2Xpd5HLsHx8hsg/fznP4+bb745ZsyYEelmSE8++WT2k2529MMf/jAuv/zyvmq3b9+ePc+Dzr4N///JoYcemj3L9+u/PX+dLqXftGlT/vKAx1e84hUHXV5/wA5e1EQgBaD5d7rW5AA6JUCAAAECBAgQqKuA3+3qyl2Tg5nDmrDqtEQCKSDaPyQqUWlKIVCowFgH/U0dgObf/5lS6Ouuuy7mzp2bTW5KpNPZoJ/5zGfizjvvjNNPPz1e85rXRE9PT+zatSvbZ7AbHE2dOjXbPtRl9IW+g3RGgAABAgQIECBAgAABAgQIECBAgMCgAk0dgF5wwQWxcOHCSJdVHH300X1ILS0t2d3c05mgKQj9yle+kgWg6QzBdPf3nTt3Dvo9oXnw2dnZ2dffQE/+/d//Pfbt2zfQpkhtn3322QG3WVm8wBFHHJF1mr4TdvPmzcUfQI8ECBAgQIAAAQJjIuB36jFhr/qg6e+z/O+p5557bkwvmax6MDogMIRAugr1+eef7zvRaohdbSIwLgXSyYP5mfwpb0m5SzVLnt9U0kdTB6BpIk4++eRB3V772tdmAejVa3W+AAA5ZklEQVQTTzyRnf2ZAtD0AZW+33Pbtm0DtsvXT5kyZcDt+crjjz8+f3rQ45YtW7KQ9aANVtRcoNr/M9a8QAcgQIAAAQIECBAYsYDf7UZMVdod00kj6Uo8C4FGFUjvb59VjTq7xrX/53f6PB/L93pT3wV+uLfizJkzs1327NkT+Xd6pgA0LXnQmb3Y73/yGxv5wvX9UDwlQIAAAQIECBAgQIAAAQIECBAgMEYCTR2A3nbbbfH5z38+u+HRQP7PPPNMtjrd2Cj/zs8jjzwyW7d+/fqBmkS+fqgzSwdsaCUBAgQIECBAgAABAgQIECBAgAABAoULNHUAunLlyrjlllviy1/+8oCw9913X7b+lFNO6duevjM0Lalt/yWd2nvXXXdlq/MbKvXfx2sCBAgQIECAAAECBAgQIECAAAECBOon0NQB6FlnnZVJp9Dy8ccfP0D9wQcfjHSGaFouvPDCvm3pjvDp+zvXrVsXy5cv71ufnqQwdePGjXHcccfFggULDtjmBQECBAgQIECAAAECBAgQIECAAAEC9Rdo6psgveMd74jVq1fHQw89FO973/ti/vz52c9jjz0Wd999dzYbS5YsiTlz5vTNTLpD/EUXXRRXXXVVXHfddbFmzZqYPXt2PPLII9nzjo6OuOyyyyLtZyFAgAABAgQIECBAgAABAgQIECBAYGwFmjoAbWtri0996lPZmZu33nprpLM+009aXvSiF8WHP/zhSGd89l/OOOOMuOGGG7IANAWleViazgy95JJL4tRTT+3fxGsCBAgQIECAAAECBAgQIECAAAECBMZAoKkD0OQ9ceLE7BL3Cy64IH75y1/Gli1b4sQTT4ypU6cOOR3z5s3LLpFPl7xv2LAh0s2RZs2aFa2tTf2tAkOa2UiAAAECBAgQIECAAAECBAgQIECg3gJNH4Dm4O3t7XHsscdmP/m6kTxOnz490o+FAAECBAgQIECAAAECBAgQIECAAIHyCThdsXxzoiICBAgQIECAAAECBAgQIECAAAECBAoSEIAWBKkbAgQIECBAgAABAgQIECBAgAABAgTKJyAALd+cqIgAAQIECBAgQIAAAQIECBAgQIAAgYIEBKAFQeqGAAECBAgQIECAAAECBAgQIECAAIHyCQhAyzcnKiJAgAABAgQIECBAgAABAgQIECBAoCABAWhBkLohQIAAAQIECBAgQIAAAQIECBAgQKB8AgLQ8s2JiggQIECAAAECBAgQIECAAAECBAgQKEhAAFoQpG4IECBAgAABAgQIECBAgAABAgQIECifgAC0fHOiIgIECBAgQIAAAQIECBAgQIAAAQIEChIQgBYEqRsCBAgQIECAAAECBAgQIECAAAECBMonIAAt35yoiAABAgQIECBAgAABAgQIECBAgACBggQEoAVB6oYAAQIECBAgQIAAAQIECBAgQIAAgfIJCEDLNycqIkCAAAECBAgQIECAAAECBAgQIECgIAEBaEGQuiFAgAABAgQIECBAgAABAgQIECBAoHwCAtDyzYmKCBAgQIAAAQIECBAgQIAAAQIECBAoSKC9oH50Q4AAAQIECBAgQIAAgVIJLF68uFT1lLWYZcuWlbU0dREgQIAAgUIEnAFaCKNOCBAgQIAAAQIECBAgQIAAAQIECBAoo4AAtIyzoiYCBAgQIECAAAECBAgQIECAAAECBAoREIAWwqgTAgQIECBAgAABAgQIECBAgAABAgTKKCAALeOsqIkAAQIECBAgQIAAAQIECBAgQIAAgUIEBKCFMOqEAAECBAgQIECAAAECBAgQIECAAIEyCghAyzgraiJAgAABAgQIECBAgAABAgQIECBAoBABAWghjDohQIAAAQIECBAgQIAAAQIECBAgQKCMAgLQMs6KmggQIECAAAECBAgQIECAAAECBAgQKERAAFoIo04IECBAgAABAgQIECBAgAABAgQIECijgAC0jLOiJgIECBAgQIAAAQIECBAgQIAAAQIEChEQgBbCqBMCBAgQIECAAAECBAgQIECAAAECBMooIAAt46yoiQABAgQIECBAgAABAgQIECBAgACBQgQEoIUw6oQAAQIECBAgQIAAAQIECBAgQIAAgTIKtJexKDURIPB/AosXL0ZBgAABAgQIECBAgAABAgQIECBQhYAzQKvA05QAAQIECBAgQIAAAQIECBAgQIAAgXILCEDLPT+qI0CAAAECBAgQIECAAAECBAgQIECgCgEBaBV4mhIgQIAAAQIECBAgQIAAAQIECBAgUG4BAWi550d1BAgQIECAAAECBAgQIECAAAECBAhUISAArQJPUwIECBAgQIAAAQIECBAgQIAAAQIEyi0gAC33/KiOAAECBAgQIECAAAECBAgQIECAAIEqBASgVeBpSoAAAQIECBAgQIAAAQIECBAgQIBAuQUEoOWeH9URIECAAAECBAgQIECAAAECBAgQIFCFgAC0CjxNCRAgQIAAAQIECBAgQIAAAQIECBAot4AAtNzzozoCBAgQIECAAAECBAgQIECAAAECBKoQEIBWgacpAQIECBAgQIAAAQIECBAgQIAAAQLlFhCAlnt+VEeAAAECBAgQIECAAAECBAgQIECAQBUCAtAq8DQlQIAAAQIECBAgQIAAAQIECBAgQKDcAgLQcs+P6ggQIECAAAECBAgQIECAAAECBAgQqEJAAFoFnqYECBAgQIAAAQIECBAgQIAAAQIECJRbQABa7vlRHQECBAgQIECAAAECBAgQIECAAAECVQgIQKvA05QAAQIECBAgQIAAAQIECBAgQIAAgXILtJe7vOasrq2tLaZNm9acgx/DUbe2tnIfQ3+HJkCAAAECBAgQGBuBsv3tkf4eypdDDz00f+qRQEMKTJo0KTo7OxtybAZFoKOjow9h6tSp0dvb2/e63k8EoPUWH8HxWlpaIoVxlvoLcK+/uSMSIECAAAECBAiMrUDZfgdOfw/lS9lqy+vySKAogfQeH8tQqKhx6IfAQAL9P8/H8r0uAB1ohsZ43d69e2Pbtm1jXEXzHP6oo47KBtvT0xObNm1qnoEbKQECBAgQIECAAIEXBMr2O/D06dP7zojbsmVLpN/TLQQaUWDWrFmxffv22LFjRyMOz5gIRFdXV0yePDmT2Lp1a3R3d1elkuc3lXTiNMNK1LQhQIAAAQIECBAgQIAAAQIECBAgQGBcCAhAx8U0KZIAAQIECBAgQIAAAQIECBAgQIAAgUoEBKCVqGlDgAABAgQIECBAgAABAgQIECBAgMC4EBCAjotpUiQBAgQIECBAgAABAgQIECBAgAABApUICEArUdOGAAECBAgQIECAAAECBAgQIECAAIFxISAAHRfTpEgCBAgQIECAAAECBAgQIECAAAECBCoREIBWoqYNAQIECBAgQIAAAQIECBAgQIAAAQLjQkAAOi6mSZEECBAgQIAAAQIECBAgQIAAAQIECFQiIACtRE0bAgQIECBAgAABAgQIECBAgAABAgTGhYAAdFxMkyIJECBAgAABAgQIECBAgAABAgQIEKhEQABaiZo2BAgQIECAAAECBAgQIECAAAECBAiMCwEB6LiYJkUSIECAAAECBAgQIECAAAECBAgQIFCJgAC0EjVtCBAgQIAAAQIECBAgQIAAAQIECBAYFwIC0HExTYokQIAAAQIECBAgQIAAAQIECBAgQKASAQFoJWraECBAgAABAgQIECBAgAABAgQIECAwLgQEoONimhRJgAABAgQIECBAgAABAgQIECBAgEAlAgLQStS0IUCAAAECBAgQIECAAAECBAgQIEBgXAgIQMfFNCmSAAECBAgQIECAAAECBAgQIECAAIFKBASglahpQ4AAAQIECBAgQIAAAQIECBAgQIDAuBAQgI6LaVIkAQIECBAgQIAAAQIECBAgQIAAAQKVCAhAK1HThgABAgQIECBAgAABAgQIECBAgACBcSEgAB0X06RIAgQIECBAgAABAgQIECBAgAABAgQqERCAVqKmDQECBAgQIECAAAECBAgQIECAAAEC40JAADoupkmRBAgQIECAAAECBAgQIECAAAECBAhUIiAArURNGwIECBAgQIAAAQIECBAgQIAAAQIExoWAAHRcTJMiCRAgQIAAAQIECBAgQIAAAQIECBCoRKC9kkbaECBAgAABAgQIECBAgEBjCCxevLgxBlKHUSxbtqwOR3EIAgQIEChawBmgRYvqjwABAgQIECBAgAABAgQIECBAgACB0ggIQEszFQohQIAAAQIECBAgQIAAAQIECBAgQKBoAQFo0aL6I0CAAAECBAgQIECAAAECBAgQIECgNAIC0NJMhUIIECBAgAABAgQIECBAgAABAgQIEChaQABatKj+CBAgQIAAAQIECBAgQIAAAQIECBAojYAAtDRToRACBAgQIECAAAECBAgQIECAAAECBIoWEIAWLao/AgQIECBAgAABAgQIECBAgAABAgRKIyAALc1UKIQAAQIECBAgQIAAAQIECBAgQIAAgaIFBKBFi+qPAAECBAgQIECAAAECBAgQIECAAIHSCAhASzMVCiFAgAABAgQIECBAgAABAgQIECBAoGgBAWjRovojQIAAAQIECBAgQIAAAQIECBAgQKA0Au2lqUQhBAgQIECAAAECBAgQIECgxAKLFy8ucXXlKW3ZsmXlKUYlBAgQeEHAGaDeBgQIECBAgAABAgQIECBAgAABAgQINKyAALRhp9bACBAgQIAAAQIECBAgQIAAAQIECBAQgHoPECBAgAABAgQIECBAgAABAgQIECDQsAIC0IadWgMjQIAAAQIECBAgQIAAAQIECBAgQMBNkLwH6i7gi8PrTu6ABAgQIECAAAECBAgQIECAAIGmFXAGaNNOvYETIECAAAECBAgQIECAAAECBAgQaHwBAWjjz7EREiBAgAABAgQIECBAgAABAgQIEGhaAQFo0069gRMgQIAAAQIECBAgQIAAAQIECBBofAEBaOPPsRESIECAAAECBAgQIECAAAECBAgQaFoBAWjTTr2BEyBAgAABAgQIECBAgAABAgQIEGh8AXeBr3COd+/eHbfffns88MADsXnz5pg9e3bMnTs3Fi1aFG1tbRX2qhkBAgQIECBAgAABAgQIECBAgAABAkUKCEAr0NyyZUssWbIkNmzYkLU+/PDDY8WKFdnP6tWrY+nSpdHZ2VlBz5oQIECAAAECBAgQIECAAAECBAgQIFCkgEvgK9C85pprsvBzwYIFcccdd8Q3v/nN+OpXvxovfvGL45577ombbrqpgl41IUCAAAECBAgQIECAAAECBAgQIECgaAEB6ChFH3300bj//vtj0qRJce2110ZXV1fWwzHHHBPXX399dvn78uXLY9u2baPs2e4ECBAgQIAAAQIECBAgQIAAAQIECBQt4BL4UYquWrUqa3HmmWfGxIkTD2idLoU/7bTTYs2aNZFC0He+850HbPeCAAECBAgQIECAAAECBAg0usDixYsbfYiFje9rX/taYX01ckfeUyOf3WXLlo185yba0xmgo5zstWvXZi3S5e8DLSkATcvDDz880GbrCBAgQIAAAQIECBAgQIAAAQIECBCoo4AzQEeJ/fTTT2ctpk2bNmDLfH1+g6QBd3ph5caNG2Pfvn0Dbu7p6YnWVtn0gDhWEiBAgAABAgQIECBAgACBBhFoaWnx93+DzGVZhlGmPCm9v/NlrN/rAtB8Jkb4uH379mzPPOjs3+zQQw/NVuX79d+ev37zm98cmzZtyl8e8HjllVfGu9/97gPWeUGAAAECBAgQIECAAAECBAg0lkDKEPIcobFGZjRjJTBz5syxOvSQx50+ffqQ22u9UQA6CuF0ZuauXbuyFocccsiALadOnZqt371794DbrYxYsWIFBgIECBAgQIAAAQIECBAgQIDAiATkCCNistMQAgLQIXD6b0qnEae7v+/cuTMGCzjz9Z2dnf2bH/D6ZS97WWzduvWAdfmLGTNmDNp/vo/H4gQmTJiQdZYC7u7u7uI61hOBEgmkyw3S59KePXuit7e3RJUphUBxAuk9nt7r6T2e3usWAo0okH+ep99Z0u8uFgKNKNDR0dF3SXD+91UjjtOYCKTfXdJX4w329XiECIx3gfb29mhra8uGUcTfonl+U4mLAHSUaimcTN/vuW3btgFb5uunTJky4PZ85T/+4z/mTw963LJly6CXxx+0sxVVCxx11FFZH+mPiMG+lqDqg+iAwBgLpD8k0ufXb3/729i7d+8YV+PwBGojcOSRR/b9guXzvDbGeh17gfQP8unStvQ7p2Bo7OdDBbURSJdJ5ieUpL+NhP21cdbr2AvMmjUr0tfn7dixY+yLUQGBGgh0dXXF5MmTs57TSYDVnnSW5zeVlOpOO6NUSwFCWvKgs3/z/KzOww47rP8mrwkQIECAAAECBAgQIECAAAECBAgQqLOAAHSU4OnskrSsX79+wJb5+pNPPnnA7VYSIECAAAECBAgQIECAAAECBAgQIFA/AQHoKK0XLlyYtVi5cuVBLdOlGXfddVe2fu7cuQdtt4IAAQIECBAgQIAAAQIECBAgQIAAgfoKCEBH6X366afH8ccfH+vWrYvly5cf0PqWW26JjRs3xnHHHRcLFiw4YJsXBAgQIECAAAECBAgQIECAAAECBAjUX8BNkEZpnu68edFFF8VVV10V1113XaxZsyZmz54djzzySPY83Wjksssuy+5CO8qu7U6AAAECBAgQIECAAAECBAgQIECAQMECzgCtAPSMM86IG264IdId2+6+++74whe+kIWf6czQv/u7v4tTTz21gl41IUCAAAECBAgQIECAAAECBAgQIECgaAFngFYoOm/evLjtttuyS943bNgQ6eZIKRBtbZUpV0iqGQECBAgQIECAAAECBAgQIECAAIHCBQSgVZJOnz490o+FAAECBAgQIECAAAECBAgQIECAAIHyCThdsXxzoiICBAgQIECAAAECBAgQIECAAAECBAoSEIAWBKkbAgQIECBAgAABAgQIECBAgAABAgTKJyAALd+cqIgAAQIECBAgQIAAAQIECBAgQIAAgYIEBKAFQeqGAAECBAgQIECAAAECBAgQIECAAIHyCQhAyzcnKiJAgAABAgQIECBAgAABAgQIECBAoCABAWhBkLohQIAAAQIECBAgQIAAAQIECBAgQKB8AgLQ8s2JiggQIECAAAECBAgQIECAAAECBAgQKEhAAFoQpG4IECBAgAABAgQIECBAgAABAgQIECifgAC0fHOiIgIECBAgQIAAAQIECBAgQIAAAQIEChIQgBYEqRsCBAgQIECAAAECBAgQIECAAAECBMonIAAt35yoiAABAgQIECBAgAABAgQIECBAgACBggRael9YCupLNwTGpcBLX/rSrO4TTjghvvWtb43LMSiaAAECBCJe97rXxa9+9auYMGFCPPjgg0gIECBAYJwKXHDBBX2f4/fcc08cfvjh43QkyiZAgEBzC1x++eVxxx13ZAhf+9rX4pRTThkzkPYxO7IDEyiJQHd3d1ZJ/liSspRBgAABAqMUSJ/j6ae11QUuo6SzOwECBEolkH+el6ooxRAgQIDAqAX27duX/X6eGvb09Iy6fZEN/IVQpKa+CBAgQIAAAQIECBAgQIAAAQIECBAolYAAtFTToRgCBAgQIECAAAECBAgQIECAAAECBIoUEIAWqakvAgQIECBAgAABAgQIECBAgAABAgRKJSAALdV0KIYAAQIECBAgQIAAAQIECBAgQIAAgSIFBKBFauqLAAECBAgQIECAAAECBAgQIECAAIFSCbT0vrCUqiLFEKizwIoVK7IjTpkyJV796lfX+egOR4AAAQJFCXz/+9+PnTt3RltbW7zuda8rqlv9ECBAgECdBe6/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HOLa5u+FDqdt6tSpY4cPH7bly5fb66+/bl/60pesa9eu9vWvfz3pjH6/1157zXULb926tfXs2dMNIZC0YczC0aNH7Z133nF+6kqu+6mf+vXrx2ydvErP3Zw5c6ygoMA9m9/61rfccxN3bcl7/v/Sli1bnJGcdF+bNm0aGjVs2PD/N4z5prFhGzVqZFu3brVHHnnE7r777pitWIUAAggggAACCKQIBIOhUxBAAAEEEEAAAQTKQSAIKGpmIffzxhtvJG666aZwWeuDgF9i7969iU8++SRc//LLLyemTZuWCMbKDNf5YwTBwcTChQszXsmrr76aCIKlhfbVMYLgU2LmzJmx+48YMSLc5+DBg0nbBON3Jnr37p0IZokPt/Ft0me3bt0SQQA1aR+/EAQN3Xm13V133eVXJ33eeeed7rgXXXRRIpgNPBHMBh57niAYl9i8eXPSvqWx8MEHH4Tn+/Wvfx17yEcffTQRBC/D7aLXr+9BYDcRBB0L7Ru9t7p3f/nLXxJBgLvQcdq1a5fYs2eP2//vf/97IgiMxm6zatWqQue4/fbbw22DgGciCJSHy76dwdiaiWCYg0QQHC20v19x3333JYJge6F9g+C5u79BoNvV6VmIKxs2bHDPgj9n6mcwxmwiGP81EfzHQNzu4bof/OAH7jynnHJKIgich+v5ggACCCCAAAIIpBOgC3zw5kVBAAEEEEAAAQTKW2DSpEmmWdCj5cILL7TatWtHV1kQaLNbbrnFZf1deeWV9tOf/tSuuOIKl/mnjDplAc6dOzdpH7/w8MMPWxCMtHfffdft3759e7v55ptNWXzK/NRERJqB/Tvf+Y7fpchPZW5eddVV9qc//cmCF06XwTlo0CCXvapMVZUg6OoyTINAoluO/rFgwQJ3Xq3r27dvtKrQ93379tnVV19tTz/9tMt6/eY3v2nnnHNOmFm5aNEil8moNpVV0TXLX12zg2C1y05U5u7gwYPdep/RuGTJElN7g4Bn2qbNmjXLXZ+yLJXlqHv15S9/2W2vTFfdF1ledtllFgRDXealZkevXr16uI2eDbUpXVGG7bx58+zUU0913kGw0mWZKqP0Jz/5iV133XWmDNHUoqEJlG356aefuizVHj162I033uiyh//973+7+57p2l555RWXoav2K1u0c+fObrzX/v37u3um8+m+6XkuanzP66+/3jVP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" width="672" /></p>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
